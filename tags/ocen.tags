BlendMode	$OCEN/sdl/mod.oc	/^enum BlendMode extern("SDL_BlendMode") {$/;"	f
Buffer	$OCEN/buffer.oc	/^struct Buffer {$/;"	f
BytesReader	$OCEN/buffer.oc	/^struct BytesReader {$/;"	f
CURSOR_TYPE_COUNT	$OCEN/sdl/mod.oc	/^[extern "SDL_NUM_SYSTEM_CURSORS"] const CURSOR_TYPE_COUNT: i32$/;"	f
CharIterator	$OCEN/mod.oc	/^struct CharIterator {$/;"	f
Chunk	$OCEN/image/png.oc	/^struct Chunk {$/;"	f
Color	$OCEN/image/mod.oc	/^struct Color {$/;"	f
Color	$OCEN/sdl/mod.oc	/^struct Color  {$/;"	f
ColorType	$OCEN/image/png.oc	/^enum ColorType {$/;"	f
Complex	$OCEN/complex.oc	/^struct Complex$/;"	f
Context	$OCEN/curl.oc	/^def Context::easy_setopt($/;"	f
Context	$OCEN/hash/sha256.oc	/^struct Context {$/;"	f
Cursor	$OCEN/sdl/mod.oc	/^struct Cursor$/;"	f
CursorType	$OCEN/sdl/mod.oc	/^enum CursorType extern("SDL_SystemCursor") {$/;"	f
DEFAULT_FORMAT	$OCEN/sdl/mixer.oc	/^[extern "MIX_DEFAULT_FORMAT"] const DEFAULT_FORMAT: u16$/;"	f
DT_DIR	$OCEN/fs.oc	/^    [extern] const DT_DIR: i32$/;"	f
DT_LNK	$OCEN/fs.oc	/^    [extern] const DT_LNK: i32$/;"	f
DT_REG	$OCEN/fs.oc	/^    [extern] const DT_REG: i32$/;"	f
Deque	$OCEN/deque.oc	/^struct Deque<T> {$/;"	f
Dir	$OCEN/fs.oc	/^    [extern "DIR"] struct Dir$/;"	f
DirectoryEntry	$OCEN/fs.oc	/^struct DirectoryEntry {$/;"	f
DirectoryIterator	$OCEN/fs.oc	/^struct DirectoryIterator {$/;"	f
Endian	$OCEN/mod.oc	/^enum Endian {$/;"	f
EntryType	$OCEN/fs.oc	/^enum EntryType {$/;"	f
ErrorContext	$OCEN/setjmp.oc	/^struct ErrorContext$/;"	f
Event	$OCEN/sdl/mod.oc	/^struct Event {$/;"	f
EventType	$OCEN/sdl/mod.oc	/^enum EventType extern("SDL_EventType") {$/;"	f
FFMPEGContext	$OCEN/video_renderer/ffmpeg.oc	/^struct FFMPEGContext {$/;"	f
FdSet	$OCEN/fcntl.oc	/^def FdSet::set(&this, fd: i32) => c_FD_SET(fd, this)$/;"	f
File	$OCEN/fs.oc	/^def File::write(&this, buf: untyped_ptr, size: u32): i32 {$/;"	f
FileMetadata	$OCEN/fs.oc	/^struct FileMetadata {$/;"	f
FileStat	$OCEN/fs.oc	/^    [extern "struct stat"] struct FileStat {$/;"	f
Font	$OCEN/sdl/ttf.oc	/^[extern "TTF_SizeText"]         def Font::get_text_size(&this, text: str, w: &i32, h: &i32)$/;"	f
GLOBAL_DEFAULT	$OCEN/curl.oc	/^[extern "CURL_GLOBAL_DEFAULT"] const GLOBAL_DEFAULT: u64$/;"	f
GLUT_DEPTH	$OCEN/glut.oc	/^[extern] const GLUT_DEPTH: i32$/;"	f
GLUT_DOUBLE	$OCEN/glut.oc	/^[extern] const GLUT_DOUBLE: i32$/;"	f
GLUT_RGB	$OCEN/glut.oc	/^[extern] const GLUT_RGB: i32$/;"	f
GL_COLOR_BUFFER_BIT	$OCEN/glut.oc	/^[extern] const GL_COLOR_BUFFER_BIT: i32$/;"	f
GL_DEPTH_BUFFER_BIT	$OCEN/glut.oc	/^[extern] const GL_DEPTH_BUFFER_BIT: i32$/;"	f
GL_DEPTH_TEST	$OCEN/glut.oc	/^[extern] const GL_DEPTH_TEST: i32$/;"	f
GL_LINES	$OCEN/glut.oc	/^[extern] const GL_LINES: i32$/;"	f
GL_MODELVIEW	$OCEN/glut.oc	/^[extern] const GL_MODELVIEW: i32$/;"	f
GL_POLYGON	$OCEN/glut.oc	/^[extern] const GL_POLYGON: i32$/;"	f
GL_PROJECTION	$OCEN/glut.oc	/^[extern] const GL_PROJECTION: i32$/;"	f
Heap	$OCEN/heap.oc	/^struct Heap<T> {$/;"	f
HostEnt	$OCEN/socket.oc	/^struct HostEnt {$/;"	f
INDEX_DELETED	$OCEN/compact_map.oc	/^const INDEX_DELETED: i32 = -2$/;"	f
INDEX_FREE	$OCEN/compact_map.oc	/^const INDEX_FREE: i32 = -1$/;"	f
INFINITY	$OCEN/math.oc	/^[extern "INFINITY"] const INFINITY: f64$/;"	f
INIT_EVERYTHING	$OCEN/sdl/mod.oc	/^[extern "SDL_INIT_EVERYTHING"]         const INIT_EVERYTHING: i32$/;"	f
Image	$OCEN/image/mod.oc	/^struct Image {$/;"	f
InterlaceMethod	$OCEN/image/png.oc	/^enum InterlaceMethod {$/;"	f
Item	$OCEN/compact_map.oc	/^struct Item<K, V> {$/;"	f
Item	$OCEN/map.oc	/^struct Item<K, V> {$/;"	f
Iterator	$OCEN/compact_map.oc	/^struct Iterator<K, V> {$/;"	f
Iterator	$OCEN/linkedlist.oc	/^struct Iterator<T> {$/;"	f
Iterator	$OCEN/map.oc	/^struct Iterator<K, V> {$/;"	f
Iterator	$OCEN/set.oc	/^struct Iterator<T> {$/;"	f
Iterator	$OCEN/vector.oc	/^struct Iterator<T> {$/;"	f
Key	$OCEN/sdl/mod.oc	/^enum Key extern("SDL_Scancode") {$/;"	f
KeyIterator	$OCEN/compact_map.oc	/^struct KeyIterator<K, V> {$/;"	f
KeyIterator	$OCEN/map.oc	/^struct KeyIterator<K, V> {$/;"	f
KeyState	$OCEN/midi.oc	/^struct KeyState {$/;"	f
KeyState	$OCEN/og/state.oc	/^struct KeyState {$/;"	f
KeyboardEvent	$OCEN/sdl/mod.oc	/^struct KeyboardEvent {$/;"	f
Keysym	$OCEN/sdl/mod.oc	/^struct Keysym {$/;"	f
LinkedList	$OCEN/linkedlist.oc	/^struct LinkedList<T> {$/;"	f
Location	$OCEN/span.oc	/^struct Location {$/;"	f
LogLevel	$OCEN/logging.oc	/^enum LogLevel {$/;"	f
Map	$OCEN/compact_map.oc	/^struct Map<K, V> {$/;"	f
Map	$OCEN/map.oc	/^struct Map<K, V> {$/;"	f
MidiFile	$OCEN/midi.oc	/^struct MidiFile {$/;"	f
Mode	$OCEN/heap.oc	/^enum Mode {$/;"	f
MouseButton	$OCEN/sdl/mod.oc	/^enum MouseButton extern("u8") {$/;"	f
MouseButtonEvent	$OCEN/sdl/mod.oc	/^struct MouseButtonEvent {$/;"	f
MouseState	$OCEN/og/state.oc	/^struct MouseState {$/;"	f
MouseWheel	$OCEN/og/state.oc	/^enum MouseWheel {$/;"	f
MouseWheelEvent	$OCEN/sdl/mod.oc	/^struct MouseWheelEvent {$/;"	f
NUM_SCANCODES	$OCEN/sdl/mod.oc	/^[extern "SDL_NUM_SCANCODES"]           const NUM_SCANCODES: i32$/;"	f
Node	$OCEN/linkedlist.oc	/^struct Node<T> {$/;"	f
Note	$OCEN/midi.oc	/^struct Note {$/;"	f
OC_NO_BACKTRACE	$OCEN/prelude.h	/^#ifndef OC_NO_BACKTRACE$/;"	f
Option	$OCEN/curl.oc	/^enum Option {$/;"	f
PIXELFORMAT_ABGR8888	$OCEN/sdl/mod.oc	/^[extern "SDL_PIXELFORMAT_ABGR8888"]    const PIXELFORMAT_ABGR8888: i32$/;"	f
PNG	$OCEN/image/png.oc	/^struct PNG {$/;"	f
Parser	$OCEN/bencode.oc	/^struct Parser {$/;"	f
Parser	$OCEN/json.oc	/^struct Parser {$/;"	f
Parser	$OCEN/midi.oc	/^struct Parser {$/;"	f
QOIDecoder	$OCEN/image/qoi.oc	/^struct QOIDecoder {$/;"	f
QOIEncoder	$OCEN/image/qoi.oc	/^struct QOIEncoder {$/;"	f
READ_END	$OCEN/video_renderer/ffmpeg.oc	/^const READ_END: u32 = 0$/;"	f
RENDERER_ACCELERATED	$OCEN/sdl/mod.oc	/^[extern "SDL_RENDERER_ACCELERATED"]    const RENDERER_ACCELERATED: i32$/;"	f
RGBA	$OCEN/image/qoi.oc	/^struct RGBA {$/;"	f
RandomState	$OCEN/random.oc	/^struct RandomState {$/;"	f
Rect	$OCEN/og/mod.oc	/^struct Rect {$/;"	f
Rect	$OCEN/sdl/mod.oc	/^struct Rect  {$/;"	f
Renderer	$OCEN/sdl/mod.oc	/^[extern "SDL_SetRenderDrawColor"]       def Renderer::set_draw_color(&this, r: i32, g: i32, b: i/;"	f
RotationDirection	$OCEN/image/mod.oc	/^enum RotationDirection {$/;"	f
SDLContext	$OCEN/video_renderer/sdl.oc	/^struct SDLContext {$/;"	f
SHA1Hash	$OCEN/hash/sha1.oc	/^struct SHA1Hash {$/;"	f
SHA256Hash	$OCEN/hash/sha256.oc	/^struct SHA256Hash {$/;"	f
SList	$OCEN/curl.oc	/^[extern "struct curl_slist"] struct SList$/;"	f
STDIN_FILENO	$OCEN/libc.oc	/^[extern] const STDIN_FILENO: i32$/;"	f
SVLineIterator	$OCEN/sv.oc	/^struct SVLineIterator {$/;"	f
SVNumberIterator	$OCEN/sv.oc	/^struct SVNumberIterator<T> {$/;"	f
SVPredicateIterator	$OCEN/sv.oc	/^struct SVPredicateIterator {$/;"	f
SVSplitIterator	$OCEN/sv.oc	/^struct SVSplitIterator {$/;"	f
SVWordIterator	$OCEN/sv.oc	/^struct SVWordIterator {$/;"	f
Scancode	$OCEN/sdl/mod.oc	/^struct Scancode$/;"	f
SeekMode	$OCEN/fs.oc	/^enum SeekMode {$/;"	f
Set	$OCEN/set.oc	/^struct Set<T> {$/;"	f
SinAddr	$OCEN/socket.oc	/^struct SinAddr {$/;"	f
SockAddr	$OCEN/socket.oc	/^[extern "struct sockaddr"] struct SockAddr$/;"	f
SockAddrIn	$OCEN/socket.oc	/^struct SockAddrIn {$/;"	f
Socket	$OCEN/socket.oc	/^struct Socket {$/;"	f
SocketMode	$OCEN/socket.oc	/^enum SocketMode {$/;"	f
SocketStatus	$OCEN/socket.oc	/^enum SocketStatus {$/;"	f
Sound	$OCEN/sdl/mixer.oc	/^[extern "Mix_Chunk"] struct Sound$/;"	f
Span	$OCEN/span.oc	/^struct Span {$/;"	f
State	$OCEN/mem.oc	/^typedef State = untyped_ptr$/;"	f
Status	$OCEN/curl.oc	/^[extern "curl_easy_strerror"] def Status::str(this): str$/;"	f
Stream	$OCEN/zlib.oc	/^    [extern "z_stream"] struct Stream {$/;"	f
Surface	$OCEN/sdl/mod.oc	/^struct Surface$/;"	f
TAU	$OCEN/math.oc	/^const TAU: f32 = PI * 2.0$/;"	f
TEXTUREACCESS_STREAMING	$OCEN/sdl/mod.oc	/^[extern "SDL_TEXTUREACCESS_STREAMING"] const TEXTUREACCESS_STREAMING: i32$/;"	f
Texture	$OCEN/sdl/mod.oc	/^[extern "SDL_UnlockTexture"]  def Texture::unlock(&this)$/;"	f
Thread	$OCEN/thread.oc	/^struct Thread {$/;"	f
Time	$OCEN/time.oc	/^[extern "time_t"] struct Time {}$/;"	f
TimeVal	$OCEN/time.oc	/^[extern "struct timeval"] struct TimeVal {$/;"	f
Track	$OCEN/midi.oc	/^struct Track {$/;"	f
Value	$OCEN/value.oc	/^struct Value {$/;"	f
ValueIterator	$OCEN/compact_map.oc	/^struct ValueIterator<K, V> {$/;"	f
ValueIterator	$OCEN/map.oc	/^struct ValueIterator<K, V> {$/;"	f
ValueType	$OCEN/value.oc	/^enum ValueType {$/;"	f
VarArgs	$OCEN/variadic.oc	/^[extern "va_start"] def VarArgs::start(this, ...)$/;"	f
Vec2	$OCEN/vec.oc	/^struct Vec2<T> {$/;"	f
Vec2f	$OCEN/vec.oc	/^typedef Vec2f = Vec2<f32>$/;"	f
Vec2f64	$OCEN/vec.oc	/^typedef Vec2f64 = Vec2<f64>$/;"	f
Vec2i	$OCEN/vec.oc	/^typedef Vec2i = Vec2<i32>$/;"	f
Vec2i64	$OCEN/vec.oc	/^typedef Vec2i64 = Vec2<i64>$/;"	f
Vec2u	$OCEN/vec.oc	/^typedef Vec2u = Vec2<u32>$/;"	f
Vec2u64	$OCEN/vec.oc	/^typedef Vec2u64 = Vec2<u64>$/;"	f
Vec3	$OCEN/vec.oc	/^struct Vec3<T> {$/;"	f
Vec3f	$OCEN/vec.oc	/^typedef Vec3f = Vec3<f32>$/;"	f
Vec3f64	$OCEN/vec.oc	/^typedef Vec3f64 = Vec3<f64>$/;"	f
Vec3i	$OCEN/vec.oc	/^typedef Vec3i = Vec3<i32>$/;"	f
Vec3i64	$OCEN/vec.oc	/^typedef Vec3i64 = Vec3<i64>$/;"	f
Vec3u	$OCEN/vec.oc	/^typedef Vec3u = Vec3<u32>$/;"	f
Vec3u64	$OCEN/vec.oc	/^typedef Vec3u64 = Vec3<u64>$/;"	f
Vector	$OCEN/vector.oc	/^struct Vector<T> {$/;"	f
VideoRenderer	$OCEN/video_renderer/mod.oc	/^struct VideoRenderer {$/;"	f
VideoRendererType	$OCEN/video_renderer/mod.oc	/^enum VideoRendererType {$/;"	f
WEXITSTATUS	$OCEN/libc.oc	/^[extern] def WEXITSTATUS(a: i32): i32$/;"	f
WIFEXITED	$OCEN/libc.oc	/^[extern] def WIFEXITED(a: i32): bool$/;"	f
WIFSIGNALED	$OCEN/libc.oc	/^[extern] def WIFSIGNALED(a: i32): bool$/;"	f
WINDOWPOS_CENTERED	$OCEN/sdl/mod.oc	/^[extern "SDL_WINDOWPOS_CENTERED"]      const WINDOWPOS_CENTERED: i32$/;"	f
WINDOW_FULLSCREEN	$OCEN/sdl/mod.oc	/^[extern "SDL_WINDOW_FULLSCREEN"]       const WINDOW_FULLSCREEN: i32$/;"	f
WINDOW_FULLSCREEN_DESKTOP	$OCEN/sdl/mod.oc	/^[extern "SDL_WINDOW_FULLSCREEN_DESKTOP"] const WINDOW_FULLSCREEN_DESKTOP: i32$/;"	f
WINDOW_RESIZABL	$OCEN/sdl/mod.oc	/^[extern "SDL_WINDOW_RESIZABL"]         const WINDOW_RESIZABL: i32$/;"	f
WINDOW_RESIZABLE	$OCEN/sdl/mod.oc	/^[extern "SDL_WINDOW_RESIZABLE"]        const WINDOW_RESIZABLE: i32$/;"	f
WRITE_END	$OCEN/video_renderer/ffmpeg.oc	/^const WRITE_END: u32 = 1$/;"	f
WTERMSIG	$OCEN/libc.oc	/^[extern] def WTERMSIG(a: i32): i32$/;"	f
Window	$OCEN/sdl/mod.oc	/^[extern "SDL_Window"] struct Window$/;"	f
WindowMode	$OCEN/sdl/mod.oc	/^enum WindowMode extern("int") {$/;"	f
WriteCallback	$OCEN/curl.oc	/^typedef WriteCallback = fn(untyped_ptr, u64, u64, untyped_ptr): u64$/;"	f
Z_NO_FLUSH	$OCEN/zlib.oc	/^    [extern] const Z_NO_FLUSH: i32$/;"	f
Z_OK	$OCEN/zlib.oc	/^    [extern] const Z_OK: i32$/;"	f
Z_STREAM_END	$OCEN/zlib.oc	/^    [extern] const Z_STREAM_END: i32$/;"	f
__APPLE__	$OCEN/prelude.h	/^#ifdef __APPLE__$/;"	f
abs	$OCEN/complex.oc	/^[extern "cabsf"] def Complex::abs(this): f32$/;"	f
abs	$OCEN/math.oc	/^def i8::abs(this): i8 => if this < 0 then -this else this$/;"	f
accept	$OCEN/socket.oc	/^[extern] def accept(sockfd: i32, addr: &SockAddr, addrlen: &i32): i32$/;"	f
acos	$OCEN/complex.oc	/^[extern "cacosf"] def Complex::acos(this): Complex$/;"	f
acos	$OCEN/math.oc	/^[extern "acos"] def f32::acos(this): f32$/;"	f
add	$OCEN/complex.oc	/^def Complex::add(this, other: Complex): Complex {$/;"	f
add	$OCEN/set.oc	/^def Set::add(&this, key: T) {$/;"	f
add	$OCEN/vec.oc	/^[operator "+"] def Vec3::add(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x + other.x, .y + other./;"	f
addrs	$OCEN/vec.oc	/^[operator "+"] def Vec3::addrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val + this.x, val + th/;"	f
adds	$OCEN/vec.oc	/^[operator "+"] def Vec3::adds(this, val: T): Vec3<T> => Vec3<T>(.x + val, .y + val, .z + val)$/;"	f
alloc	$OCEN/mem.oc	/^def alloc<T>(count: u32 = 1): &T {$/;"	f
allocate_channels	$OCEN/sdl/mixer.oc	/^[extern "Mix_AllocateChannels"] def allocate_channels(num: i32): i32$/;"	f
append	$OCEN/curl.oc	/^[extern "curl_slist_append"] def SList::append(&this, string: str): &SList$/;"	f
arg	$OCEN/complex.oc	/^[extern "cargf"] def Complex::arg(this): f32$/;"	f
as_bool	$OCEN/value.oc	/^def Value::as_bool(&this): bool {$/;"	f
as_dict	$OCEN/value.oc	/^def Value::as_dict(&this): &Map<str, &Value> {$/;"	f
as_float	$OCEN/value.oc	/^def Value::as_float(&this): f64 {$/;"	f
as_int	$OCEN/value.oc	/^def Value::as_int(&this): i64 {$/;"	f
as_list	$OCEN/value.oc	/^def Value::as_list(&this): &Vector<&Value> {$/;"	f
as_str	$OCEN/value.oc	/^def Value::as_str(&this): Buffer {$/;"	f
asin	$OCEN/complex.oc	/^[extern "casinf"] def Complex::asin(this): Complex$/;"	f
asin	$OCEN/math.oc	/^[extern "asin"] def f32::asin(this): f32$/;"	f
at_key	$OCEN/value.oc	/^def Value::at_key(&this, key: str): &Value {$/;"	f
at_ptr	$OCEN/vector.oc	/^def Vector::at_ptr(&this, i: u32 = 0): &T {$/;"	f
atan	$OCEN/complex.oc	/^[extern "catanf"] def Complex::atan(this): Complex$/;"	f
atan2	$OCEN/complex.oc	/^[extern "catan2f"] def Complex::atan2(this, other: Complex): Complex$/;"	f
atan2	$OCEN/math.oc	/^[extern "atan2f"] def f32::atan2(this, y: f32): f32$/;"	f
atexit	$OCEN/libc.oc	/^[extern] def atexit(callback: fn())$/;"	f
back	$OCEN/deque.oc	/^def Deque::back(&this): T {$/;"	f
back	$OCEN/vector.oc	/^def Vector::back(&this, i: u32 = 0): T {$/;"	f
back_ptr	$OCEN/vector.oc	/^def Vector::back_ptr(&this, i: u32 = 0): &T {$/;"	f
bilinear_interp	$OCEN/image/mod.oc	/^def bilinear_interp(t0: f32, t1: f32, a: f32, b: f32, c: f32, d: f32):f32 {$/;"	f
bind	$OCEN/socket.oc	/^[extern] def bind(sockfd: i32, addr: &SockAddr, addrlen: i32): i32$/;"	f
bool	$OCEN/traits/eq.oc	/^def bool::eq(this, other: bool): bool => this == other$/;"	f
builtin_trap	$OCEN/mod.oc	/^[extern "oc_trap"] def builtin_trap()$/;"	f
c_FD_SET	$OCEN/fcntl.oc	/^[extern "FD_SET"] def c_FD_SET(fd: i32, set: &FdSet)$/;"	f
calloc	$OCEN/mem.oc	/^    [extern] def calloc(size: u32, elem_size: u32): untyped_ptr$/;"	f
ceil	$OCEN/math.oc	/^[extern "ceilf"] def f32::ceil(this): f32$/;"	f
char	$OCEN/mod.oc	/^def char::is_upper(this): bool => libc::isupper(this)$/;"	f
char	$OCEN/traits/eq.oc	/^def char::eq(this, other: char): bool => this == other$/;"	f
char	$OCEN/traits/hash.oc	/^def char::hash(this): u32 => this as u32 * 7817$/;"	f
chars	$OCEN/mod.oc	/^def str::chars(this, start: u32 = 0): CharIterator => CharIterator(this, this.len(), start)$/;"	f
chars	$OCEN/sv.oc	/^def SV::chars(this, start: u32 = 0): std::CharIterator => std::CharIterator(.data, .len, start)$/;"	f
chop_by_delim	$OCEN/sv.oc	/^def SV::chop_by_delim(&this, delim: char): SV {$/;"	f
chop_by_str	$OCEN/sv.oc	/^def SV::chop_by_str(&this, delim: str): SV => .chop_by_sv(SV::from_str(delim))$/;"	f
chop_by_sv	$OCEN/sv.oc	/^def SV::chop_by_sv(&this, delim: SV): SV {$/;"	f
chop_f32	$OCEN/sv.oc	/^def SV::chop_f32(&this): f32 {$/;"	f
chop_i16	$OCEN/sv.oc	/^def SV::chop_i16(&this): i16 => .chop_signed("SV::chop_i16") as i16$/;"	f
chop_i32	$OCEN/sv.oc	/^def SV::chop_i32(&this): i32 => .chop_signed("SV::chop_i32") as i32$/;"	f
chop_i64	$OCEN/sv.oc	/^def SV::chop_i64(&this): i64 => .chop_signed("SV::chop_i64") as i64$/;"	f
chop_i8	$OCEN/sv.oc	/^def SV::chop_i8(&this): i8 => .chop_signed("SV::chop_i8") as i8$/;"	f
chop_left	$OCEN/sv.oc	/^def SV::chop_left(&this, n: u32 = 1): SV {$/;"	f
chop_line	$OCEN/sv.oc	/^def SV::chop_line(&this): SV => .chop_by_delim('\\n')$/;"	f
chop_right	$OCEN/sv.oc	/^def SV::chop_right(&this, n: u32 = 1): SV {$/;"	f
chop_signed	$OCEN/sv.oc	/^def SV::chop_signed(&this, fn_name: str): i64 {$/;"	f
chop_u16	$OCEN/sv.oc	/^def SV::chop_u16(&this): u16 => .chop_unsigned("SV::chop_u16") as u16$/;"	f
chop_u32	$OCEN/sv.oc	/^def SV::chop_u32(&this): u32 => .chop_unsigned("SV::chop_u32") as u32$/;"	f
chop_u64	$OCEN/sv.oc	/^def SV::chop_u64(&this): u64 => .chop_unsigned("SV::chop_u64") as u64$/;"	f
chop_u8	$OCEN/sv.oc	/^def SV::chop_u8(&this): u8 => .chop_unsigned("SV::chop_u8") as u8$/;"	f
chop_unsigned	$OCEN/sv.oc	/^def SV::chop_unsigned(&this, fn_name: str): u64 {$/;"	f
chop_word	$OCEN/sv.oc	/^def SV::chop_word(&this): SV {$/;"	f
circle	$OCEN/image/draw.oc	/^def circle(img: &Image, x: i32, y: i32, radius: i32, color: Color, segments: u32 = 100) {$/;"	f
circle_f	$OCEN/image/draw.oc	/^def circle_f(img: &Image, x: f32, y: f32, radius: f32, color: Color, segments: u32 = 100) {$/;"	f
clamp	$OCEN/math.oc	/^def f64::clamp(this, min: f64, max: f64): f64 => f64::max(f64::min(this, max), min)$/;"	f
clamp01	$OCEN/math.oc	/^def f64::clamp01(this): f64 => this.clamp(0.0, 1.0)$/;"	f
clear	$OCEN/buffer.oc	/^def Buffer::clear(&this) {$/;"	f
clear	$OCEN/compact_map.oc	/^def Map::clear(&this) {$/;"	f
clear	$OCEN/heap.oc	/^def Heap::clear(&this) {$/;"	f
clear	$OCEN/image/mod.oc	/^def Image::clear(&this) {$/;"	f
clear	$OCEN/map.oc	/^def Map::clear(&this) {$/;"	f
clear	$OCEN/og/mod.oc	/^def clear(col: Color) {$/;"	f
clear	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderClear"]     def Renderer::clear(&this)$/;"	f
clear	$OCEN/set.oc	/^def Set::clear(&this) {$/;"	f
clear	$OCEN/vector.oc	/^def Vector::clear(&this) {$/;"	f
close	$OCEN/fs.oc	/^[extern "fclose"] def File::close(&this)$/;"	f
close	$OCEN/libc.oc	/^[extern] def close(a: i32): i32$/;"	f
close	$OCEN/sdl/ttf.oc	/^[extern "TTF_CloseFont"]        def Font::close(&this)$/;"	f
close	$OCEN/socket.oc	/^[extern] def close(fd: i32): i32/;"	f
closedir	$OCEN/fs.oc	/^    [extern] def closedir(dir: &Dir)$/;"	f
compare	$OCEN/complex.oc	/^def Complex::compare(this, other: Complex): i8 {$/;"	f
compare	$OCEN/traits/compare.oc	/^def u8::compare(this, b: u8): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
compress	$OCEN/zlib.oc	/^def compress(data: Buffer): Buffer {$/;"	f
compress_str	$OCEN/zlib.oc	/^def compress_str(s: str): Buffer => compress(Buffer::from_str(s))$/;"	f
concat	$OCEN/mod.oc	/^[extern "strcat"] def str::concat(this, src: str)$/;"	f
conj	$OCEN/complex.oc	/^[extern "conjf"] def Complex::conj(this): Complex$/;"	f
connect	$OCEN/socket.oc	/^def Socket::connect(host: str, port: i32, mode: SocketMode, timeout_secs: i32 = -1): Socket {$/;"	f
consume	$OCEN/json.oc	/^def Parser::consume(&this, type: TokenType): &Token {$/;"	f
contains	$OCEN/compact_map.oc	/^def Map::contains(&this, key: K): bool {$/;"	f
contains	$OCEN/map.oc	/^def Map::contains(&this, key: K): bool {$/;"	f
contains	$OCEN/og/mod.oc	/^def Rect::contains(this, pos: Vec2i): bool {$/;"	f
contains	$OCEN/set.oc	/^def Set::contains(&this, key: T): bool => .map.contains(key)$/;"	f
contains	$OCEN/sv.oc	/^def SV::contains(this, c: char): bool => .count(c) > 0$/;"	f
contains	$OCEN/value.oc	/^def Value::contains(&this, key: str): bool {$/;"	f
contains_loc	$OCEN/span.oc	/^def Span::contains_loc(this, loc: Location): bool {$/;"	f
copy	$OCEN/buffer.oc	/^def Buffer::copy(&this): Buffer {$/;"	f
copy	$OCEN/image/mod.oc	/^def Image::copy(&this): &Image {$/;"	f
copy	$OCEN/mod.oc	/^[extern "strdup"] def str::copy(this): str$/;"	f
copy	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderCopy"]      def Renderer::copy(&this, texture: &Texture, src: &Rect, dst: &Re/;"	f
copy_data_to_cstr	$OCEN/sv.oc	/^def SV::copy_data_to_cstr(this): str {$/;"	f
copy_ex	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderCopyEx"]    def Renderer::copy_ex(&this, texture: &Texture, src: &Rect, dst: /;"	f
cos	$OCEN/complex.oc	/^[extern "ccosf"] def Complex::cos(this): Complex$/;"	f
cos	$OCEN/math.oc	/^[extern "cosf"] def f32::cos(this): f32$/;"	f
count	$OCEN/sv.oc	/^def SV::count(this, c: char): u64 {$/;"	f
create	$OCEN/video_renderer/ffmpeg.oc	/^def FFMPEGContext::create(width: u32, height: u32, fps: u32, out_name: str, verbose: bool = fals/;"	f
create	$OCEN/video_renderer/mod.oc	/^def VideoRenderer::create(type: VideoRendererType, width: u32, height: u32, fps: u32, out_name: /;"	f
create	$OCEN/video_renderer/sdl.oc	/^def SDLContext::create(width: u32, height: u32, fps: u32): &SDLContext {$/;"	f
create_directory	$OCEN/fs.oc	/^def create_directory(path: str, exists_ok: bool = false) {$/;"	f
create_renderer	$OCEN/sdl/mod.oc	/^[extern "SDL_CreateRenderer"]           def Window::create_renderer(&this, index: i32, flags: i3/;"	f
create_system_cursor	$OCEN/sdl/mod.oc	/^[extern "SDL_CreateSystemCursor"] def create_system_cursor(cursor: CursorType): &Cursor$/;"	f
create_texture	$OCEN/sdl/mod.oc	/^[extern "SDL_CreateTexture"]   def Renderer::create_texture(&this, format: i32, access: i32, w: /;"	f
create_texture_from_surface	$OCEN/sdl/mod.oc	/^[extern "SDL_CreateTextureFromSurface"] def Renderer::create_texture_from_surface(&this, surface/;"	f
create_window	$OCEN/sdl/mod.oc	/^[extern "SDL_CreateWindow"]            def create_window(title: str, x: i32, y: i32, w: i32, h: /;"	f
create_window_renderer	$OCEN/sdl/mod.oc	/^[extern "SDL_CreateWindowAndRenderer"]  def create_window_renderer(width: i32, height: i32, flag/;"	f
cross	$OCEN/vec.oc	/^def Vec3::cross(this, other: Vec3<T>): Vec3<T> {$/;"	f
cur	$OCEN/bencode.oc	/^def Parser::cur(&this): char => .input.data[.loc.index] as char$/;"	f
cur	$OCEN/compact_map.oc	/^def ValueIterator::cur(&this): V => .iter.cur().value$/;"	f
cur	$OCEN/fs.oc	/^def DirectoryIterator::cur(&this): DirectoryEntry {$/;"	f
cur	$OCEN/linkedlist.oc	/^def Iterator::cur(&this): T => .node.value/;"	f
cur	$OCEN/map.oc	/^def ValueIterator::cur(&this): V => .map_iter.cur().value$/;"	f
cur	$OCEN/mod.oc	/^def CharIterator::cur(&this): char => .data[.pos]$/;"	f
cur	$OCEN/set.oc	/^def Iterator::cur(&this): T => .map_iter.cur().key$/;"	f
cur	$OCEN/sv.oc	/^def SVWordIterator::cur(&this): SV => .sv.chop_word()$/;"	f
cur	$OCEN/vector.oc	/^def Iterator::cur(&this): T {$/;"	f
dbg	$OCEN/value.oc	/^def Value::dbg(&this): str {$/;"	f
decode	$OCEN/image/png.oc	/^def decode(data: &Buffer): &Image {$/;"	f
decode	$OCEN/image/ppm.oc	/^def decode(data: &Buffer): &Image {$/;"	f
decode	$OCEN/image/qoi.oc	/^def decode(data: &Buffer): &Image {$/;"	f
decode_op_diff	$OCEN/image/qoi.oc	/^def QOIDecoder::decode_op_diff(&this, first: u8) {$/;"	f
decode_op_index	$OCEN/image/qoi.oc	/^def QOIDecoder::decode_op_index(&this, first: u8) {$/;"	f
decode_op_luma	$OCEN/image/qoi.oc	/^def QOIDecoder::decode_op_luma(&this, first: u8) {$/;"	f
decode_op_rgb	$OCEN/image/qoi.oc	/^def QOIDecoder::decode_op_rgb(&this) {$/;"	f
decode_op_rgba	$OCEN/image/qoi.oc	/^def QOIDecoder::decode_op_rgba(&this) {$/;"	f
decode_op_run	$OCEN/image/qoi.oc	/^def QOIDecoder::decode_op_run(&this, first: u8) {$/;"	f
decode_pixels	$OCEN/image/qoi.oc	/^def QOIDecoder::decode_pixels(&this) {$/;"	f
decode_scanline	$OCEN/image/png.oc	/^def PNG::decode_scanline(&this, out: &Buffer, scanline: u32, sv: SV) {$/;"	f
decompress	$OCEN/zlib.oc	/^def decompress(data: Buffer, bytes_consumed: &u32 = null): Buffer {$/;"	f
decompress_bytes	$OCEN/zlib.oc	/^def decompress_bytes(data: &u8, size: u32, bytes_consumed: &u32): Buffer {$/;"	f
default	$OCEN/span.oc	/^def Span::default(): Span {$/;"	f
degrees	$OCEN/math.oc	/^def degrees(radians: f32): f32 { return radians * 180.0 \/ PI; }$/;"	f
delay	$OCEN/sdl/mod.oc	/^[extern "SDL_Delay"]                   def delay(ms: i32)$/;"	f
destroy	$OCEN/sdl/mod.oc	/^[extern "SDL_FreeSurface"] def Surface::destroy(&this)$/;"	f
directory_exists	$OCEN/fs.oc	/^def directory_exists(path: str): bool {$/;"	f
dirent	$OCEN/fs.oc	/^    [extern "struct dirent"] struct dirent {$/;"	f
div	$OCEN/complex.oc	/^def Complex::div(this, other: Complex): Complex {$/;"	f
div	$OCEN/vec.oc	/^[operator "\/"] def Vec3::div(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x \/ other.x, .y \/ oth/;"	f
divrs	$OCEN/vec.oc	/^[operator "\/"] def Vec3::divrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val \/ this.x, val \//;"	f
divs	$OCEN/vec.oc	/^[operator "\/"] def Vec3::divs(this, val: T): Vec3<T> => Vec3<T>(.x \/ val, .y \/ val, .z \/ val/;"	f
dot	$OCEN/vec.oc	/^def Vec3::dot(this, other: Vec3<T>): T => .x * other.x + .y * other.y + .z * other.z$/;"	f
double	$OCEN/prelude.h	/^typedef double f64;$/;"	f
drand48	$OCEN/random.oc	/^[extern] def drand48(): f64/;"	f
draw_bezier	$OCEN/sdl/gfx.oc	/^[extern "bezierColor"]        def std::sdl::Renderer::draw_bezier(&this, vx: &i16, vy: &i16, n: /;"	f
draw_circle_color	$OCEN/sdl/gfx.oc	/^[extern "aacircleColor"]      def std::sdl::Renderer::draw_circle_color(&this, x: i32, y: i32, r/;"	f
draw_line	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderDrawLine"]  def Renderer::draw_line(&this, x1: i32, y1: i32, x2: i32, y2: i32/;"	f
draw_point	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderDrawPoint"] def Renderer::draw_point(&this, x: i32, y: i32)$/;"	f
draw_poly_color	$OCEN/sdl/gfx.oc	/^[extern "polygonColor"]       def std::sdl::Renderer::draw_poly_color(&this, vx: &i16, vy: &i16,/;"	f
draw_rect	$OCEN/og/mod.oc	/^def draw_rect(x: i32, y: i32, w: i32, h: i32, col: Color) {$/;"	f
draw_rect	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderDrawRect"]  def Renderer::draw_rect(&this, rect: &Rect)$/;"	f
draw_rect_v	$OCEN/og/mod.oc	/^def draw_rect_v(pos: Vec2i, size: Vec2i, col: Color) {$/;"	f
draw_tri_color	$OCEN/sdl/gfx.oc	/^[extern "trigonColor"]        def std::sdl::Renderer::draw_tri_color(&this, x1: i32, y1: i32, x2/;"	f
dump_backtrace	$OCEN/mod.oc	/^[extern] def dump_backtrace()$/;"	f
dup2	$OCEN/libc.oc	/^[extern] def dup2(a: i32, b: i32): i32$/;"	f
easy_cleanup	$OCEN/curl.oc	/^[extern "curl_easy_cleanup"] def Context::easy_cleanup(&this)$/;"	f
easy_init	$OCEN/curl.oc	/^[extern "curl_easy_init"] def Context::easy_init(): &Context$/;"	f
easy_perform	$OCEN/curl.oc	/^[extern "curl_easy_perform"] def Context::easy_perform(&this): Status$/;"	f
easy_setopt	$OCEN/curl.oc	/^def Context::easy_setopt($/;"	f
encode	$OCEN/image/png.oc	/^def encode(img: &Image, data: &Buffer) {$/;"	f
encode	$OCEN/image/ppm.oc	/^def encode(img: &Image, data: &Buffer) {$/;"	f
encode	$OCEN/image/qoi.oc	/^def encode(img: &Image, data: &Buffer) {$/;"	f
encode_end	$OCEN/image/qoi.oc	/^def QOIEncoder::encode_end(&this) {$/;"	f
encode_header	$OCEN/image/qoi.oc	/^def QOIEncoder::encode_header(&this) {$/;"	f
encode_pixel	$OCEN/image/qoi.oc	/^def QOIEncoder::encode_pixel(&this, pix: RGBA) {$/;"	f
encode_pixels	$OCEN/image/qoi.oc	/^def QOIEncoder::encode_pixels(&this) {$/;"	f
end	$OCEN/variadic.oc	/^[extern "va_end"] def VarArgs::end(this)$/;"	f
end	$OCEN/zlib.oc	/^    [extern "inflateEnd"] def Stream::end(&this): i32$/;"	f
ends_with	$OCEN/mod.oc	/^def str::ends_with(this, suffix: str): bool {$/;"	f
ends_with_str	$OCEN/sv.oc	/^def SV::ends_with_str(this, other: str): bool => .ends_with_sv(SV::from_str(other))$/;"	f
ends_with_sv	$OCEN/sv.oc	/^def SV::ends_with_sv(this, other: SV): bool {$/;"	f
ensure	$OCEN/value.oc	/^def Value::ensure(&this, type: ValueType) {$/;"	f
ep0	$OCEN/hash/sha256.oc	/^    def ep0(x: u32): u32 => rotate_right(x, 2) ^ rotate_right(x, 13) ^ rotate_right(x, 22)$/;"	f
ep1	$OCEN/hash/sha256.oc	/^    def ep1(x: u32): u32 => rotate_right(x, 6) ^ rotate_right(x, 11) ^ rotate_right(x, 25)$/;"	f
eq_bool	$OCEN/value.oc	/^def Value::eq_bool(&this, other: bool): bool {$/;"	f
eq_i64	$OCEN/value.oc	/^def Value::eq_i64(&this, other: i64): bool {$/;"	f
eq_str	$OCEN/sv.oc	/^[operator "=="] def SV::eq_str(this, other: str): bool => .eq(SV::from_str(other))$/;"	f
eq_str	$OCEN/value.oc	/^def Value::eq_str(&this, other: str): bool {$/;"	f
eq_u32	$OCEN/value.oc	/^def Value::eq_u32(&this, other: u32): bool {$/;"	f
errno	$OCEN/libc.oc	/^[extern] const errno: i32$/;"	f
execvp	$OCEN/libc.oc	/^[extern] def execvp(a: str, b: &str): i32$/;"	f
exit	$OCEN/libc.oc	/^[extern] [exits] def exit(code: i32)$/;"	f
exit	$OCEN/mod.oc	/^[extern] [exits] def exit(code: i32 = 0)$/;"	f
exp	$OCEN/complex.oc	/^[extern "cexpf"] def Complex::exp(this): Complex$/;"	f
extend	$OCEN/compact_map.oc	/^def Map::extend(&this, other: &Map<K, V>) {$/;"	f
extend	$OCEN/map.oc	/^def Map::extend(&this, other: &Map<K, V>) {$/;"	f
extend	$OCEN/set.oc	/^def Set::extend(&this, other: &Set<T>) {$/;"	f
extend	$OCEN/vector.oc	/^def Vector::extend(&this, other: &Vector<T>) {$/;"	f
f32	$OCEN/math.oc	/^def f32::min(this, b: f32): f32 => if this < b then this else b$/;"	f
f32	$OCEN/traits/compare.oc	/^def f32::compare(this, b: f32): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
f32	$OCEN/traits/eq.oc	/^def f32::eq(this, other: f32): bool => this == other$/;"	f
f32	$OCEN/traits/hash.oc	/^def f32::hash(this): u32 => this as u32 * 7817$/;"	f
f64	$OCEN/math.oc	/^def f64::min(this, b: f64): f64 => if this < b then this else b$/;"	f
f64	$OCEN/traits/compare.oc	/^def f64::compare(this, b: f64): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
f64	$OCEN/traits/eq.oc	/^def f64::eq(this, other: f64): bool => this == other$/;"	f
f64	$OCEN/traits/hash.oc	/^def f64::hash(this): u32 => (this as u64).hash()$/;"	f
fclose	$OCEN/fs.oc	/^    [extern] def fclose(file: &File): i32$/;"	f
fcntl	$OCEN/fcntl.oc	/^[extern "fcntl"] def fcntl(fd: i32, cmd: i32, arg: i32): i32$/;"	f
fft	$OCEN/fft.oc	/^def fft(data: &Complex, N: u32, out: &Complex) {$/;"	f
fft2	$OCEN/fft.oc	/^def fft2(inp: &Complex, R: u32, C: u32, out: &Complex) {$/;"	f
fft2_impl	$OCEN/fft.oc	/^def fft2_impl(inp: &Complex, R: u32, C: u32, out: &Complex, inv: bool) {$/;"	f
fft_impl	$OCEN/fft.oc	/^def fft_impl(data: &Complex, N: u32, out: &Complex, step: u32, factor: f32) {$/;"	f
file_exists	$OCEN/fs.oc	/^def file_exists(path: str): bool {$/;"	f
file_info	$OCEN/fs.oc	/^def file_info(path: str): FileMetadata {$/;"	f
fileno	$OCEN/fs.oc	/^    [extern] def fileno(file: &File): i32$/;"	f
fill_circle_color	$OCEN/sdl/gfx.oc	/^[extern "filledCircleColor"]  def std::sdl::Renderer::fill_circle_color(&this, x: i32, y: i32, r/;"	f
fill_poly_color	$OCEN/sdl/gfx.oc	/^[extern "filledPolygonColor"] def std::sdl::Renderer::fill_poly_color(&this, vx: &i16, vy: &i16,/;"	f
fill_rect	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderFillRect"]  def Renderer::fill_rect(&this, rect: &Rect)$/;"	f
fill_tri_color	$OCEN/sdl/gfx.oc	/^[extern "filledTrigonColor"]  def std::sdl::Renderer::fill_tri_color(&this, x1: i32, y1: i32, x2/;"	f
final	$OCEN/hash/sha256.oc	/^def Context::final(&this, hash: &u8) {$/;"	f
find_str	$OCEN/sv.oc	/^def SV::find_str(&this, s: str): i32 {$/;"	f
finish	$OCEN/video_renderer/ffmpeg.oc	/^def FFMPEGContext::finish(&this): bool {$/;"	f
finish	$OCEN/video_renderer/mod.oc	/^def VideoRenderer::finish(&this) {$/;"	f
finish	$OCEN/video_renderer/sdl.oc	/^def SDLContext::finish(&this) {$/;"	f
float	$OCEN/prelude.h	/^typedef float f32;$/;"	f
floor	$OCEN/math.oc	/^[extern "floorf"] def f32::floor(this): f32$/;"	f
fopen	$OCEN/fs.oc	/^    [extern] def fopen(path: str, mode: str = "r"): &File$/;"	f
fork	$OCEN/libc.oc	/^[extern] def fork(): i32$/;"	f
format	$OCEN/mod.oc	/^def format(fmt: str, ...): str {$/;"	f
fread	$OCEN/fs.oc	/^    [extern] def fread(ptr: untyped_ptr, size: u32, nmemb: u32, file: &File): i32$/;"	f
free	$OCEN/buffer.oc	/^def Buffer::free(&this) {$/;"	f
free	$OCEN/compact_map.oc	/^def Map::free(&this) {$/;"	f
free	$OCEN/deque.oc	/^def Deque::free(&this) {$/;"	f
free	$OCEN/heap.oc	/^def Heap::free(&this) {$/;"	f
free	$OCEN/image/mod.oc	/^def Image::free(&this) {$/;"	f
free	$OCEN/libc.oc	/^[extern] def free(ptr: untyped_ptr)$/;"	f
free	$OCEN/linkedlist.oc	/^def LinkedList::free(&this) {$/;"	f
free	$OCEN/map.oc	/^def Map::free(&this) {$/;"	f
free	$OCEN/mem.oc	/^def free(ptr: untyped_ptr) {$/;"	f
free	$OCEN/midi.oc	/^def Track::free(&this) {$/;"	f
free	$OCEN/mod.oc	/^def str::free(&this) {$/;"	f
free	$OCEN/set.oc	/^def Set::free(&this) {$/;"	f
free	$OCEN/value.oc	/^def Value::free(&this) {$/;"	f
free	$OCEN/vector.oc	/^def Vector::free(&this) {$/;"	f
free_all	$OCEN/curl.oc	/^[extern "curl_slist_free_all"] def SList::free_all(&this)$/;"	f
free_chunk	$OCEN/sdl/mixer.oc	/^[extern "Mix_FreeChunk"] def free_chunk(chunk: &Sound)$/;"	f
free_list	$OCEN/map.oc	/^def Item::free_list(&this) {$/;"	f
from	$OCEN/hash/sha1.oc	/^def SHA1Hash::from(data: Buffer): SHA1Hash {$/;"	f
from	$OCEN/hash/sha256.oc	/^def SHA256Hash::from(data: Buffer): SHA256Hash {$/;"	f
from_buf	$OCEN/sv.oc	/^def SV::from_buf(buf: Buffer): SV => SV(buf.data as str, buf.size)$/;"	f
from_sized_str	$OCEN/buffer.oc	/^def Buffer::from_sized_str(s: str, size: u32): Buffer {$/;"	f
from_str	$OCEN/buffer.oc	/^def Buffer::from_str(s: str): Buffer {$/;"	f
from_str	$OCEN/sv.oc	/^def SV::from_str(s: str): SV => SV(s, s.len())$/;"	f
from_sv	$OCEN/buffer.oc	/^def Buffer::from_sv(sv: SV): Buffer {$/;"	f
from_v	$OCEN/og/mod.oc	/^def Rect::from_v(pos: Vec2i, size: Vec2i): Rect {$/;"	f
from_vec	$OCEN/heap.oc	/^def Heap::from_vec(mode: Mode, data: &Vector<T>): &Heap<T> {$/;"	f
front	$OCEN/deque.oc	/^def Deque::front(&this): T {$/;"	f
fseek	$OCEN/fs.oc	/^    [extern] def fseek(file: &File, offset: i64, mode: SeekMode): i32$/;"	f
ftell	$OCEN/fs.oc	/^    [extern] def ftell(file: &File): i64$/;"	f
ftruncate	$OCEN/fs.oc	/^    [extern] def ftruncate(fd: i32, size: i64): i32$/;"	f
fwrite	$OCEN/fs.oc	/^    [extern] def fwrite(ptr: untyped_ptr, size: u32, nmemb: u32, file: &File): i32$/;"	f
get	$OCEN/compact_map.oc	/^def Map::get(&this, key: K, defolt: V): V {$/;"	f
get	$OCEN/image/mod.oc	/^def Image::get(&this, x: u32, y: u32): Color => .data[y * .width + x]$/;"	f
get	$OCEN/map.oc	/^def Map::get(&this, key: K, defolt: V): V {$/;"	f
get	$OCEN/og/state.oc	/^def KeyState::get(&this, k: sdl::Key): bool => .keys[k as u32]$/;"	f
get	$OCEN/sv.oc	/^def SV::get(this, n: u32): SV => SV(this.data, n)$/;"	f
get	$OCEN/value.oc	/^def Value::get(&this, key: str, defolt: &Value = null): &Value {$/;"	f
get_button	$OCEN/og/state.oc	/^def MouseState::get_button(&this, b: sdl::MouseButton): bool => .buttons[b as u32]$/;"	f
get_byte_at	$OCEN/buffer.oc	/^def Buffer::get_byte_at(this, index: u32): u8 {$/;"	f
get_compress_bound	$OCEN/zlib.oc	/^    [extern "compressBound"] def get_compress_bound(size: u64): uLongf$/;"	f
get_crc	$OCEN/image/png.oc	/^def get_crc(buf: &u8, len: u32, init: u32 = 0xffffffff): u32 {$/;"	f
get_digit	$OCEN/mod.oc	/^def char::get_digit(this): u32 => this as u32 - '0' as u32$/;"	f
get_err	$OCEN/libc.oc	/^def get_err(): str => strerror(errno) as str/;"	f
get_error	$OCEN/sdl/mixer.oc	/^[extern "Mix_GetError"] def get_error(): str$/;"	f
get_error	$OCEN/sdl/mod.oc	/^[extern "SDL_GetError"]                def get_error(): str$/;"	f
get_error	$OCEN/sdl/ttf.oc	/^[extern "TTF_GetError"] def get_error(): str/;"	f
get_flags	$OCEN/sdl/mod.oc	/^[extern "SDL_GetWindowFlags"] def Window::get_flags(&this): i32$/;"	f
get_frame_time	$OCEN/og/mod.oc	/^def get_frame_time(): f32 => state::frame_time$/;"	f
get_hex_digit	$OCEN/mod.oc	/^def char::get_hex_digit(this): u8 {$/;"	f
get_index	$OCEN/compact_map.oc	/^def Map::get_index(&this, key: K, hash: u32): u32 {$/;"	f
get_interpolated	$OCEN/image/mod.oc	/^def Image::get_interpolated(&this, xf: f32, yf: f32): Color {$/;"	f
get_item	$OCEN/compact_map.oc	/^def Map::get_item(&this, key: K): &Item<K, V> {$/;"	f
get_item	$OCEN/map.oc	/^def Map::get_item(&this, key: K): &Item<K, V> {$/;"	f
get_mouse_delta	$OCEN/og/mod.oc	/^def get_mouse_delta(): Vec2i => state::mouse.pos.sub(state::prev_mouse.pos)$/;"	f
get_mouse_pos	$OCEN/og/mod.oc	/^def get_mouse_pos(): Vec2i => state::mouse.pos$/;"	f
get_mouse_state	$OCEN/sdl/mod.oc	/^[extern "SDL_GetMouseState"]           def get_mouse_state(x: &i32, y: &i32): i32$/;"	f
get_position	$OCEN/sdl/mod.oc	/^[extern "SDL_GetWindowPosition"]       def Window::get_position(&this, x: &i32, y: &i32)$/;"	f
get_relative_mouse_state	$OCEN/sdl/mod.oc	/^[extern "SDL_GetRelativeMouseState"]   def get_relative_mouse_state(x: &i32, y: &i32): i32$/;"	f
get_size	$OCEN/sdl/mod.oc	/^[extern "SDL_GetWindowSize"]  def Window::get_size(&this, w: &i32, h: &i32)$/;"	f
get_surface	$OCEN/sdl/mod.oc	/^[extern "SDL_GetWindowSurface"]        def Window::get_surface(&this): &Surface$/;"	f
get_text_size	$OCEN/sdl/ttf.oc	/^[extern "TTF_SizeText"]         def Font::get_text_size(&this, text: str, w: &i32, h: &i32)$/;"	f
get_ticks	$OCEN/og/mod.oc	/^def get_ticks(): u32 => sdl::get_ticks() as u32$/;"	f
get_ticks	$OCEN/sdl/mod.oc	/^[extern "SDL_GetTicks"]                def get_ticks(): i32$/;"	f
get_wheel	$OCEN/og/state.oc	/^def MouseState::get_wheel(&this, w: MouseWheel): bool => .wheel_dirs[w as u32]$/;"	f
getenv	$OCEN/libc.oc	/^[extern] def getenv(name: str): str$/;"	f
gethostbyname	$OCEN/socket.oc	/^[extern] def gethostbyname(name: str): &HostEnt$/;"	f
glBegin	$OCEN/glut.oc	/^[extern] def glBegin(mode: i32)$/;"	f
glClear	$OCEN/glut.oc	/^[extern] def glClear(mask: i32)$/;"	f
glColor3f	$OCEN/glut.oc	/^[extern] def glColor3f(r: f32, g: f32, b: f32)$/;"	f
glEnable	$OCEN/glut.oc	/^[extern] def glEnable(cap: i32)$/;"	f
glEnd	$OCEN/glut.oc	/^[extern] def glEnd()$/;"	f
glFlush	$OCEN/glut.oc	/^[extern] def glFlush()$/;"	f
glLoadIdentity	$OCEN/glut.oc	/^[extern] def glLoadIdentity()$/;"	f
glMatrixMode	$OCEN/glut.oc	/^[extern] def glMatrixMode(mode: i32)$/;"	f
glPopMatrix	$OCEN/glut.oc	/^[extern] def glPopMatrix()$/;"	f
glPushMatrix	$OCEN/glut.oc	/^[extern] def glPushMatrix()$/;"	f
glRotatef	$OCEN/glut.oc	/^[extern] def glRotatef(angle: f32, x: f32, y: f32, z: f32)$/;"	f
glTranslatef	$OCEN/glut.oc	/^[extern] def glTranslatef(x: f32, y: f32, z: f32)$/;"	f
glVertex3f	$OCEN/glut.oc	/^[extern] def glVertex3f(x: f32, y: f32, z: f32)$/;"	f
glViewport	$OCEN/glut.oc	/^[extern] def glViewport(x: i32, y: i32, width: i32, height: i32)$/;"	f
global_cleanup	$OCEN/curl.oc	/^[extern "curl_global_cleanup"] def global_cleanup()$/;"	f
global_init	$OCEN/curl.oc	/^[extern "curl_global_init"] def global_init(flags: u64): u64$/;"	f
gluLookAt	$OCEN/glut.oc	/^[extern] def gluLookAt($/;"	f
gluPerspective	$OCEN/glut.oc	/^[extern] def gluPerspective(fovy: f32, aspect: f32, zNear: f32, zFar: f32)$/;"	f
glutCreateWindow	$OCEN/glut.oc	/^[extern] def glutCreateWindow(title: str)$/;"	f
glutDisplayFunc	$OCEN/glut.oc	/^[extern] def glutDisplayFunc(func: fn())$/;"	f
glutInit	$OCEN/glut.oc	/^[extern] def glutInit(argc: &i32, argv: &str)$/;"	f
glutInitDisplayMode	$OCEN/glut.oc	/^[extern] def glutInitDisplayMode(mode: i32)$/;"	f
glutInitWindowPosition	$OCEN/glut.oc	/^[extern] def glutInitWindowPosition(x: i32, y: i32)$/;"	f
glutInitWindowSize	$OCEN/glut.oc	/^[extern] def glutInitWindowSize(width: i32, height: i32)$/;"	f
glutMainLoop	$OCEN/glut.oc	/^[extern] def glutMainLoop()$/;"	f
glutPostRedisplay	$OCEN/glut.oc	/^[extern] def glutPostRedisplay()$/;"	f
glutReshapeFunc	$OCEN/glut.oc	/^[extern] def glutReshapeFunc(func: fn(i32, i32))$/;"	f
glutSwapBuffers	$OCEN/glut.oc	/^[extern] def glutSwapBuffers()$/;"	f
glutTimerFunc	$OCEN/glut.oc	/^[extern] def glutTimerFunc(time: i32, func: fn(i32), value: i32)$/;"	f
glutWireSphere	$OCEN/glut.oc	/^[extern] def glutWireSphere(radius: f32, slices: i32, stacks: i32)/;"	f
handle_pixel	$OCEN/image/qoi.oc	/^def QOIEncoder::handle_pixel(&this, pix: RGBA, num: u32 = 1) {$/;"	f
handle_sdl_events	$OCEN/og/utils.oc	/^def handle_sdl_events() {$/;"	f
has_value	$OCEN/compact_map.oc	/^def ValueIterator::has_value(&this): bool => .iter.has_value()$/;"	f
has_value	$OCEN/fs.oc	/^def DirectoryIterator::has_value(&this): bool => .dp?$/;"	f
has_value	$OCEN/linkedlist.oc	/^def Iterator::has_value(&this): bool => .node?$/;"	f
has_value	$OCEN/map.oc	/^def ValueIterator::has_value(&this): bool => .map_iter.has_value()$/;"	f
has_value	$OCEN/mod.oc	/^def CharIterator::has_value(&this): bool => .pos < .len$/;"	f
has_value	$OCEN/set.oc	/^def Iterator::has_value(&this): bool => .map_iter.has_value()$/;"	f
has_value	$OCEN/sv.oc	/^def SVWordIterator::has_value(&this): bool => not .sv.is_empty()$/;"	f
has_value	$OCEN/vector.oc	/^def Iterator::has_value(&this): bool => .index < .vec.size$/;"	f
hash	$OCEN/hash/sha1.oc	/^def hash(input: Buffer): Buffer {$/;"	f
hash	$OCEN/hash/sha256.oc	/^def hash(input: Buffer): Buffer {$/;"	f
hash	$OCEN/image/qoi.oc	/^def RGBA::hash(this): u32 {$/;"	f
hash	$OCEN/map.oc	/^def Map::hash(&this, key: K): u32 {$/;"	f
hash	$OCEN/span.oc	/^def Span::hash(this): u32 => pair_hash(.start.hash(), .end.index.hash())$/;"	f
hash	$OCEN/sv.oc	/^def SV::hash(this): u32 {$/;"	f
hash	$OCEN/traits/hash.oc	/^def u8::hash(this): u32 => this as u32 * 7817$/;"	f
hash	$OCEN/vec.oc	/^def Vec3::hash(this): u32 => pair_hash(.x.hash(), pair_hash(.y.hash(), .z.hash()))$/;"	f
hash_bytes	$OCEN/traits/hash.oc	/^def hash_bytes(data: &u8, len: u32): u32 {$/;"	f
hash_into	$OCEN/hash/sha1.oc	/^def hash_into(input: Buffer, output: &u8) {$/;"	f
hash_into	$OCEN/hash/sha256.oc	/^def hash_into(input: Buffer, output: &u8) {$/;"	f
hash_str	$OCEN/hash/sha1.oc	/^def hash_str(data: str): Buffer => hash(Buffer::from_str(data))$/;"	f
hash_str	$OCEN/hash/sha256.oc	/^def hash_str(data: str): Buffer => hash(Buffer::from_str(data))$/;"	f
hex_dump	$OCEN/buffer.oc	/^def hex_dump(data: &u8, size: u32) {$/;"	f
hex_dump	$OCEN/hash/sha1.oc	/^def SHA1Hash::hex_dump(this) => hex_dump(.data, 20)$/;"	f
hex_dump	$OCEN/hash/sha256.oc	/^def SHA256Hash::hex_dump(this) => hex_dump(.data, 32)$/;"	f
hostent	$OCEN/socket.oc	/^[extern "struct hostent"]$/;"	f
htonl	$OCEN/socket.oc	/^[extern] def htonl(val: i32): i32$/;"	f
htons	$OCEN/socket.oc	/^[extern] def htons(val: i32): i32$/;"	f
http_request	$OCEN/curl.oc	/^def http_request(url: str, data: &Buffer = null): Buffer {$/;"	f
http_request_auth	$OCEN/curl.oc	/^def http_request_auth($/;"	f
i16	$OCEN/math.oc	/^def i16::abs(this): i16 => if this < 0 then -this else this$/;"	f
i16	$OCEN/traits/compare.oc	/^def i16::compare(this, b: i16): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
i16	$OCEN/traits/eq.oc	/^def i16::eq(this, other: i16): bool => this == other$/;"	f
i16	$OCEN/traits/hash.oc	/^def i16::hash(this): u32 => this as u32 * 7817$/;"	f
i32	$OCEN/math.oc	/^def i32::abs(this): i32 => if this < 0 then -this else this$/;"	f
i32	$OCEN/mod.oc	/^def i32::min(this, b: i32): i32 => if this < b then this else b$/;"	f
i32	$OCEN/traits/compare.oc	/^def i32::compare(this, b: i32): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
i32	$OCEN/traits/eq.oc	/^def i32::eq(this, other: i32): bool => this == other$/;"	f
i32	$OCEN/traits/hash.oc	/^def i32::hash(this): u32 => this as u32 * 7817$/;"	f
i64	$OCEN/math.oc	/^def i64::abs(this): i64 => if this < 0 then -this else this$/;"	f
i64	$OCEN/traits/compare.oc	/^def i64::compare(this, b: i64): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
i64	$OCEN/traits/eq.oc	/^def i64::eq(this, other: i64): bool => this == other$/;"	f
i64	$OCEN/traits/hash.oc	/^def i64::hash(this): u32 => pair_hash((this as u32).hash(), ((this >> 32) as u32).hash())$/;"	f
ifft	$OCEN/fft.oc	/^def ifft(data: &Complex, N: u32, out: &Complex) {$/;"	f
ifft2	$OCEN/fft.oc	/^def ifft2(inp: &Complex, R: u32, C: u32, out: &Complex) {$/;"	f
imag	$OCEN/complex.oc	/^[extern "cimagf"] def Complex::imag(this): f32$/;"	f
img_pix	$OCEN/image/qoi.oc	/^def QOIEncoder::img_pix(&this, idx: u32): RGBA {$/;"	f
in_addr	$OCEN/socket.oc	/^[extern "struct in_addr"]$/;"	f
inc	$OCEN/bencode.oc	/^def Parser::inc(&this) => .loc.index += 1$/;"	f
index	$OCEN/vec.oc	/^def Vec3::index(this, idx: u32): T => (&this as &T)[idx]/;"	f
inet_pton	$OCEN/socket.oc	/^[extern] def inet_pton(af: i32, src: str, dst: untyped_ptr): i32$/;"	f
inf	$OCEN/math.oc	/^def f64::inf(): f64 => INFINITY$/;"	f
inflate	$OCEN/zlib.oc	/^    [extern "inflate"] def Stream::inflate(&this, flush: i32): i32$/;"	f
init	$OCEN/og/mod.oc	/^def init(width: u32, height: u32, title: str) {$/;"	f
init	$OCEN/sdl/mod.oc	/^[extern "SDL_Init"]                    def init(flags: i32): i32$/;"	f
init	$OCEN/sdl/ttf.oc	/^[extern "TTF_Init"]     def init(): i32$/;"	f
init	$OCEN/zlib.oc	/^    [extern "inflateInit"] def Stream::init(&this): i32$/;"	f
init_logging	$OCEN/logging.oc	/^def init_logging(level: LogLevel = Info, time_format: str = "%H:%M:%S") {$/;"	f
insert	$OCEN/compact_map.oc	/^def Map::insert(&this, key: K, value: V) {$/;"	f
insert	$OCEN/map.oc	/^def Map::insert(&this, key: K, value: V) {$/;"	f
insert	$OCEN/value.oc	/^def Value::insert(&this, key: str, value: &Value) {$/;"	f
insert_bool	$OCEN/value.oc	/^[operator "[]="] def Value::insert_bool(&this, key: str, b: bool) => .insert(key, Value::new_boo/;"	f
insert_f32	$OCEN/value.oc	/^[operator "[]="] def Value::insert_f32(&this, key: str, f: f32) => .insert(key, Value::new_float/;"	f
insert_f64	$OCEN/value.oc	/^[operator "[]="] def Value::insert_f64(&this, key: str, f: f64) => .insert(key, Value::new_float/;"	f
insert_i32	$OCEN/value.oc	/^[operator "[]="] def Value::insert_i32(&this, key: str, i: i32) => .insert(key, Value::new_int(i/;"	f
insert_i64	$OCEN/value.oc	/^[operator "[]="] def Value::insert_i64(&this, key: str, i: i64) => .insert(key, Value::new_int(i/;"	f
insert_str	$OCEN/value.oc	/^[operator "[]="] def Value::insert_str(&this, key: str, s: str) => .insert(key, Value::new_str(s/;"	f
insert_u32	$OCEN/value.oc	/^[operator "[]="] def Value::insert_u32(&this, key: str, i: u32) => .insert(key, Value::new_int(i/;"	f
insert_u64	$OCEN/value.oc	/^[operator "[]="] def Value::insert_u64(&this, key: str, i: u64) => .insert(key, Value::new_int(i/;"	f
int16_t	$OCEN/prelude.h	/^typedef int16_t i16;$/;"	f
int32_t	$OCEN/prelude.h	/^typedef int32_t i32;$/;"	f
int64_t	$OCEN/prelude.h	/^typedef int64_t i64;$/;"	f
int8_t	$OCEN/prelude.h	/^typedef int8_t i8;$/;"	f
interp	$OCEN/image/mod.oc	/^def interp(t: f32, a: f32, b: f32): f32 {$/;"	f
is_alnum	$OCEN/mod.oc	/^def char::is_alnum(this): bool => libc::isalnum(this)$/;"	f
is_alpha	$OCEN/mod.oc	/^def char::is_alpha(this): bool => libc::isalpha(this)$/;"	f
is_before	$OCEN/span.oc	/^def Location::is_before(&this, other: Location): bool {$/;"	f
is_close	$OCEN/math.oc	/^def f64::is_close(this, other: f64, thresh: f64 = 0.0001): bool => (this - other).abs() < thresh$/;"	f
is_digit	$OCEN/mod.oc	/^def char::is_digit(this): bool => libc::isdigit(this)$/;"	f
is_empty	$OCEN/buffer.oc	/^def BytesReader::is_empty(&this): bool => .index >= .size/;"	f
is_empty	$OCEN/compact_map.oc	/^def Map::is_empty(&this): bool => .items.size == 0$/;"	f
is_empty	$OCEN/deque.oc	/^def Deque::is_empty(&this): bool => .size == 0/;"	f
is_empty	$OCEN/heap.oc	/^def Heap::is_empty(&this): bool => .vec.is_empty()$/;"	f
is_empty	$OCEN/linkedlist.oc	/^def LinkedList::is_empty(&this): bool => .head == null$/;"	f
is_empty	$OCEN/map.oc	/^def Map::is_empty(&this): bool => .size == 0$/;"	f
is_empty	$OCEN/set.oc	/^def Set::is_empty(&this): bool => .map.size == 0$/;"	f
is_empty	$OCEN/sv.oc	/^def SV::is_empty(&this): bool => .len == 0$/;"	f
is_empty	$OCEN/vector.oc	/^def Vector::is_empty(&this): bool => .size == 0$/;"	f
is_hex_digit	$OCEN/mod.oc	/^def char::is_hex_digit(this): bool => libc::isxdigit(this)$/;"	f
is_key_down	$OCEN/og/mod.oc	/^def is_key_down(k: sdl::Key): bool => state::keys.get(k) == true$/;"	f
is_key_pressed	$OCEN/og/mod.oc	/^def is_key_pressed(k: sdl::Key): bool => state::prev_keys.get(k) == false and state::keys.get(k)/;"	f
is_key_released	$OCEN/og/mod.oc	/^def is_key_released(k: sdl::Key): bool => state::prev_keys.get(k) == true and state::keys.get(k)/;"	f
is_key_up	$OCEN/og/mod.oc	/^def is_key_up(k: sdl::Key): bool => state::keys.get(k) == false$/;"	f
is_lower	$OCEN/mod.oc	/^def char::is_lower(this): bool => libc::islower(this)$/;"	f
is_mouse_down	$OCEN/og/mod.oc	/^def is_mouse_down(b: sdl::MouseButton): bool$/;"	f
is_mouse_pressed	$OCEN/og/mod.oc	/^def is_mouse_pressed(b: sdl::MouseButton): bool$/;"	f
is_mouse_released	$OCEN/og/mod.oc	/^def is_mouse_released(b: sdl::MouseButton): bool$/;"	f
is_mouse_up	$OCEN/og/mod.oc	/^def is_mouse_up(b: sdl::MouseButton): bool$/;"	f
is_power_of_2	$OCEN/fft.oc	/^def is_power_of_2(x: u32): bool => x & (x - 1) == 0$/;"	f
is_print	$OCEN/mod.oc	/^def char::is_print(this): bool => libc::isprint(this)$/;"	f
is_running	$OCEN/og/mod.oc	/^def is_running(): bool {$/;"	f
is_scroll	$OCEN/og/mod.oc	/^def is_scroll(w: state::MouseWheel): bool => state::mouse.get_wheel(w)$/;"	f
is_space	$OCEN/mod.oc	/^def char::is_space(this): bool => libc::isspace(this)$/;"	f
is_upper	$OCEN/mod.oc	/^def char::is_upper(this): bool => libc::isupper(this)$/;"	f
is_valid	$OCEN/span.oc	/^def Span::is_valid(this): bool {$/;"	f
isalnum	$OCEN/libc.oc	/^[extern] def isalnum(c: char): bool$/;"	f
isalpha	$OCEN/libc.oc	/^[extern] def isalpha(c: char): bool$/;"	f
isdigit	$OCEN/libc.oc	/^[extern] def isdigit(c: char): bool$/;"	f
islower	$OCEN/libc.oc	/^[extern] def islower(c: char): bool$/;"	f
isprint	$OCEN/libc.oc	/^[extern] def isprint(c: char): bool$/;"	f
isspace	$OCEN/libc.oc	/^[extern] def isspace(c: char): bool$/;"	f
isupper	$OCEN/libc.oc	/^[extern] def isupper(c: char): bool$/;"	f
isxdigit	$OCEN/libc.oc	/^[extern] def isxdigit(c: char): bool$/;"	f
iter	$OCEN/compact_map.oc	/^def Map::iter(&this): Iterator<K, V> => Iterator<K, V>(.items.iter())$/;"	f
iter	$OCEN/linkedlist.oc	/^def LinkedList::iter(&this): Iterator<T> => Iterator<T>(.head, forward: true)$/;"	f
iter	$OCEN/map.oc	/^def Map::iter(&this): Iterator<K, V> {$/;"	f
iter	$OCEN/set.oc	/^def Set::iter(&this): Iterator<T> => Iterator<T>::make(this)$/;"	f
iter	$OCEN/vector.oc	/^def Vector::iter(&this): Iterator<T> => Iterator<T>::make(this)$/;"	f
iter_i64	$OCEN/sv.oc	/^def SV::iter_i64(this): SVNumberIterator<i64> => SVNumberIterator<i64>::make(this)$/;"	f
iter_keys	$OCEN/compact_map.oc	/^def Map::iter_keys(&this): KeyIterator<K, V> => KeyIterator<K, V>(.items.iter())$/;"	f
iter_keys	$OCEN/map.oc	/^def Map::iter_keys(&this): KeyIterator<K, V> => KeyIterator<K, V>(.iter())$/;"	f
iter_nums	$OCEN/sv.oc	/^def SV::iter_nums(this): SVNumberIterator<u64> => SVNumberIterator<u64>::make(this)$/;"	f
iter_pred	$OCEN/sv.oc	/^def SV::iter_pred(this, pred: fn(SV): u32): SVPredicateIterator => SVPredicateIterator::make(thi/;"	f
iter_rev	$OCEN/linkedlist.oc	/^def LinkedList::iter_rev(&this): Iterator<T> => Iterator<T>(.head, forward: false)$/;"	f
iter_u64	$OCEN/sv.oc	/^def SV::iter_u64(this): SVNumberIterator<u64> => SVNumberIterator<u64>::make(this)$/;"	f
iter_values	$OCEN/compact_map.oc	/^def Map::iter_values(&this): ValueIterator<K, V> => ValueIterator<K, V>(.items.iter())$/;"	f
iter_values	$OCEN/map.oc	/^def Map::iter_values(&this): ValueIterator<K, V> => ValueIterator<K, V>(.iter())$/;"	f
iterate_directory	$OCEN/fs.oc	/^def iterate_directory(path: str, skip_self_and_parent: bool = true): DirectoryIterator {$/;"	f
join	$OCEN/span.oc	/^def Span::join(this, other: Span): Span {$/;"	f
join	$OCEN/thread.oc	/^def Thread::join(&this) {$/;"	f
jump_back	$OCEN/setjmp.oc	/^def ErrorContext::jump_back(this, status: i32)/;"	f
key	$OCEN/map.oc	/^def Iterator::key(&this): K {$/;"	f
len	$OCEN/mod.oc	/^[extern "strlen"] def str::len(this): u32$/;"	f
length	$OCEN/vec.oc	/^def Vec3::length(this): f32 => ((.x * .x + .y * .y + .z * .z) as f32).sqrt()$/;"	f
length_sq	$OCEN/vec.oc	/^def Vec3::length_sq(this): T => .x * .x + .y * .y + .z * .z$/;"	f
line	$OCEN/image/draw.oc	/^def line(img: &Image, x1: i32, y1: i32, x2: i32, y2: i32, color: Color) {$/;"	f
line_f	$OCEN/image/draw.oc	/^def line_f(img: &Image, x1: f32, y1: f32, x2: f32, y2: f32, color: Color) {$/;"	f
lines	$OCEN/sv.oc	/^def SV::lines(this): SVLineIterator => SVLineIterator(this)$/;"	f
listen	$OCEN/socket.oc	/^[extern] def listen(sockfd: i32, backlog: i32): i32$/;"	f
load	$OCEN/image/mod.oc	/^def Image::load(filename: str): &Image {$/;"	f
load	$OCEN/sdl/ttf.oc	/^[extern "TTF_OpenFont"]         def Font::load(path: str, size: i32): &Font$/;"	f
load_image	$OCEN/sdl/image.oc	/^[extern "IMG_LoadTexture"] def std::sdl::Renderer::load_image(&this, path: str): &Texture$/;"	f
load_wav	$OCEN/sdl/mixer.oc	/^[extern "Mix_LoadWAV"] def load_wav(path: str): &Sound$/;"	f
localtime	$OCEN/time.oc	/^[extern] def localtime(t: &Time): &TM$/;"	f
lock	$OCEN/sdl/mod.oc	/^[extern "SDL_LockTexture"]    def Texture::lock(&this, rect: &Rect, pixels: &untyped_ptr, pitch:/;"	f
log	$OCEN/complex.oc	/^[extern "clogf"] def Complex::log(this): Complex$/;"	f
log	$OCEN/logging.oc	/^def log(level: LogLevel, fmt: str, ...) {$/;"	f
log	$OCEN/math.oc	/^[extern "logf"] def f32::log(this): f32$/;"	f
log2	$OCEN/math.oc	/^[extern "log2f"] def f32::log2(this): f32$/;"	f
maj	$OCEN/hash/sha256.oc	/^    def maj(x: u32, y: u32, z: u32): u32 => (x & y) ^ (x & z) ^ (y & z)$/;"	f
make	$OCEN/buffer.oc	/^def BytesReader::make(data: &u8, size: u32): BytesReader {$/;"	f
make	$OCEN/hash/sha256.oc	/^def Context::make(): Context {$/;"	f
make	$OCEN/image/qoi.oc	/^def QOIEncoder::make(img: &Image, buffer: &Buffer): QOIEncoder {$/;"	f
make	$OCEN/json.oc	/^def Parser::make(tokens: &Vector<&Token>): Parser {$/;"	f
make	$OCEN/map.oc	/^def Iterator::make(map: &Map<K, V>): Iterator<K, V> {$/;"	f
make	$OCEN/random.oc	/^def RandomState::make(s: u32 = 0): RandomState {$/;"	f
make	$OCEN/set.oc	/^def Iterator::make(set: &Set<T>): Iterator<T> => Iterator<T>(set.map.iter())$/;"	f
make	$OCEN/sv.oc	/^def SVPredicateIterator::make(sv: SV, pred: fn(SV): u32): SVPredicateIterator {$/;"	f
make	$OCEN/thread.oc	/^def Thread::make(callback: fn(untyped_ptr): untyped_ptr, arg: untyped_ptr = null): Thread {$/;"	f
make	$OCEN/vector.oc	/^def Iterator::make(vec: &Vector<T>): Iterator<T> => Iterator<T>(vec, 0)$/;"	f
make_crc_table	$OCEN/image/png.oc	/^def make_crc_table() {$/;"	f
malloc	$OCEN/mem.oc	/^    [extern] def malloc(size: u32): untyped_ptr$/;"	f
max	$OCEN/math.oc	/^def f64::max(this, b: f64): f64 => if this > b then this else b$/;"	f
max	$OCEN/mod.oc	/^def u8::max(this, other: u8): u8 => if this > other then this else other$/;"	f
maximize	$OCEN/sdl/mod.oc	/^[extern "SDL_MaximizeWindow"] def Window::maximize(&this)$/;"	f
memcmp	$OCEN/libc.oc	/^[extern] def memcmp(s: untyped_ptr, other: untyped_ptr, n: u32): i32$/;"	f
memcpy	$OCEN/libc.oc	/^[extern] def memcpy(dest: untyped_ptr, src: untyped_ptr, size: u32)$/;"	f
memset	$OCEN/libc.oc	/^[extern] def memset(dest: untyped_ptr, c: u8, size: u32)$/;"	f
min	$OCEN/math.oc	/^def f64::min(this, b: f64): f64 => if this < b then this else b$/;"	f
min	$OCEN/mod.oc	/^def u8::min(this, other: u8): u8 => if this < other then this else other$/;"	f
mkdir	$OCEN/fs.oc	/^    [extern] def mkdir(path: str, mode: i32 = 0777): i32$/;"	f
mul	$OCEN/complex.oc	/^def Complex::mul(this, other: Complex): Complex {$/;"	f
mult	$OCEN/vec.oc	/^[operator "*"] def Vec3::mult(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x * other.x, .y * other/;"	f
multrs	$OCEN/vec.oc	/^[operator "*"] def Vec3::multrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val * this.x, val * t/;"	f
mults	$OCEN/vec.oc	/^[operator "*"] def Vec3::mults(this, val: T): Vec3<T> => Vec3<T>(.x * val, .y * val, .z * val)$/;"	f
my_calloc	$OCEN/mem.oc	/^    def my_calloc(state: State, size: u32): untyped_ptr                                   => cal/;"	f
my_free	$OCEN/mem.oc	/^    def my_free(state: State, ptr: untyped_ptr)                                           => fre/;"	f
my_realloc	$OCEN/mem.oc	/^    def my_realloc(state: State, ptr: untyped_ptr, old_size: u32, size: u32): untyped_ptr => rea/;"	f
negate	$OCEN/vec.oc	/^[operator "-"] def Vec3::negate(this): Vec3<T> => Vec3<T>(-.x, -.y, -.z)$/;"	f
new	$OCEN/bencode.oc	/^def Parser::new(input: Buffer): Parser {$/;"	f
new	$OCEN/compact_map.oc	/^def Map::new(capacity: u32 = 16): &Map<K, V> {$/;"	f
new	$OCEN/complex.oc	/^[extern "CMPLXF"] def Complex::new(real: f32, imag: f32): Complex$/;"	f
new	$OCEN/deque.oc	/^def Deque::new(capacity: u32 = 16): &Deque<T> {$/;"	f
new	$OCEN/heap.oc	/^def Heap::new(mode: Mode, capacity: u32 = 32): &Heap<T> {$/;"	f
new	$OCEN/image/mod.oc	/^def Image::new(width: u32, height: u32): &Image {$/;"	f
new	$OCEN/linkedlist.oc	/^def Node::new(val: T, next: &Node<T> = null, prev: &Node<T> = null): &Node<T> {$/;"	f
new	$OCEN/map.oc	/^def Map::new(capacity: u32 = 32): &Map<K, V> {$/;"	f
new	$OCEN/set.oc	/^def Set::new(): &Set<T> {$/;"	f
new	$OCEN/value.oc	/^def Value::new(type: ValueType): &Value {$/;"	f
new	$OCEN/vector.oc	/^def Vector::new(capacity: u32 = 16): &Vector<T> {$/;"	f
new_bool	$OCEN/value.oc	/^def Value::new_bool(bul: bool): &Value {$/;"	f
new_dict	$OCEN/value.oc	/^def Value::new_dict(map: &Map<str, &Value>): &Value {$/;"	f
new_float	$OCEN/value.oc	/^def Value::new_float(num: f64): &Value {$/;"	f
new_int	$OCEN/value.oc	/^def Value::new_int(num: i64): &Value {$/;"	f
new_list	$OCEN/value.oc	/^def Value::new_list(vec: &Vector<&Value>): &Value {$/;"	f
new_str	$OCEN/buffer.oc	/^def Buffer::new_str(this): str => (.data as str).copy()$/;"	f
new_str	$OCEN/value.oc	/^def Value::new_str(s: str): &Value {$/;"	f
new_str_buf	$OCEN/value.oc	/^def Value::new_str_buf(buf: Buffer): &Value {$/;"	f
next	$OCEN/compact_map.oc	/^def ValueIterator::next(&this) { .iter.next() }$/;"	f
next	$OCEN/fs.oc	/^def DirectoryIterator::next(&this) {$/;"	f
next	$OCEN/linkedlist.oc	/^def Iterator::next(&this) {$/;"	f
next	$OCEN/map.oc	/^def ValueIterator::next(&this) {$/;"	f
next	$OCEN/mod.oc	/^def CharIterator::next(&this): u32 => .pos++$/;"	f
next	$OCEN/set.oc	/^def Iterator::next(&this) {$/;"	f
next	$OCEN/sv.oc	/^def SVWordIterator::next(&this) {}$/;"	f
next	$OCEN/vector.oc	/^def Iterator::next(&this) {$/;"	f
next_power_of_2	$OCEN/fft.oc	/^def next_power_of_2(x: u32): u32 {$/;"	f
normalized	$OCEN/vec.oc	/^def Vec3::normalized(this): Vec3f {$/;"	f
nth_element	$OCEN/sort.oc	/^def nth_element<T>(data: &T, size: u32, n: u32) => nth_element_by<T>(data, size, n, T::compare)$/;"	f
nth_element_by	$OCEN/sort.oc	/^def nth_element_by<T>(data: &T, size: u32, n: u32, cmp: fn(T,T): i8): T {$/;"	f
only_chop_left	$OCEN/sv.oc	/^def SV::only_chop_left(&this, n: u32 = 1) {$/;"	f
open	$OCEN/fs.oc	/^def File::open(path: str, mode: str = "r"): &File {$/;"	f
open_audio	$OCEN/sdl/mixer.oc	/^[extern "Mix_OpenAudio"] def open_audio(frequency: i32, format: u16, channels: i32, chunksize: i/;"	f
opendir	$OCEN/fs.oc	/^    [extern] def opendir(path: str): &Dir$/;"	f
paeth_predictor	$OCEN/image/png.oc	/^def paeth_predictor(ua: u8, ub: u8, uc: u8): u8 {$/;"	f
pair_hash	$OCEN/traits/hash.oc	/^def pair_hash(a: u32, b: u32): u32 => a * 33 ^ b$/;"	f
panic	$OCEN/mod.oc	/^def panic(msg: str = "<panic>") {$/;"	f
parse	$OCEN/bencode.oc	/^def parse(input: Buffer): &Value {$/;"	f
parse	$OCEN/image/png.oc	/^def Chunk::parse(io: &BytesReader): Chunk {$/;"	f
parse	$OCEN/json.oc	/^def parse(source: str, filename: str = "<anonymous>"): &Value {$/;"	f
parse_array	$OCEN/json.oc	/^def Parser::parse_array(&this): &Value {$/;"	f
parse_dict	$OCEN/bencode.oc	/^def Parser::parse_dict(&this): &Value {$/;"	f
parse_file	$OCEN/midi.oc	/^def parse_file(filename: str): MidiFile {$/;"	f
parse_from_file	$OCEN/json.oc	/^def parse_from_file(filename: str): &Value {$/;"	f
parse_int	$OCEN/bencode.oc	/^def Parser::parse_int(&this): &Value {$/;"	f
parse_int_internal	$OCEN/bencode.oc	/^def Parser::parse_int_internal(&this): i64 {$/;"	f
parse_list	$OCEN/bencode.oc	/^def Parser::parse_list(&this): &Value {$/;"	f
parse_midi	$OCEN/midi.oc	/^def Parser::parse_midi(&this, io: &BytesReader): MidiFile {$/;"	f
parse_object	$OCEN/json.oc	/^def Parser::parse_object(&this): &Value {$/;"	f
parse_string	$OCEN/bencode.oc	/^def Parser::parse_string(&this): &Value {$/;"	f
parse_string_internal	$OCEN/bencode.oc	/^def Parser::parse_string_internal(&this): Buffer {$/;"	f
parse_track	$OCEN/midi.oc	/^def Parser::parse_track(&this, io: &BytesReader): Track {$/;"	f
parse_value	$OCEN/json.oc	/^def Parser::parse_value(&this): &Value => match .token().type {$/;"	f
partition	$OCEN/sort.oc	/^def partition<T>(data: &T, size: u32) => partition_by<T>(data, size, T::compare)$/;"	f
partition_by	$OCEN/sort.oc	/^def partition_by<T>(data: &T, size: u32, cmp: fn(T): bool): u32 {$/;"	f
pause	$OCEN/sdl/mixer.oc	/^[extern "Mix_Pause"] def pause(channel: i32)$/;"	f
peek	$OCEN/heap.oc	/^def Heap::peek(&this): T {$/;"	f
pipe	$OCEN/libc.oc	/^[extern] def pipe(fds: &i32): i32$/;"	f
play_channel	$OCEN/sdl/mixer.oc	/^[extern "Mix_PlayChannel"] def play_channel(channel: i32, chunk: &Sound, loops: i32): i32$/;"	f
poll_event	$OCEN/sdl/mod.oc	/^[extern "SDL_PollEvent"]        def poll_event(event: &Event): bool$/;"	f
pop	$OCEN/heap.oc	/^def Heap::pop(&this): T {$/;"	f
pop	$OCEN/linkedlist.oc	/^def LinkedList::pop(&this): T {$/;"	f
pop	$OCEN/vector.oc	/^def Vector::pop(&this): T {$/;"	f
pop_at	$OCEN/vector.oc	/^def Vector::pop_at(&this, i: u32): T {$/;"	f
pop_back	$OCEN/deque.oc	/^def Deque::pop_back(&this): T {$/;"	f
pop_front	$OCEN/deque.oc	/^def Deque::pop_front(&this): T {$/;"	f
pop_front	$OCEN/linkedlist.oc	/^def LinkedList::pop_front(&this): T {$/;"	f
pow	$OCEN/math.oc	/^[extern "powf"] def f32::pow(this, exp: f32): f32$/;"	f
present	$OCEN/sdl/mod.oc	/^[extern "SDL_RenderPresent"]   def Renderer::present(&this)$/;"	f
print	$OCEN/sv.oc	/^def SV::print(&this, msg: str=null) {$/;"	f
pthread_attr_t	$OCEN/thread.oc	/^    struct pthread_attr_t extern$/;"	f
pthread_create	$OCEN/thread.oc	/^    def pthread_create(thread: &pthread_t, attr: &pthread_attr_t, start_routine: fn(untyped_ptr)/;"	f
pthread_join	$OCEN/thread.oc	/^    def pthread_join(thread: pthread_t, retval: &untyped_ptr): i32 extern$/;"	f
pthread_t	$OCEN/thread.oc	/^    struct pthread_t extern$/;"	f
ptr_hash	$OCEN/traits/hash.oc	/^def ptr_hash(ptr: untyped_ptr): u32 => (ptr as u64).hash()$/;"	f
push	$OCEN/heap.oc	/^def Heap::push(&this, value: T) {$/;"	f
push	$OCEN/linkedlist.oc	/^def LinkedList::push(&this, val: T): &Node<T> {$/;"	f
push	$OCEN/value.oc	/^def Value::push(&this, value: &Value) {$/;"	f
push	$OCEN/vector.oc	/^def Vector::push(&this, value: T) {$/;"	f
push_back	$OCEN/deque.oc	/^def Deque::push_back(&this, value: T) {$/;"	f
push_bool	$OCEN/value.oc	/^[operator "+="] def Value::push_bool(&this, b: bool) => .push(Value::new_bool(b))$/;"	f
push_f32	$OCEN/value.oc	/^[operator "+="] def Value::push_f32(&this, f: f32) => .push(Value::new_float(f as f64))$/;"	f
push_f64	$OCEN/value.oc	/^[operator "+="] def Value::push_f64(&this, f: f64) => .push(Value::new_float(f))$/;"	f
push_front	$OCEN/deque.oc	/^def Deque::push_front(&this, value: T) {$/;"	f
push_front	$OCEN/linkedlist.oc	/^def LinkedList::push_front(&this, val: T): &Node<T> {$/;"	f
push_front	$OCEN/vector.oc	/^def Vector::push_front(&this, value: T) {$/;"	f
push_i32	$OCEN/value.oc	/^[operator "+="] def Value::push_i32(&this, i: i32) => .push(Value::new_int(i as i64))$/;"	f
push_i64	$OCEN/value.oc	/^[operator "+="] def Value::push_i64(&this, i: i64) => .push(Value::new_int(i))$/;"	f
push_str	$OCEN/value.oc	/^[operator "+="] def Value::push_str(&this, s: str) => .push(Value::new_str(s))$/;"	f
push_u32	$OCEN/value.oc	/^[operator "+="] def Value::push_u32(&this, i: u32) => .push(Value::new_int(i as i64))$/;"	f
push_u64	$OCEN/value.oc	/^[operator "+="] def Value::push_u64(&this, i: u64) => .push(Value::new_int(i as i64))$/;"	f
puts	$OCEN/fs.oc	/^def File::puts(&this, s: str) {$/;"	f
query	$OCEN/sdl/mod.oc	/^[extern "SDL_QueryTexture"]   def Texture::query(&this, a: untyped_ptr, b: untyped_ptr, w: &i32,/;"	f
quit	$OCEN/og/mod.oc	/^def quit() {$/;"	f
quit	$OCEN/sdl/mixer.oc	/^[extern "Mix_Quit"] def quit()$/;"	f
quit	$OCEN/sdl/mod.oc	/^[extern "SDL_Quit"]                    def quit()$/;"	f
quit	$OCEN/sdl/ttf.oc	/^[extern "TTF_Quit"]     def quit(): i32$/;"	f
radians	$OCEN/math.oc	/^def radians(degrees: f32): f32 { return degrees * PI \/ 180.0; }$/;"	f
rand	$OCEN/random.oc	/^    [extern] def rand(): u32$/;"	f
rand01	$OCEN/math.oc	/^[extern "drand48"] def rand01(): f32$/;"	f
randf32	$OCEN/random.oc	/^def randf32(state: &RandomState=null): f32 => (randint(state) as f32) \/ 4294967296.0$/;"	f
randf64	$OCEN/random.oc	/^def randf64(state: &RandomState=null): f64 => (randint(state) as f64) \/ 4294967296.0$/;"	f
randi32	$OCEN/random.oc	/^def randi32(state: &RandomState=null): i32 => (randint(state) as i32)$/;"	f
randint	$OCEN/math.oc	/^[extern "rand"] def randint(): i32$/;"	f
randint	$OCEN/random.oc	/^def randint(state: &RandomState=null): u32 {$/;"	f
randu32	$OCEN/random.oc	/^def randu32(state: &RandomState=null): u32 => randint(state)$/;"	f
randu64	$OCEN/random.oc	/^def randu64(state: &RandomState=null): u64 => (randint(state) as u64) << 32 | randint(state) as /;"	f
read	$OCEN/fs.oc	/^def File::read(&this, buf: untyped_ptr, size: u32): i32 {$/;"	f
read	$OCEN/socket.oc	/^def Socket::read(&this, buf: &Buffer, max_size: u32): u32 {$/;"	f
read_bytes	$OCEN/buffer.oc	/^def BytesReader::read_bytes(&this, _dst: untyped_ptr, count: u32) {$/;"	f
read_bytes_sv	$OCEN/buffer.oc	/^def BytesReader::read_bytes_sv(&this, count: u32): SV {$/;"	f
read_exactly	$OCEN/socket.oc	/^def Socket::read_exactly(&this, buf: &Buffer, size: u32): u32 {$/;"	f
read_file	$OCEN/fs.oc	/^def read_file(path: str): Buffer {$/;"	f
read_i16	$OCEN/buffer.oc	/^def BytesReader::read_i16(&this, endian: Endian = Big): i16 { return .read_u16(endian) as i16 }$/;"	f
read_i32	$OCEN/buffer.oc	/^def BytesReader::read_i32(&this, endian: Endian = Big): i32 { return .read_u32(endian) as i32 }$/;"	f
read_i64	$OCEN/buffer.oc	/^def BytesReader::read_i64(&this, endian: Endian = Big): i64 { return .read_u64(endian) as i64 }$/;"	f
read_i8	$OCEN/buffer.oc	/^def BytesReader::read_i8(&this): i8 { return .read_u8() as i8 }$/;"	f
read_u16	$OCEN/buffer.oc	/^def BytesReader::read_u16(&this, endian: Endian = Big): u16 {$/;"	f
read_u32	$OCEN/buffer.oc	/^def BytesReader::read_u32(&this, endian: Endian = Big): u32 {$/;"	f
read_u64	$OCEN/buffer.oc	/^def BytesReader::read_u64(&this, endian: Endian = Big): u64 {$/;"	f
read_u8	$OCEN/buffer.oc	/^def BytesReader::read_u8(&this): u8 {$/;"	f
read_var_length	$OCEN/midi.oc	/^def read_var_length(io: &BytesReader): u32 {$/;"	f
readdir	$OCEN/fs.oc	/^    [extern] def readdir(dir: &Dir): &dirent$/;"	f
reader	$OCEN/buffer.oc	/^def Buffer::reader(this): BytesReader => BytesReader::make(.data, .size)$/;"	f
reader	$OCEN/sv.oc	/^def SV::reader(this): BytesReader => BytesReader::make(.data as &u8, .len)$/;"	f
real	$OCEN/complex.oc	/^[extern "crealf"] def Complex::real(this): f32$/;"	f
realloc	$OCEN/mem.oc	/^def realloc<T>(ptr: &T, old_count: u32, new_count: u32): &T {$/;"	f
realpath	$OCEN/fs.oc	/^def realpath(path: str): str => bindings::realpath(path, null)$/;"	f
reflect	$OCEN/vec.oc	/^def Vec3::reflect(this, normal: Vec3<T>): Vec3<T> => .sub(normal.mults(2 as T * .dot(normal)))$/;"	f
remove	$OCEN/compact_map.oc	/^def Map::remove(&this, key: K) {$/;"	f
remove	$OCEN/map.oc	/^def Map::remove(&this, key: K) {$/;"	f
remove	$OCEN/set.oc	/^def Set::remove(&this, key: T) {$/;"	f
remove_last_n	$OCEN/mod.oc	/^def str::remove_last_n(this, n: u32) {$/;"	f
remove_node	$OCEN/linkedlist.oc	/^def LinkedList::remove_node(&this, node: &Node<T>) {$/;"	f
render_solid	$OCEN/sdl/ttf.oc	/^[extern "TTF_RenderText_Solid"] def Font::render_solid(&this, text: str, color: Color): &Surface$/;"	f
replace_with	$OCEN/mod.oc	/^def str::replace_with(&this, other: str) {$/;"	f
reset_to_default_allocator	$OCEN/mem.oc	/^def reset_to_default_allocator() {$/;"	f
resize	$OCEN/compact_map.oc	/^def Map::resize(&this, new_capacity: u32) {$/;"	f
resize	$OCEN/deque.oc	/^def Deque::resize(&this, new_capacity: u32) {$/;"	f
resize	$OCEN/image/mod.oc	/^def Image::resize(&this, new_width: u32, new_height: u32): &Image {$/;"	f
resize	$OCEN/map.oc	/^def Map::resize(&this) {$/;"	f
resize	$OCEN/vector.oc	/^def Vector::resize(&this, new_capacity: u32) {$/;"	f
resize_if_necessary	$OCEN/buffer.oc	/^def Buffer::resize_if_necessary(&this, new_size: u32) {$/;"	f
resize_if_necessary	$OCEN/compact_map.oc	/^def Map::resize_if_necessary(&this) {$/;"	f
restore	$OCEN/sdl/mod.oc	/^[extern "SDL_RestoreWindow"]  def Window::restore(&this)$/;"	f
resume	$OCEN/sdl/mixer.oc	/^[extern "Mix_Resume"] def resume(channel: i32)$/;"	f
rotate	$OCEN/image/mod.oc	/^def Image::rotate(&this, dir: RotationDirection = RotationDirection::Clockwise): &Image {$/;"	f
rotate	$OCEN/vec.oc	/^def Vec2::rotate(&this, angle: f32): Vec2f {$/;"	f
rotateX	$OCEN/vec.oc	/^def Vec3::rotateX(&this, angle: f32): Vec3f {$/;"	f
rotateY	$OCEN/vec.oc	/^def Vec3::rotateY(&this, angle: f32): Vec3f {$/;"	f
rotateZ	$OCEN/vec.oc	/^def Vec3::rotateZ(&this, angle: f32): Vec3f {$/;"	f
rotate_left	$OCEN/hash/utils.oc	/^def rotate_left(value: u32, bits: u32): u32 {$/;"	f
rotate_right	$OCEN/hash/utils.oc	/^def rotate_right(value: u32, bits: u32): u32 {$/;"	f
save	$OCEN/image/mod.oc	/^def Image::save(&this, filename: str) {$/;"	f
seed	$OCEN/random.oc	/^def RandomState::seed(&this, s: u32) {$/;"	f
seek	$OCEN/fs.oc	/^def File::seek(&this, offset: i64, mode: SeekMode) {$/;"	f
select	$OCEN/fcntl.oc	/^[extern "select"] def select(nfds: i32, readfds: &FdSet, writefds: &FdSet, exceptfds: &FdSet, ti/;"	f
send_frame	$OCEN/video_renderer/ffmpeg.oc	/^def FFMPEGContext::send_frame(&this, img: &Image): bool {$/;"	f
send_frame	$OCEN/video_renderer/mod.oc	/^def VideoRenderer::send_frame(&this, img: &Image) {$/;"	f
send_frame	$OCEN/video_renderer/sdl.oc	/^def SDLContext::send_frame(&this, img: &Image) {$/;"	f
serialize	$OCEN/bencode.oc	/^def serialize(val: &Value): Buffer {$/;"	f
serialize	$OCEN/json.oc	/^def serialize(val: &Value): Buffer {$/;"	f
serialize_into	$OCEN/bencode.oc	/^def serialize_into(val: &Value, sb: &Buffer) {$/;"	f
serialize_into	$OCEN/json.oc	/^def serialize_into(val: &Value, sb: &Buffer) {$/;"	f
set	$OCEN/fcntl.oc	/^def FdSet::set(&this, fd: i32) => c_FD_SET(fd, this)$/;"	f
set	$OCEN/image/mod.oc	/^def Image::set(&this, x: u32, y: u32, col: Color) { .data[y * .width + x] = col }$/;"	f
set	$OCEN/value.oc	/^def Value::set(&this, idx: u32, value: &Value) {$/;"	f
set	$OCEN/vector.oc	/^def Vector::set(&this, i: u32, val: T) {$/;"	f
set_allocator	$OCEN/mem.oc	/^def set_allocator($/;"	f
set_blend_mode	$OCEN/sdl/mod.oc	/^[extern "SDL_SetRenderDrawBlendMode"]   def Renderer::set_blend_mode(&this, blend: BlendMode)$/;"	f
set_bool	$OCEN/value.oc	/^[operator "[]="] def Value::set_bool(&this, idx: u32, b: bool) => .set(idx, Value::new_bool(b))$/;"	f
set_cursor	$OCEN/og/mod.oc	/^def set_cursor(c: sdl::CursorType) {$/;"	f
set_cursor	$OCEN/sdl/mod.oc	/^[extern "SDL_SetCursor"]          def set_cursor(cursor: &Cursor)$/;"	f
set_draw_color	$OCEN/sdl/mod.oc	/^[extern "SDL_SetRenderDrawColor"]       def Renderer::set_draw_color(&this, r: i32, g: i32, b: i/;"	f
set_f32	$OCEN/value.oc	/^[operator "[]="] def Value::set_f32(&this, idx: u32, f: f32) => .set(idx, Value::new_float(f as /;"	f
set_f64	$OCEN/value.oc	/^[operator "[]="] def Value::set_f64(&this, idx: u32, f: f64) => .set(idx, Value::new_float(f))$/;"	f
set_fullscreen	$OCEN/sdl/mod.oc	/^[extern "SDL_SetWindowFullscreen"]     def Window::set_fullscreen(&this, fullscreen: i32): i32$/;"	f
set_i32	$OCEN/value.oc	/^[operator "[]="] def Value::set_i32(&this, idx: u32, i: i32) => .set(idx, Value::new_int(i as i6/;"	f
set_i64	$OCEN/value.oc	/^[operator "[]="] def Value::set_i64(&this, idx: u32, i: i64) => .set(idx, Value::new_int(i))$/;"	f
set_jump_point	$OCEN/setjmp.oc	/^def ErrorContext::set_jump_point(this): i32$/;"	f
set_mode	$OCEN/sdl/mod.oc	/^[extern "SDL_SetWindowFullscreen"] def Window::set_mode(&this, mode: WindowMode)$/;"	f
set_position	$OCEN/sdl/mod.oc	/^[extern "SDL_SetWindowPosition"]       def Window::set_position(&this, x: i32, y: i32)$/;"	f
set_resizable	$OCEN/sdl/mod.oc	/^[extern "SDL_SetWindowResizable"]  def Window::set_resizable(&this, resizable: bool)$/;"	f
set_size	$OCEN/sdl/mod.oc	/^[extern "SDL_SetWindowSize"]  def Window::set_size(&this, w: i32, h: i32)$/;"	f
set_str	$OCEN/value.oc	/^[operator "[]="] def Value::set_str(&this, idx: u32, s: str) => .set(idx, Value::new_str(s))$/;"	f
set_title	$OCEN/sdl/mod.oc	/^[extern "SDL_SetWindowTitle"]           def Window::set_title(&this, title: str)$/;"	f
set_u32	$OCEN/value.oc	/^[operator "[]="] def Value::set_u32(&this, idx: u32, i: u32) => .set(idx, Value::new_int(i as i6/;"	f
set_u64	$OCEN/value.oc	/^[operator "[]="] def Value::set_u64(&this, idx: u32, i: u64) => .set(idx, Value::new_int(i as i6/;"	f
shift_args	$OCEN/mod.oc	/^def shift_args(argc: &i32, argv: &&str, where: str = "here"): str {$/;"	f
should_swap	$OCEN/heap.oc	/^def Heap::should_swap(&this, a: u32, b: u32): bool {$/;"	f
show_cursor	$OCEN/sdl/mod.oc	/^[extern "SDL_ShowCursor"]              def show_cursor(toggle: bool)$/;"	f
sift_down	$OCEN/heap.oc	/^def Heap::sift_down(&this, i: u32 = 0) {$/;"	f
sift_up	$OCEN/heap.oc	/^def Heap::sift_up(&this, i: u32) {$/;"	f
sig0	$OCEN/hash/sha256.oc	/^    def sig0(x: u32): u32 => rotate_right(x, 7) ^ rotate_right(x, 18) ^ (x >> 3)$/;"	f
sig1	$OCEN/hash/sha256.oc	/^    def sig1(x: u32): u32 => rotate_right(x, 17) ^ rotate_right(x, 19) ^ (x >> 10)$/;"	f
sin	$OCEN/complex.oc	/^[extern "csinf"] def Complex::sin(this): Complex$/;"	f
sin	$OCEN/math.oc	/^[extern "sinf"] def f32::sin(this): f32$/;"	f
size	$OCEN/compact_map.oc	/^def Map::size(&this): u32 => .items.size$/;"	f
size	$OCEN/fs.oc	/^def File::size(&this): u32 {$/;"	f
size	$OCEN/heap.oc	/^def Heap::size(&this): u32 => .vec.size$/;"	f
sleep	$OCEN/thread.oc	/^[extern] def sleep(seconds: u32)$/;"	f
slice	$OCEN/sv.oc	/^def SV::slice(this, off: u32, end: u32 = 0): SV {$/;"	f
sockaddr_in	$OCEN/socket.oc	/^[extern "struct sockaddr_in"]$/;"	f
socket	$OCEN/socket.oc	/^[extern] def socket(domain: i32, type: i32, protocol: i32): i32$/;"	f
sort	$OCEN/heap.oc	/^def Heap::sort(&this) {$/;"	f
sort	$OCEN/sort.oc	/^def sort<T>(data: &T, size: u32) => sort_by<T>(data, size, T::compare)$/;"	f
sort_by	$OCEN/sort.oc	/^def sort_by<T>(data: &T, size: u32, cmp: fn(T,T): i8) {$/;"	f
split_str	$OCEN/sv.oc	/^def SV::split_str(this, delim: str): SVSplitIterator => SVSplitIterator(this, SV::from_str(delim/;"	f
split_sv	$OCEN/sv.oc	/^def SV::split_sv(this, delim: SV): SVSplitIterator => SVSplitIterator(this, delim)$/;"	f
split_words	$OCEN/sv.oc	/^def SV::split_words(this): SVWordIterator => SVWordIterator(this)$/;"	f
sqrt	$OCEN/math.oc	/^[extern "sqrtf"] def f32::sqrt(this): f32$/;"	f
srand	$OCEN/random.oc	/^    [extern] def srand(seed: u32)$/;"	f
start	$OCEN/variadic.oc	/^[extern "va_start"] def VarArgs::start(this, ...)$/;"	f
starts_right_after	$OCEN/span.oc	/^def Span::starts_right_after(this, other: Span): bool {$/;"	f
starts_with	$OCEN/mod.oc	/^def str::starts_with(this, prefix: str): bool {$/;"	f
starts_with_str	$OCEN/sv.oc	/^def SV::starts_with_str(this, other: str): bool => .starts_with_sv(SV::from_str(other))$/;"	f
starts_with_sv	$OCEN/sv.oc	/^def SV::starts_with_sv(this, other: SV): bool {$/;"	f
stat	$OCEN/fs.oc	/^    [extern] def stat(path: str, buf: &FileStat): i32$/;"	f
std	$OCEN/sdl/gfx.oc	/^[extern "trigonColor"]        def std::sdl::Renderer::draw_tri_color(&this, x1: i32, y1: i32, x2/;"	f
std	$OCEN/sdl/image.oc	/^[extern "IMG_LoadTexture"] def std::sdl::Renderer::load_image(&this, path: str): &Texture$/;"	f
str	$OCEN/buffer.oc	/^def Buffer::str(this): str => .data as str$/;"	f
str	$OCEN/curl.oc	/^[extern "curl_easy_strerror"] def Status::str(this): str$/;"	f
str	$OCEN/mod.oc	/^def str::to_u32(this): u32 => this.to_i32() as u32 \/\/ FIXME: this doesn't always work$/;"	f
str	$OCEN/span.oc	/^def Span::str(this): str => `{.start.str()} => {.end.str()}`$/;"	f
str	$OCEN/traits/compare.oc	/^def str::compare(this, b: str): i8 => std::libc::strcmp(this, b) as i8/;"	f
str	$OCEN/traits/hash.oc	/^def str::hash(this): u32 => hash_bytes(this as &u8, this.len())$/;"	f
str	$OCEN/value.oc	/^def ValueType::str(this): str => .dbg()$/;"	f
strcat	$OCEN/libc.oc	/^[extern] def strcat(dst: str, src: str): str$/;"	f
strchr	$OCEN/libc.oc	/^[extern] def strchr(s: str, c: i32): str$/;"	f
strcmp	$OCEN/libc.oc	/^[extern] def strcmp(a: str, b: str): i32$/;"	f
strcpy	$OCEN/libc.oc	/^[extern] def strcpy(dst: str, src: str): str$/;"	f
strerror	$OCEN/libc.oc	/^[extern] def strerror(errnum: i32): str$/;"	f
strftime	$OCEN/time.oc	/^[extern] def strftime(s: untyped_ptr, maxsize: u32, format: str, timeptr: &TM): u32$/;"	f
strip_trailing_whitespace	$OCEN/mod.oc	/^def str::strip_trailing_whitespace(this) {$/;"	f
strlen	$OCEN/libc.oc	/^[extern] def strlen(s: str): u32$/;"	f
strsep	$OCEN/libc.oc	/^[extern] def strsep(str: &str, delim: str): str$/;"	f
strstr	$OCEN/libc.oc	/^[extern] def strstr(haystack: str, needle: str): str$/;"	f
strtod	$OCEN/libc.oc	/^[extern] def strtod(s: str, endptr: &str): f64$/;"	f
strtof	$OCEN/libc.oc	/^[extern] def strtof(s: str, endptr: &str): f32$/;"	f
strtol	$OCEN/libc.oc	/^[extern] def strtol(s: str, endptr: &str, base: i32 = 10): i32$/;"	f
strtoll	$OCEN/libc.oc	/^[extern] def strtoll(s: str, endptr: &str, base: i32 = 10): i64$/;"	f
strtoul	$OCEN/libc.oc	/^[extern] def strtoul(s: str, endptr: &str, base: i32 = 10): u64$/;"	f
sub	$OCEN/complex.oc	/^def Complex::sub(this, other: Complex): Complex {$/;"	f
sub	$OCEN/vec.oc	/^[operator "-"] def Vec3::sub(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x - other.x, .y - other./;"	f
subrs	$OCEN/vec.oc	/^[operator "-"] def Vec3::subrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val - this.x, val - th/;"	f
subs	$OCEN/vec.oc	/^[operator "-"] def Vec3::subs(this, val: T): Vec3<T> => Vec3<T>(.x - val, .y - val, .z - val)$/;"	f
substring	$OCEN/mod.oc	/^def str::substring(this, start: u32, len: u32): str {$/;"	f
subtract	$OCEN/set.oc	/^def Set::subtract(&this, other: &Set<T>) {$/;"	f
swap	$OCEN/heap.oc	/^def Heap::swap(&this, a: u32, b: u32) {$/;"	f
system	$OCEN/libc.oc	/^[extern] def system(cmd: str): i32$/;"	f
tan	$OCEN/complex.oc	/^[extern "ctanf"] def Complex::tan(this): Complex$/;"	f
tan	$OCEN/math.oc	/^[extern "tanf"] def f32::tan(this): f32$/;"	f
ticks_to_seconds	$OCEN/midi.oc	/^def Parser::ticks_to_seconds(&this, ticks: u64): f64 {$/;"	f
time	$OCEN/time.oc	/^[extern] def time(t: &Time): Time$/;"	f
to_f32	$OCEN/mod.oc	/^[extern "atof"] def str::to_f32(this): f32$/;"	f
to_f32	$OCEN/vec.oc	/^def Vec3::to_f32(this): Vec3f => Vec3f(.x as f32, .y as f32, .z as f32)$/;"	f
to_f64	$OCEN/vec.oc	/^def Vec3::to_f64(this): Vec3f64 => Vec3f64(.x as f64, .y as f64, .z as f64)$/;"	f
to_i32	$OCEN/mod.oc	/^[extern "atoi"] def str::to_i32(this): i32$/;"	f
to_i32	$OCEN/vec.oc	/^def Vec3::to_i32(this): Vec3i => Vec3i(.x as i32, .y as i32, .z as i32)$/;"	f
to_i64	$OCEN/vec.oc	/^def Vec3::to_i64(this): Vec3i64 => Vec3i64(.x as i64, .y as i64, .z as i64)$/;"	f
to_u32	$OCEN/mod.oc	/^def str::to_u32(this): u32 => this.to_i32() as u32 \/\/ FIXME: this doesn't always work$/;"	f
to_u32	$OCEN/vec.oc	/^def Vec3::to_u32(this): Vec3u => Vec3u(.x as u32, .y as u32, .z as u32)$/;"	f
to_u64	$OCEN/vec.oc	/^def Vec3::to_u64(this): Vec3u64 => Vec3u64(.x as u64, .y as u64, .z as u64)$/;"	f
token	$OCEN/json.oc	/^def Parser::token(&this): &Token => .tokens.at(.curr)$/;"	f
tolower	$OCEN/libc.oc	/^[extern] def tolower(c: char): char$/;"	f
toupper	$OCEN/libc.oc	/^[extern] def toupper(c: char): char$/;"	f
transform	$OCEN/hash/sha256.oc	/^def Context::transform(&this, data: &u8) {$/;"	f
trim	$OCEN/sv.oc	/^def SV::trim(&this) {$/;"	f
trim_left	$OCEN/sv.oc	/^def SV::trim_left(&this) {$/;"	f
trim_right	$OCEN/sv.oc	/^def SV::trim_right(&this) {$/;"	f
truncate	$OCEN/fs.oc	/^def File::truncate(&this, size: i64) {$/;"	f
try_connect	$OCEN/socket.oc	/^def Socket::try_connect(host: str, port: i32, mode: SocketMode, out_sock: &Socket, timeout_secs:/;"	f
u16	$OCEN/traits/compare.oc	/^def u16::compare(this, b: u16): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
u16	$OCEN/traits/eq.oc	/^def u16::eq(this, other: u16): bool => this == other$/;"	f
u16	$OCEN/traits/hash.oc	/^def u16::hash(this): u32 => this as u32 * 7817$/;"	f
u32	$OCEN/mod.oc	/^def u32::min(this, other: u32): u32 => if this < other then this else other$/;"	f
u32	$OCEN/traits/compare.oc	/^def u32::compare(this, b: u32): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
u32	$OCEN/traits/eq.oc	/^def u32::eq(this, other: u32): bool => this == other$/;"	f
u32	$OCEN/traits/hash.oc	/^def u32::hash(this): u32 => this as u32 * 7817$/;"	f
u64	$OCEN/mod.oc	/^def u64::min(this, other: u64): u64 => if this < other then this else other$/;"	f
u64	$OCEN/traits/compare.oc	/^def u64::compare(this, b: u64): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
u64	$OCEN/traits/eq.oc	/^def u64::eq(this, other: u64): bool => this == other$/;"	f
u64	$OCEN/traits/hash.oc	/^def u64::hash(this): u32 => pair_hash((this as u32).hash(), ((this >> 32) as u32).hash())$/;"	f
uLongf	$OCEN/zlib.oc	/^    [extern] struct uLongf {}$/;"	f
uint16_t	$OCEN/prelude.h	/^typedef uint16_t u16;$/;"	f
uint32_t	$OCEN/prelude.h	/^typedef uint32_t u32;$/;"	f
uint64_t	$OCEN/prelude.h	/^typedef uint64_t u64;$/;"	f
uint8_t	$OCEN/prelude.h	/^typedef uint8_t u8;$/;"	f
unchecked_at	$OCEN/vector.oc	/^def Vector::unchecked_at(&this, i: u32): T => .data[i]$/;"	f
unchecked_pop	$OCEN/heap.oc	/^def Heap::unchecked_pop(&this): T {$/;"	f
unchecked_pop	$OCEN/vector.oc	/^def Vector::unchecked_pop(&this): T {$/;"	f
unlock	$OCEN/sdl/mod.oc	/^[extern "SDL_UnlockTexture"]  def Texture::unlock(&this)$/;"	f
update	$OCEN/hash/sha256.oc	/^def Context::update(&this, data: &u8, len: u64) {$/;"	f
value	$OCEN/map.oc	/^def Iterator::value(&this): V {$/;"	f
vlog	$OCEN/logging.oc	/^def vlog(level: LogLevel, fmt: str, vargs: VarArgs) {$/;"	f
volume	$OCEN/sdl/mixer.oc	/^[extern "Mix_Volume"] def volume(channel: i32, volume: i32)/;"	f
vprintf	$OCEN/variadic.oc	/^[extern] def vprintf(format: str, args: VarArgs): u32$/;"	f
vsnprintf	$OCEN/variadic.oc	/^[extern] def vsnprintf(buffer: str, size: u32, format: str, args: VarArgs): u32$/;"	f
vsprintf	$OCEN/variadic.oc	/^[extern] def vsprintf(buffer: str, format: str, args: VarArgs): u32$/;"	f
wait_and_finish	$OCEN/video_renderer/mod.oc	/^def VideoRenderer::wait_and_finish(&this) {$/;"	f
wait_event_timeout	$OCEN/sdl/mod.oc	/^[extern "SDL_WaitEventTimeout"] def wait_event_timeout(event: &Event, timeout: i32): bool$/;"	f
wait_for_quit	$OCEN/video_renderer/sdl.oc	/^def SDLContext::wait_for_quit(&this) {$/;"	f
waitpid	$OCEN/libc.oc	/^[extern] def waitpid(a: i32, b: &i32, c: i32): i32$/;"	f
write	$OCEN/fs.oc	/^def File::write(&this, buf: untyped_ptr, size: u32): i32 {$/;"	f
write	$OCEN/libc.oc	/^[extern] def write(a: i32, b: &u32, c: u32): i32$/;"	f
write	$OCEN/socket.oc	/^def Socket::write(&this, buf: &Buffer): u32 => write(this.fd, buf.data, buf.size)$/;"	f
write_buf	$OCEN/buffer.oc	/^def Buffer::write_buf(&this, buf: &Buffer) {$/;"	f
write_buf_f	$OCEN/buffer.oc	/^def Buffer::write_buf_f(&this, buf: &Buffer) {$/;"	f
write_bytes	$OCEN/buffer.oc	/^def Buffer::write_bytes(&this, bytes: untyped_ptr, size: u32) {$/;"	f
write_callback	$OCEN/curl.oc	/^    def write_callback($/;"	f
write_char	$OCEN/buffer.oc	/^def Buffer::write_char(&this, c: char) => .write_u8(c as u8)$/;"	f
write_file	$OCEN/fs.oc	/^def write_file(path: str, data: Buffer) {$/;"	f
write_file_bytes	$OCEN/fs.oc	/^def write_file_bytes(path: str, data: untyped_ptr, size: u32) {$/;"	f
write_file_str	$OCEN/fs.oc	/^def write_file_str(path: str, data: str) {$/;"	f
write_i16	$OCEN/buffer.oc	/^def Buffer::write_i16(&this, value: i16, endian: Endian = Big) { .write_u16(value as u16, endian/;"	f
write_i32	$OCEN/buffer.oc	/^def Buffer::write_i32(&this, value: i32, endian: Endian = Big) { .write_u32(value as u32, endian/;"	f
write_i64	$OCEN/buffer.oc	/^def Buffer::write_i64(&this, value: i64, endian: Endian = Big) { .write_u64(value as u64, endian/;"	f
write_i8	$OCEN/buffer.oc	/^def Buffer::write_i8(&this, value: i8) { .write_u8(value as u8) }$/;"	f
write_str	$OCEN/buffer.oc	/^def Buffer::write_str(&this, s: str) {$/;"	f
write_str_f	$OCEN/buffer.oc	/^def Buffer::write_str_f(&this, s: str) {$/;"	f
write_sv	$OCEN/buffer.oc	/^def Buffer::write_sv(&this, sv: SV) => .write_bytes(sv.data as &u8, sv.len)$/;"	f
write_to_file	$OCEN/json.oc	/^def write_to_file(val: &Value, filename: str) {$/;"	f
write_u16	$OCEN/buffer.oc	/^def Buffer::write_u16(&this, value: u16, endian: Endian = Big) {$/;"	f
write_u32	$OCEN/buffer.oc	/^def Buffer::write_u32(&this, value: u32, endian: Endian = Big) {$/;"	f
write_u64	$OCEN/buffer.oc	/^def Buffer::write_u64(&this, value: u64, endian: Endian = Big) {$/;"	f
write_u8	$OCEN/buffer.oc	/^def Buffer::write_u8(&this, value: u8) {$/;"	f
zero	$OCEN/fcntl.oc	/^[extern "FD_ZERO"] def FdSet::zero(&this)$/;"	f

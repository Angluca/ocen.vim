AST	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct AST {$/;"	f
ASTType	$OCEN_ROOT/compiler/ast/nodes.oc	/^enum ASTType {$/;"	f
ATLAS_FONT	$OCEN_ROOT/std/ogui/atlas.oc	/^const ATLAS_FONT: i32 = 5   \/\/ First font character$/;"	f
ATLAS_HEIGHT	$OCEN_ROOT/std/ogui/atlas.oc	/^const ATLAS_HEIGHT: i32 = 128$/;"	f
ATLAS_WHITE	$OCEN_ROOT/std/ogui/atlas.oc	/^const ATLAS_WHITE: i32 = 4  \/\/ Icon::Max$/;"	f
ATLAS_WIDTH	$OCEN_ROOT/std/ogui/atlas.oc	/^const ATLAS_WIDTH: i32 = 128$/;"	f
Arg	$OCEN_ROOT/std/argparse.oc	/^struct Arg {$/;"	f
ArgType	$OCEN_ROOT/std/argparse.oc	/^enum ArgType {$/;"	f
ArgUnion	$OCEN_ROOT/std/argparse.oc	/^struct ArgUnion {$/;"	f
Argument	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Argument {$/;"	f
ArrayLiteral	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct ArrayLiteral {$/;"	f
ArrayType	$OCEN_ROOT/compiler/types.oc	/^struct ArrayType {$/;"	f
Assertion	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Assertion {$/;"	f
Attribute	$OCEN_ROOT/compiler/attributes.oc	/^struct Attribute {$/;"	f
AttributeType	$OCEN_ROOT/compiler/attributes.oc	/^enum AttributeType {$/;"	f
Barrier	$OCEN_ROOT/std/thread.oc	/^struct Barrier {$/;"	f
BaseType	$OCEN_ROOT/compiler/types.oc	/^enum BaseType {$/;"	f
Binary	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Binary {$/;"	f
BitReader	$OCEN_ROOT/std/bitio.oc	/^struct BitReader {$/;"	f
BitWriter	$OCEN_ROOT/std/bitio.oc	/^struct BitWriter {$/;"	f
BlendMode	$OCEN_ROOT/std/sdl/mod.oc	/^enum BlendMode extern("SDL_BlendMode") {$/;"	f
Block	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Block {$/;"	f
BoolAction	$OCEN_ROOT/std/argparse.oc	/^enum BoolAction {$/;"	f
Buffer	$OCEN_ROOT/std/buffer.oc	/^struct Buffer {$/;"	f
BytesReader	$OCEN_ROOT/std/buffer.oc	/^struct BytesReader {$/;"	f
CLOCK_MONOTONIC	$OCEN_ROOT/std/time.oc	/^[extern] const CLOCK_MONOTONIC: i32$/;"	f
COLORSTYLE_MAX	$OCEN_ROOT/std/mui.oc	/^const COLORSTYLE_MAX: u32 = 14$/;"	f
CONTAINERPOOL_SIZE	$OCEN_ROOT/std/mui.oc	/^const CONTAINERPOOL_SIZE: u32 = 48$/;"	f
CURSOR_TYPE_COUNT	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_NUM_SYSTEM_CURSORS"] const CURSOR_TYPE_COUNT: i32$/;"	f
CachedSymbols	$OCEN_ROOT/compiler/ast/program.oc	/^struct CachedSymbols {$/;"	f
CallBackType	$OCEN_ROOT/std/thread.oc	/^typedef CallBackType = fn(untyped_ptr): untyped_ptr$/;"	f
CallType	$OCEN_ROOT/compiler/ast/nodes.oc	/^enum CallType {$/;"	f
Cast	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Cast {$/;"	f
CharCode	$OCEN_ROOT/std/huffman.oc	/^struct CharCode {$/;"	f
CharIterator	$OCEN_ROOT/std/mod.oc	/^struct CharIterator {$/;"	f
Chunk	$OCEN_ROOT/std/image/png.oc	/^struct Chunk {$/;"	f
Clip	$OCEN_ROOT/std/mui.oc	/^enum Clip {$/;"	f
ClosedVariable	$OCEN_ROOT/compiler/ast/scopes.oc	/^struct ClosedVariable {$/;"	f
CodeGenerator	$OCEN_ROOT/compiler/passes/code_generator.oc	/^struct CodeGenerator {$/;"	f
Color	$OCEN_ROOT/std/image/mod.oc	/^struct Color {$/;"	f
Color	$OCEN_ROOT/std/sdl/mod.oc	/^struct Color  {$/;"	f
ColorStyle	$OCEN_ROOT/std/mui.oc	/^enum ColorStyle {$/;"	f
ColorType	$OCEN_ROOT/std/image/png.oc	/^enum ColorType {$/;"	f
Command	$OCEN_ROOT/std/mui.oc	/^enum Command {$/;"	f
CommandType	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^enum CommandType {$/;"	f
Complex	$OCEN_ROOT/std/complex.oc	/^struct Complex {}$/;"	f
Cond	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_cond_wait"]    def Cond::wait(&this, mtx: &Mutex): i32$/;"	f
ConstU8Ptr	$OCEN_ROOT/std/sdl/mod.oc	/^    [extern "const Uint8 *"]          struct ConstU8Ptr$/;"	f
Container	$OCEN_ROOT/std/mui.oc	/^struct Container {$/;"	f
Context	$OCEN_ROOT/std/curl.oc	/^def Context::easy_setopt($/;"	f
Context	$OCEN_ROOT/std/hash/sha256.oc	/^struct Context {$/;"	f
Context	$OCEN_ROOT/std/mui.oc	/^struct Context {$/;"	f
Cursor	$OCEN_ROOT/std/sdl/mod.oc	/^struct Cursor$/;"	f
CursorType	$OCEN_ROOT/std/sdl/mod.oc	/^enum CursorType extern("SDL_SystemCursor") {$/;"	f
DEFAULT_FORMAT	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "MIX_DEFAULT_FORMAT"] const DEFAULT_FORMAT: u16$/;"	f
DIR	$OCEN_ROOT/compiler/utils.oc	/^[extern] struct DIR$/;"	f
DT_DIR	$OCEN_ROOT/std/fs.oc	/^    [extern] const DT_DIR: i32$/;"	f
DT_LNK	$OCEN_ROOT/std/fs.oc	/^    [extern] const DT_LNK: i32$/;"	f
DT_REG	$OCEN_ROOT/std/fs.oc	/^    [extern] const DT_REG: i32$/;"	f
Decompressor	$OCEN_ROOT/std/huffman.oc	/^struct Decompressor {$/;"	f
Deque	$OCEN_ROOT/std/deque.oc	/^struct Deque<T> {$/;"	f
DetachState	$OCEN_ROOT/std/thread.oc	/^enum DetachState{$/;"	f
DiagnosticSeverity	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^enum DiagnosticSeverity {$/;"	f
Dir	$OCEN_ROOT/std/fs.oc	/^    [extern "DIR"] struct Dir$/;"	f
DirectoryEntry	$OCEN_ROOT/std/fs.oc	/^struct DirectoryEntry {$/;"	f
DirectoryIterator	$OCEN_ROOT/std/fs.oc	/^struct DirectoryIterator {$/;"	f
DisjointSet	$OCEN_ROOT/std/disjoint_set.oc	/^struct DisjointSet<T> {$/;"	f
DocGenerator	$OCEN_ROOT/compiler/docgen.oc	/^struct DocGenerator {$/;"	f
EXIT_FAILURE	$OCEN_ROOT/std/libc/mod.oc	/^[extern] const EXIT_FAILURE: i32$/;"	f
EXIT_SUCCESS	$OCEN_ROOT/std/libc/mod.oc	/^[extern] const EXIT_SUCCESS: i32$/;"	f
Endian	$OCEN_ROOT/std/mod.oc	/^enum Endian {$/;"	f
EntryType	$OCEN_ROOT/std/fs.oc	/^enum EntryType {$/;"	f
Enum	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Enum {$/;"	f
EnumField	$OCEN_ROOT/compiler/ast/scopes.oc	/^struct EnumField {$/;"	f
EnumVariant	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct EnumVariant {$/;"	f
Error	$OCEN_ROOT/compiler/errors.oc	/^struct Error {$/;"	f
ErrorContext	$OCEN_ROOT/std/setjmp.oc	/^struct ErrorContext$/;"	f
ErrorPropBase	$OCEN_ROOT/compiler/passes/typechecker.oc	/^enum ErrorPropBase {$/;"	f
ErrorType	$OCEN_ROOT/compiler/errors.oc	/^enum ErrorType {$/;"	f
Event	$OCEN_ROOT/std/sdl/mod.oc	/^struct Event {$/;"	f
EventType	$OCEN_ROOT/std/sdl/mod.oc	/^enum EventType extern("SDL_EventType") {$/;"	f
FFMPEGContext	$OCEN_ROOT/std/video_renderer/ffmpeg.oc	/^struct FFMPEGContext {$/;"	f
FRAMETIMES_COUNT	$OCEN_ROOT/std/og/state.oc	/^const FRAMETIMES_COUNT: u32 = 200$/;"	f
FdSet	$OCEN_ROOT/std/fcntl.oc	/^def FdSet::set(&this, fd: i32) => c_FD_SET(fd, this)$/;"	f
File	$OCEN_ROOT/std/fs.oc	/^def File::write(&this, buf: untyped_ptr, size: u32): i32 {$/;"	f
FileMetadata	$OCEN_ROOT/std/fs.oc	/^struct FileMetadata {$/;"	f
FileStat	$OCEN_ROOT/std/fs.oc	/^    [extern "struct stat"] struct FileStat {$/;"	f
Finder	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^struct Finder {$/;"	f
Finder	$OCEN_ROOT/compiler/passes/register_types.oc	/^struct Finder {$/;"	f
Font	$OCEN_ROOT/std/mui.oc	/^typedef Font = untyped_ptr$/;"	f
Font	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_SizeText"]         def Font::get_text_size(&this, text: str, w: &i32, h: &i32)$/;"	f
FormatString	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct FormatString {$/;"	f
Formattable	$OCEN_ROOT/compiler/passes/typechecker.oc	/^enum Formattable {$/;"	f
FuncCall	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct FuncCall {$/;"	f
Function	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Function {$/;"	f
FunctionKind	$OCEN_ROOT/compiler/ast/nodes.oc	/^enum FunctionKind {$/;"	f
FunctionType	$OCEN_ROOT/compiler/types.oc	/^struct FunctionType {$/;"	f
GLOBAL_DEFAULT	$OCEN_ROOT/std/curl.oc	/^[extern "CURL_GLOBAL_DEFAULT"] const GLOBAL_DEFAULT: u64$/;"	f
GLUT_DEPTH	$OCEN_ROOT/std/glut.oc	/^[extern] const GLUT_DEPTH: i32$/;"	f
GLUT_DOUBLE	$OCEN_ROOT/std/glut.oc	/^[extern] const GLUT_DOUBLE: i32$/;"	f
GLUT_RGB	$OCEN_ROOT/std/glut.oc	/^[extern] const GLUT_RGB: i32$/;"	f
GL_COLOR_BUFFER_BIT	$OCEN_ROOT/std/glut.oc	/^[extern] const GL_COLOR_BUFFER_BIT: i32$/;"	f
GL_DEPTH_BUFFER_BIT	$OCEN_ROOT/std/glut.oc	/^[extern] const GL_DEPTH_BUFFER_BIT: i32$/;"	f
GL_DEPTH_TEST	$OCEN_ROOT/std/glut.oc	/^[extern] const GL_DEPTH_TEST: i32$/;"	f
GL_LINES	$OCEN_ROOT/std/glut.oc	/^[extern] const GL_LINES: i32$/;"	f
GL_MODELVIEW	$OCEN_ROOT/std/glut.oc	/^[extern] const GL_MODELVIEW: i32$/;"	f
GL_POLYGON	$OCEN_ROOT/std/glut.oc	/^[extern] const GL_POLYGON: i32$/;"	f
GL_PROJECTION	$OCEN_ROOT/std/glut.oc	/^[extern] const GL_PROJECTION: i32$/;"	f
GenericPass	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^struct GenericPass {$/;"	f
HASH_INITIAL	$OCEN_ROOT/std/mui.oc	/^const HASH_INITIAL: u32 = 2166136261$/;"	f
HINT_EMSCRIPTEN_KEYBOARD_ELEMENT	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT"] const HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: str$/;"	f
HSV	$OCEN_ROOT/std/mui.oc	/^struct HSV {$/;"	f
Header	$OCEN_ROOT/std/gc.oc	/^    struct Header {$/;"	f
Heap	$OCEN_ROOT/std/heap.oc	/^struct Heap<T> {$/;"	f
HostEnt	$OCEN_ROOT/std/socket.oc	/^    struct HostEnt {$/;"	f
HuffmanCodes	$OCEN_ROOT/std/huffman.oc	/^struct HuffmanCodes {$/;"	f
HuffmanTree	$OCEN_ROOT/std/huffman.oc	/^struct HuffmanTree {$/;"	f
ICON_CHECK	$OCEN_ROOT/std/ogui/atlas.oc	/^const ICON_CHECK: i32 = 1$/;"	f
ICON_CLOSE	$OCEN_ROOT/std/ogui/atlas.oc	/^const ICON_CLOSE: i32 = 0$/;"	f
ICON_COLLAPSED	$OCEN_ROOT/std/ogui/atlas.oc	/^const ICON_COLLAPSED: i32 = 2$/;"	f
ICON_EXPANDED	$OCEN_ROOT/std/ogui/atlas.oc	/^const ICON_EXPANDED: i32 = 3$/;"	f
INDEX_DELETED	$OCEN_ROOT/std/compact_map.oc	/^const INDEX_DELETED: i32 = -2$/;"	f
INDEX_FREE	$OCEN_ROOT/std/compact_map.oc	/^const INDEX_FREE: i32 = -1$/;"	f
INFINITY	$OCEN_ROOT/std/math.oc	/^[extern "INFINITY"] const INFINITY: f64$/;"	f
INIT_EVERYTHING	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_INIT_EVERYTHING"]         const INIT_EVERYTHING: i32$/;"	f
INPUT_TEXT_SIZE	$OCEN_ROOT/std/mui.oc	/^const INPUT_TEXT_SIZE: u32 = 128$/;"	f
Icon	$OCEN_ROOT/std/mui.oc	/^enum Icon {$/;"	f
Identifier	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Identifier {$/;"	f
IfBranch	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct IfBranch {$/;"	f
IfStatement	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct IfStatement {$/;"	f
Image	$OCEN_ROOT/std/image/mod.oc	/^struct Image {$/;"	f
Import	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Import {$/;"	f
ImportPart	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct ImportPart {$/;"	f
ImportPartMultiple	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct ImportPartMultiple {$/;"	f
ImportPartSingle	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct ImportPartSingle {$/;"	f
ImportPartType	$OCEN_ROOT/compiler/ast/nodes.oc	/^enum ImportPartType {$/;"	f
ImportType	$OCEN_ROOT/compiler/ast/nodes.oc	/^enum ImportType {$/;"	f
InterlaceMethod	$OCEN_ROOT/std/image/png.oc	/^enum InterlaceMethod {$/;"	f
IsExpression	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct IsExpression {$/;"	f
Item	$OCEN_ROOT/std/compact_map.oc	/^struct Item<K, V> {$/;"	f
Item	$OCEN_ROOT/std/map.oc	/^struct Item<K, V> {$/;"	f
Iterator	$OCEN_ROOT/std/compact_map.oc	/^struct Iterator<K, V> {$/;"	f
Iterator	$OCEN_ROOT/std/linkedlist.oc	/^struct Iterator<T> {$/;"	f
Iterator	$OCEN_ROOT/std/map.oc	/^struct Iterator<K, V> {$/;"	f
Iterator	$OCEN_ROOT/std/set.oc	/^struct Iterator<T> {$/;"	f
Iterator	$OCEN_ROOT/std/vector.oc	/^struct Iterator<T> {$/;"	f
Key	$OCEN_ROOT/std/mui.oc	/^enum Key {$/;"	f
Key	$OCEN_ROOT/std/sdl/mod.oc	/^enum Key extern("SDL_Scancode") {$/;"	f
KeyIterator	$OCEN_ROOT/std/compact_map.oc	/^struct KeyIterator<K, V> {$/;"	f
KeyIterator	$OCEN_ROOT/std/map.oc	/^struct KeyIterator<K, V> {$/;"	f
KeyState	$OCEN_ROOT/std/midi.oc	/^struct KeyState {$/;"	f
KeyState	$OCEN_ROOT/std/og/state.oc	/^struct KeyState {$/;"	f
KeyboardEvent	$OCEN_ROOT/std/sdl/mod.oc	/^struct KeyboardEvent {$/;"	f
Keysym	$OCEN_ROOT/std/sdl/mod.oc	/^struct Keysym {$/;"	f
LAYOUTSTACK_SIZE	$OCEN_ROOT/std/mui.oc	/^const LAYOUTSTACK_SIZE: u32 = 16$/;"	f
LSPServer	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^struct LSPServer {$/;"	f
LSPSymbolKind	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^enum LSPSymbolKind {$/;"	f
Layout	$OCEN_ROOT/std/mui.oc	/^struct Layout {$/;"	f
Lexer	$OCEN_ROOT/compiler/lexer.oc	/^struct Lexer {$/;"	f
LibraryInfo	$OCEN_ROOT/compiler/parser.oc	/^struct LibraryInfo {$/;"	f
LinkedList	$OCEN_ROOT/std/linkedlist.oc	/^struct LinkedList<T> {$/;"	f
Loc	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^struct Loc {$/;"	f
Location	$OCEN_ROOT/std/span.oc	/^struct Location {$/;"	f
LogLevel	$OCEN_ROOT/std/logging.oc	/^enum LogLevel {$/;"	f
Loop	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Loop {$/;"	f
MAX_FMT	$OCEN_ROOT/std/mui.oc	/^const MAX_FMT: u32 = 127$/;"	f
MAX_M	$OCEN_ROOT/compiler/utils.oc	/^const MAX_M: u32 = 128$/;"	f
MAX_N	$OCEN_ROOT/compiler/utils.oc	/^const MAX_N: u32 = 128$/;"	f
MAX_WIDTHS	$OCEN_ROOT/std/mui.oc	/^const MAX_WIDTHS: u32 = 16$/;"	f
MEM_SIZE	$OCEN_ROOT/std/bump_alloc.oc	/^const MEM_SIZE: u64 = 1u64 * 1024 * 1024 * 1024$/;"	f
Map	$OCEN_ROOT/std/compact_map.oc	/^struct Map<K, V> {$/;"	f
Map	$OCEN_ROOT/std/map.oc	/^struct Map<K, V> {$/;"	f
MapLiteral	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct MapLiteral {$/;"	f
MapLiteralPair	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct MapLiteralPair {$/;"	f
MapShorthandType	$OCEN_ROOT/compiler/types.oc	/^struct MapShorthandType {$/;"	f
MarkDeadCode	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^struct MarkDeadCode {$/;"	f
Match	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Match {$/;"	f
MatchCase	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct MatchCase {$/;"	f
MatchCond	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct MatchCond {$/;"	f
MatchCondArg	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct MatchCondArg {$/;"	f
Matrix4f	$OCEN_ROOT/std/matrix.oc	/^struct Matrix4f {$/;"	f
Member	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Member {$/;"	f
MessageType	$OCEN_ROOT/compiler/errors.oc	/^enum MessageType {$/;"	f
MidiFile	$OCEN_ROOT/std/midi.oc	/^struct MidiFile {$/;"	f
Mode	$OCEN_ROOT/std/heap.oc	/^enum Mode {$/;"	f
Mouse	$OCEN_ROOT/std/mui.oc	/^enum Mouse {$/;"	f
MouseButton	$OCEN_ROOT/std/sdl/mod.oc	/^enum MouseButton extern("u8") {$/;"	f
MouseButtonEvent	$OCEN_ROOT/std/sdl/mod.oc	/^struct MouseButtonEvent {$/;"	f
MouseState	$OCEN_ROOT/std/og/state.oc	/^struct MouseState {$/;"	f
MouseWheel	$OCEN_ROOT/std/og/state.oc	/^enum MouseWheel {$/;"	f
MouseWheelEvent	$OCEN_ROOT/std/sdl/mod.oc	/^struct MouseWheelEvent {$/;"	f
Mutex	$OCEN_ROOT/std/thread.oc	/^struct Mutex {$/;"	f
MutexAttr	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_mutexattr_t"]  struct MutexAttr {}$/;"	f
MutexMode	$OCEN_ROOT/std/thread.oc	/^enum MutexMode{$/;"	f
NODEFER	$OCEN_ROOT/std/signal.oc	/^[extern "SA_NODEFER"] const NODEFER: u32$/;"	f
NSIterator	$OCEN_ROOT/compiler/ast/program.oc	/^struct NSIterator {$/;"	f
NSLookup	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct NSLookup {$/;"	f
NUM_SCANCODES	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_NUM_SCANCODES"]           const NUM_SCANCODES: i32$/;"	f
Namespace	$OCEN_ROOT/compiler/ast/program.oc	/^struct Namespace {$/;"	f
NamespaceDump	$OCEN_ROOT/compiler/passes/namespace_dump.oc	/^struct NamespaceDump {$/;"	f
Node	$OCEN_ROOT/std/huffman.oc	/^struct Node {$/;"	f
Node	$OCEN_ROOT/std/linkedlist.oc	/^struct Node<T> {$/;"	f
NodeType	$OCEN_ROOT/std/huffman.oc	/^enum NodeType {$/;"	f
Note	$OCEN_ROOT/std/midi.oc	/^struct Note {$/;"	f
NumLiteral	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct NumLiteral {$/;"	f
Operator	$OCEN_ROOT/compiler/ast/operators.oc	/^enum Operator {$/;"	f
OperatorOverload	$OCEN_ROOT/compiler/ast/operators.oc	/^struct OperatorOverload {$/;"	f
Opt	$OCEN_ROOT/std/mui.oc	/^enum Opt {$/;"	f
Option	$OCEN_ROOT/std/curl.oc	/^enum Option {$/;"	f
Option	$OCEN_ROOT/std/option.oc	/^enum Option<T> {$/;"	f
Output	$OCEN_ROOT/std/process.oc	/^struct Output {$/;"	f
PATH_MAX	$OCEN_ROOT/std/fs.oc	/^    [extern] const PATH_MAX: u32$/;"	f
PI	$OCEN_ROOT/std/math.oc	/^[extern "M_PI"] const PI: f32$/;"	f
PIXELFORMAT_ABGR8888	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_PIXELFORMAT_ABGR8888"]    const PIXELFORMAT_ABGR8888: i32$/;"	f
PNG	$OCEN_ROOT/std/image/png.oc	/^struct PNG {$/;"	f
Parser	$OCEN_ROOT/compiler/parser.oc	/^struct Parser {$/;"	f
Parser	$OCEN_ROOT/std/argparse.oc	/^struct Parser {$/;"	f
Parser	$OCEN_ROOT/std/bencode.oc	/^struct Parser {$/;"	f
Parser	$OCEN_ROOT/std/json.oc	/^struct Parser {$/;"	f
Parser	$OCEN_ROOT/std/midi.oc	/^struct Parser {$/;"	f
PoolItem	$OCEN_ROOT/std/mui.oc	/^struct PoolItem {$/;"	f
PositionType	$OCEN_ROOT/std/mui.oc	/^enum PositionType {$/;"	f
Program	$OCEN_ROOT/compiler/ast/program.oc	/^struct Program {$/;"	f
QOIDecoder	$OCEN_ROOT/std/image/qoi.oc	/^struct QOIDecoder {$/;"	f
QOIEncoder	$OCEN_ROOT/std/image/qoi.oc	/^struct QOIEncoder {$/;"	f
READ_END	$OCEN_ROOT/std/video_renderer/ffmpeg.oc	/^const READ_END: u32 = 0$/;"	f
REAL_FMT	$OCEN_ROOT/std/mui.oc	/^const REAL_FMT: str = "%.3g"$/;"	f
RENDERER_ACCELERATED	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RENDERER_ACCELERATED"]    const RENDERER_ACCELERATED: i32$/;"	f
RGBA	$OCEN_ROOT/std/image/qoi.oc	/^struct RGBA {$/;"	f
RandomState	$OCEN_ROOT/std/random.oc	/^struct RandomState {$/;"	f
Rect	$OCEN_ROOT/std/mui.oc	/^struct Rect {$/;"	f
Rect	$OCEN_ROOT/std/og/mod.oc	/^struct Rect {$/;"	f
Rect	$OCEN_ROOT/std/sdl/mod.oc	/^struct Rect  {$/;"	f
RecvFromResult	$OCEN_ROOT/std/socket.oc	/^struct RecvFromResult {$/;"	f
Reference	$OCEN_ROOT/compiler/ast/scopes.oc	/^struct Reference {$/;"	f
ReferenceType	$OCEN_ROOT/compiler/ast/scopes.oc	/^enum ReferenceType {$/;"	f
RegisterTypes	$OCEN_ROOT/compiler/passes/register_types.oc	/^struct RegisterTypes {$/;"	f
Renderer	$OCEN_ROOT/std/sdl/mod.oc	/^def Renderer::copy_and_display(&this, texture: &Texture, src: &Rect = null, dst: &Rect = null) {$/;"	f
ReorderSymbols	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^struct ReorderSymbols {$/;"	f
Res	$OCEN_ROOT/std/mui.oc	/^enum Res {$/;"	f
Result	$OCEN_ROOT/std/result.oc	/^enum Result<T, E> {$/;"	f
Return	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Return {$/;"	f
RotationDirection	$OCEN_ROOT/std/image/mod.oc	/^enum RotationDirection {$/;"	f
SDLContext	$OCEN_ROOT/std/video_renderer/sdl.oc	/^struct SDLContext {$/;"	f
SHA1Hash	$OCEN_ROOT/std/hash/sha1.oc	/^struct SHA1Hash {$/;"	f
SHA256Hash	$OCEN_ROOT/std/hash/sha256.oc	/^struct SHA256Hash {$/;"	f
SLIDER_FMT	$OCEN_ROOT/std/mui.oc	/^const SLIDER_FMT: str = "%.2f"$/;"	f
SList	$OCEN_ROOT/std/curl.oc	/^[extern "struct curl_slist"] struct SList$/;"	f
STDIN_FILENO	$OCEN_ROOT/std/libc/mod.oc	/^[extern] const STDIN_FILENO: i32$/;"	f
SV	$OCEN_ROOT/std/sv.oc	/^struct SV {$/;"	f
SVLineIterator	$OCEN_ROOT/std/sv.oc	/^struct SVLineIterator {$/;"	f
SVNumberIterator	$OCEN_ROOT/std/sv.oc	/^struct SVNumberIterator<T> {$/;"	f
SVPredicateIterator	$OCEN_ROOT/std/sv.oc	/^struct SVPredicateIterator {$/;"	f
SVSplitIterator	$OCEN_ROOT/std/sv.oc	/^struct SVSplitIterator {$/;"	f
SVWordIterator	$OCEN_ROOT/std/sv.oc	/^struct SVWordIterator {$/;"	f
Scancode	$OCEN_ROOT/std/sdl/mod.oc	/^struct Scancode$/;"	f
SchedPolicy	$OCEN_ROOT/std/thread.oc	/^enum SchedPolicy{$/;"	f
Scope	$OCEN_ROOT/compiler/ast/scopes.oc	/^struct Scope {$/;"	f
SeekMode	$OCEN_ROOT/std/fs.oc	/^enum SeekMode {$/;"	f
Set	$OCEN_ROOT/std/set.oc	/^struct Set<T> {$/;"	f
SigAction	$OCEN_ROOT/std/signal.oc	/^[extern "struct sigaction"] struct SigAction {$/;"	f
Signal	$OCEN_ROOT/std/signal.oc	/^enum Signal {$/;"	f
SinAddr	$OCEN_ROOT/std/socket.oc	/^    struct SinAddr {$/;"	f
SockAddr	$OCEN_ROOT/std/socket.oc	/^    [extern "struct sockaddr"] struct SockAddr$/;"	f
SockAddrIn	$OCEN_ROOT/std/socket.oc	/^    struct SockAddrIn {$/;"	f
Socket	$OCEN_ROOT/std/socket.oc	/^struct Socket {$/;"	f
SocketMode	$OCEN_ROOT/std/socket.oc	/^enum SocketMode {$/;"	f
SocketStatus	$OCEN_ROOT/std/socket.oc	/^enum SocketStatus {$/;"	f
Sound	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_Chunk"] struct Sound$/;"	f
Span	$OCEN_ROOT/std/span.oc	/^struct Span {$/;"	f
Specialization	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Specialization {$/;"	f
State	$OCEN_ROOT/std/mem.oc	/^typedef State = untyped_ptr$/;"	f
Status	$OCEN_ROOT/std/curl.oc	/^[extern "curl_easy_strerror"] def Status::str(this): str$/;"	f
Stream	$OCEN_ROOT/std/zlib.oc	/^    [extern "z_stream"] struct Stream {$/;"	f
Structure	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Structure {$/;"	f
Style	$OCEN_ROOT/std/mui.oc	/^struct Style {$/;"	f
Surface	$OCEN_ROOT/std/sdl/mod.oc	/^struct Surface$/;"	f
Symbol	$OCEN_ROOT/compiler/ast/scopes.oc	/^struct Symbol {$/;"	f
SymbolType	$OCEN_ROOT/compiler/ast/scopes.oc	/^enum SymbolType {$/;"	f
TAU	$OCEN_ROOT/std/math.oc	/^const TAU: f32 = PI * 2.0$/;"	f
TEXTUREACCESS_STREAMING	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_TEXTUREACCESS_STREAMING"] const TEXTUREACCESS_STREAMING: i32$/;"	f
TM	$OCEN_ROOT/std/time.oc	/^[extern "struct tm"] struct TM {$/;"	f
TMP_TEXT_SIZE	$OCEN_ROOT/std/mui.oc	/^const TMP_TEXT_SIZE: u32 = (1024 * 1024)  \/\/ For text output, temporary buffer$/;"	f
TREENODEPOOL_SIZE	$OCEN_ROOT/std/mui.oc	/^const TREENODEPOOL_SIZE: u32 = 48$/;"	f
TcpListener	$OCEN_ROOT/std/socket.oc	/^struct TcpListener {$/;"	f
TcpStream	$OCEN_ROOT/std/socket.oc	/^struct TcpStream {$/;"	f
Template	$OCEN_ROOT/compiler/ast/scopes.oc	/^struct Template {$/;"	f
TemplateInstance	$OCEN_ROOT/compiler/ast/scopes.oc	/^struct TemplateInstance {$/;"	f
TextDocument	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^struct TextDocument {$/;"	f
TextInputEvent	$OCEN_ROOT/std/sdl/mod.oc	/^struct TextInputEvent {$/;"	f
Texture	$OCEN_ROOT/std/og/mod.oc	/^struct Texture {$/;"	f
Texture	$OCEN_ROOT/std/sdl/mod.oc	/^def Texture::write_image(&this, img: &Image) {$/;"	f
Thread	$OCEN_ROOT/std/thread.oc	/^struct Thread {$/;"	f
ThreadAttr	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_attr_t"] struct ThreadAttr$/;"	f
Time	$OCEN_ROOT/std/time.oc	/^[extern "time_t"] struct Time {}$/;"	f
TimeSpec	$OCEN_ROOT/std/time.oc	/^[extern "struct timespec"] struct TimeSpec {$/;"	f
TimeVal	$OCEN_ROOT/std/time.oc	/^[extern "struct timeval"] struct TimeVal {$/;"	f
Timer	$OCEN_ROOT/std/timer.oc	/^struct Timer {$/;"	f
Token	$OCEN_ROOT/compiler/tokens.oc	/^struct Token {$/;"	f
TokenType	$OCEN_ROOT/compiler/tokens.oc	/^enum TokenType {$/;"	f
Track	$OCEN_ROOT/std/midi.oc	/^struct Track {$/;"	f
Type	$OCEN_ROOT/compiler/types.oc	/^struct Type {$/;"	f
TypeChecker	$OCEN_ROOT/compiler/passes/typechecker.oc	/^struct TypeChecker {$/;"	f
TypeUnion	$OCEN_ROOT/compiler/types.oc	/^struct TypeUnion {$/;"	f
USE_CMD_MODE	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^const USE_CMD_MODE: bool = false$/;"	f
UdpSocket	$OCEN_ROOT/std/socket.oc	/^struct UdpSocket {$/;"	f
Unary	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Unary {$/;"	f
UnresolvedTemplate	$OCEN_ROOT/compiler/types.oc	/^struct UnresolvedTemplate {$/;"	f
Value	$OCEN_ROOT/std/value.oc	/^struct Value {$/;"	f
ValueIterator	$OCEN_ROOT/std/compact_map.oc	/^struct ValueIterator<K, V> {$/;"	f
ValueIterator	$OCEN_ROOT/std/map.oc	/^struct ValueIterator<K, V> {$/;"	f
ValueType	$OCEN_ROOT/std/value.oc	/^enum ValueType {$/;"	f
VarArgs	$OCEN_ROOT/std/variadic.oc	/^[extern "va_start"] def VarArgs::start(this, ...)$/;"	f
Variable	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct Variable {$/;"	f
Vec2	$OCEN_ROOT/std/vec.oc	/^struct Vec2<T> {$/;"	f
Vec2f	$OCEN_ROOT/std/vec.oc	/^typedef Vec2f = Vec2<f32>$/;"	f
Vec2f64	$OCEN_ROOT/std/vec.oc	/^typedef Vec2f64 = Vec2<f64>$/;"	f
Vec2i	$OCEN_ROOT/std/vec.oc	/^typedef Vec2i = Vec2<i32>$/;"	f
Vec2i64	$OCEN_ROOT/std/vec.oc	/^typedef Vec2i64 = Vec2<i64>$/;"	f
Vec2u	$OCEN_ROOT/std/vec.oc	/^typedef Vec2u = Vec2<u32>$/;"	f
Vec2u64	$OCEN_ROOT/std/vec.oc	/^typedef Vec2u64 = Vec2<u64>$/;"	f
Vec3	$OCEN_ROOT/std/vec.oc	/^struct Vec3<T> {$/;"	f
Vec3f	$OCEN_ROOT/std/vec.oc	/^typedef Vec3f = Vec3<f32>$/;"	f
Vec3f64	$OCEN_ROOT/std/vec.oc	/^typedef Vec3f64 = Vec3<f64>$/;"	f
Vec3i	$OCEN_ROOT/std/vec.oc	/^typedef Vec3i = Vec3<i32>$/;"	f
Vec3i64	$OCEN_ROOT/std/vec.oc	/^typedef Vec3i64 = Vec3<i64>$/;"	f
Vec3u	$OCEN_ROOT/std/vec.oc	/^typedef Vec3u = Vec3<u32>$/;"	f
Vec3u64	$OCEN_ROOT/std/vec.oc	/^typedef Vec3u64 = Vec3<u64>$/;"	f
Vector	$OCEN_ROOT/std/vector.oc	/^struct Vector<T> {$/;"	f
VectorLiteral	$OCEN_ROOT/compiler/ast/nodes.oc	/^struct VectorLiteral {$/;"	f
VideoRenderer	$OCEN_ROOT/std/video_renderer/mod.oc	/^struct VideoRenderer {$/;"	f
VideoRendererType	$OCEN_ROOT/std/video_renderer/mod.oc	/^enum VideoRendererType {$/;"	f
Visitor	$OCEN_ROOT/compiler/passes/visitor.oc	/^struct Visitor {$/;"	f
WEXITSTATUS	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def WEXITSTATUS(a: i32): i32$/;"	f
WIFEXITED	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def WIFEXITED(a: i32): bool$/;"	f
WIFSIGNALED	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def WIFSIGNALED(a: i32): bool$/;"	f
WINDOWPOS_CENTERED	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_WINDOWPOS_CENTERED"]      const WINDOWPOS_CENTERED: i32$/;"	f
WINDOW_FULLSCREEN	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_WINDOW_FULLSCREEN"]       const WINDOW_FULLSCREEN: i32$/;"	f
WINDOW_FULLSCREEN_DESKTOP	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_WINDOW_FULLSCREEN_DESKTOP"] const WINDOW_FULLSCREEN_DESKTOP: i32$/;"	f
WINDOW_RESIZABL	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_WINDOW_RESIZABL"]         const WINDOW_RESIZABL: i32$/;"	f
WINDOW_RESIZABLE	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_WINDOW_RESIZABLE"]        const WINDOW_RESIZABLE: i32$/;"	f
WRITE_END	$OCEN_ROOT/std/video_renderer/ffmpeg.oc	/^const WRITE_END: u32 = 1$/;"	f
WTERMSIG	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def WTERMSIG(a: i32): i32$/;"	f
Window	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_Window"] struct Window$/;"	f
WindowEvent	$OCEN_ROOT/std/sdl/mod.oc	/^struct WindowEvent {$/;"	f
WindowEventID	$OCEN_ROOT/std/sdl/mod.oc	/^enum WindowEventID extern("u8") {$/;"	f
WindowMode	$OCEN_ROOT/std/sdl/mod.oc	/^enum WindowMode extern("int") {$/;"	f
WriteCallback	$OCEN_ROOT/std/curl.oc	/^typedef WriteCallback = fn(untyped_ptr, u64, u64, untyped_ptr): u64$/;"	f
Z_NO_FLUSH	$OCEN_ROOT/std/zlib.oc	/^    [extern] const Z_NO_FLUSH: i32$/;"	f
Z_OK	$OCEN_ROOT/std/zlib.oc	/^    [extern] const Z_OK: i32$/;"	f
Z_STREAM_END	$OCEN_ROOT/std/zlib.oc	/^    [extern] const Z_STREAM_END: i32$/;"	f
_IONBF	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^[extern] const _IONBF: i32$/;"	f
__APPLE__	$OCEN_ROOT/std/prelude.h	/^#ifdef __APPLE__$/;"	f
_add	$OCEN_ROOT/std/argparse.oc	/^def Parser::_add($/;"	f
_alloc_fn	$OCEN_ROOT/std/gc.oc	/^    def _alloc_fn(_: mem::State, size: u32): untyped_ptr {$/;"	f
_free_fn	$OCEN_ROOT/std/gc.oc	/^    def _free_fn(_: mem::State, ptr: untyped_ptr) {}$/;"	f
_header_help	$OCEN_ROOT/std/mui.oc	/^def Context::_header_help(&this, label: str, istreenode: bool, opt: Opt): Res {$/;"	f
_realloc_fn	$OCEN_ROOT/std/gc.oc	/^    def _realloc_fn(_: mem::State, ptr: untyped_ptr, old_size: u32, size: u32): untyped_ptr {$/;"	f
abs	$OCEN_ROOT/std/complex.oc	/^[extern "cabsf"] def Complex::abs(this): f32$/;"	f
abs	$OCEN_ROOT/std/math.oc	/^def i8::abs(this): i8 => if this < 0 then -this else this$/;"	f
accept	$OCEN_ROOT/std/socket.oc	/^def TcpListener::accept(&this): Result<&TcpStream, SocketStatus> {$/;"	f
acos	$OCEN_ROOT/std/complex.oc	/^[extern "cacosf"] def Complex::acos(this): Complex$/;"	f
acos	$OCEN_ROOT/std/math.oc	/^[extern "acos"] def f32::acos(this): f32$/;"	f
add	$OCEN_ROOT/std/complex.oc	/^def Complex::add(this, other: Complex): Complex {$/;"	f
add	$OCEN_ROOT/std/set.oc	/^def Set::add(&this, key: T) {$/;"	f
add	$OCEN_ROOT/std/vec.oc	/^[operator "+"] def Vec3::add(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x + other.x, .y + other./;"	f
add_bool	$OCEN_ROOT/std/argparse.oc	/^def Parser::add_bool($/;"	f
add_dbg_method_for_enum	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::add_dbg_method_for_enum(&this, enom: &Enum) {$/;"	f
add_doc_comment	$OCEN_ROOT/compiler/parser.oc	/^def Parser::add_doc_comment(&this, sym: &Symbol, token: &Token) {$/;"	f
add_error_context	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::add_error_context(&this): &ErrorContext {$/;"	f
add_float	$OCEN_ROOT/std/argparse.oc	/^def Parser::add_float($/;"	f
add_frametime	$OCEN_ROOT/std/og/state.oc	/^def add_frametime(frametime: f32) {$/;"	f
add_history	$OCEN_ROOT/std/readline.oc	/^[extern "add_history"] def add_history(line: str)/;"	f
add_int	$OCEN_ROOT/std/argparse.oc	/^def Parser::add_int($/;"	f
add_reference	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::add_reference(&this, type: ReferenceType, span: Span) {$/;"	f
add_str	$OCEN_ROOT/std/argparse.oc	/^def Parser::add_str($/;"	f
addrs	$OCEN_ROOT/std/vec.oc	/^[operator "+"] def Vec3::addrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val + this.x, val + th/;"	f
adds	$OCEN_ROOT/std/vec.oc	/^[operator "+"] def Vec3::adds(this, val: T): Vec3<T> => Vec3<T>(.x + val, .y + val, .z + val)$/;"	f
alloc	$OCEN_ROOT/std/bump_alloc.oc	/^def alloc(_: mem::State, size: u32): untyped_ptr {$/;"	f
alloc	$OCEN_ROOT/std/gc.oc	/^def alloc(size: u32): untyped_ptr {$/;"	f
alloc	$OCEN_ROOT/std/mem.oc	/^def alloc<T>(count: u32 = 1): &T {$/;"	f
allocate_channels	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_AllocateChannels"] def allocate_channels(num: i32): i32$/;"	f
and	$OCEN_ROOT/compiler/passes/code_generator.oc	/^    if is_func_def and cur == top {$/;"	f
append	$OCEN_ROOT/std/curl.oc	/^[extern "curl_slist_append"] def SList::append(&this, string: str): &SList$/;"	f
arg	$OCEN_ROOT/std/complex.oc	/^[extern "cargf"] def Complex::arg(this): f32$/;"	f
as_bool	$OCEN_ROOT/std/value.oc	/^def Value::as_bool(&this): bool {$/;"	f
as_cstr	$OCEN_ROOT/std/value.oc	/^def Value::as_cstr(&this): str => .as_str().str()$/;"	f
as_dict	$OCEN_ROOT/std/value.oc	/^def Value::as_dict(&this): &Map<str, &Value> {$/;"	f
as_float	$OCEN_ROOT/std/value.oc	/^def Value::as_float(&this): f64 {$/;"	f
as_int	$OCEN_ROOT/std/value.oc	/^def Value::as_int(&this): i64 {$/;"	f
as_int_or	$OCEN_ROOT/std/value.oc	/^def Value::as_int_or(&this, defolt: i64): i64 => match .type {$/;"	f
as_list	$OCEN_ROOT/std/value.oc	/^def Value::as_list(&this): &Vector<&Value> {$/;"	f
as_str	$OCEN_ROOT/std/value.oc	/^def Value::as_str(&this): Buffer {$/;"	f
asin	$OCEN_ROOT/std/complex.oc	/^[extern "casinf"] def Complex::asin(this): Complex$/;"	f
asin	$OCEN_ROOT/std/math.oc	/^[extern "asin"] def f32::asin(this): f32$/;"	f
assert_ok	$OCEN_ROOT/std/process.oc	/^def Output::assert_ok(this): Buffer {$/;"	f
at	$OCEN_ROOT/std/compact_map.oc	/^def Map::at(&this, key: K): V {$/;"	f
at	$OCEN_ROOT/std/deque.oc	/^def Deque::at(&this, index: u32): T {$/;"	f
at	$OCEN_ROOT/std/map.oc	/^def Map::at(&this, key: K): V {$/;"	f
at	$OCEN_ROOT/std/sv.oc	/^def SV::at(this, n: u32): char {$/;"	f
at	$OCEN_ROOT/std/value.oc	/^def Value::at(&this, idx: u32): &Value {$/;"	f
at	$OCEN_ROOT/std/vector.oc	/^def Vector::at(&this, i: u32): T {$/;"	f
at_key	$OCEN_ROOT/std/value.oc	/^def Value::at_key(&this, key: str): &Value {$/;"	f
at_ptr	$OCEN_ROOT/std/vector.oc	/^def Vector::at_ptr(&this, i: u32 = 0): &T {$/;"	f
atan	$OCEN_ROOT/std/complex.oc	/^[extern "catanf"] def Complex::atan(this): Complex$/;"	f
atan2	$OCEN_ROOT/std/complex.oc	/^[extern "catan2f"] def Complex::atan2(this, other: Complex): Complex$/;"	f
atan2	$OCEN_ROOT/std/math.oc	/^[extern "atan2f"] def f32::atan2(this, y: f32): f32$/;"	f
atexit	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def atexit(callback: fn())$/;"	f
back	$OCEN_ROOT/std/deque.oc	/^def Deque::back(&this): T {$/;"	f
back	$OCEN_ROOT/std/vector.oc	/^def Vector::back(&this, i: u32 = 0): T {$/;"	f
back_ptr	$OCEN_ROOT/std/vector.oc	/^def Vector::back_ptr(&this, i: u32 = 0): &T {$/;"	f
basename	$OCEN_ROOT/compiler/parser.oc	/^[extern] def basename(path: str): str$/;"	f
begin	$OCEN_ROOT/std/mui.oc	/^def Context::begin(&this) {$/;"	f
begin_panel	$OCEN_ROOT/std/mui.oc	/^def Context::begin_panel(&this, name: str, opt: Opt = 0) {$/;"	f
begin_popup	$OCEN_ROOT/std/mui.oc	/^def Context::begin_popup(&this, name: str): Res {$/;"	f
begin_root_container	$OCEN_ROOT/std/mui.oc	/^def Context::begin_root_container(&this, cnt: &Container) {$/;"	f
begin_treenode	$OCEN_ROOT/std/mui.oc	/^def Context::begin_treenode(&this, label: str, opt: Opt = 0): Res {$/;"	f
begin_window	$OCEN_ROOT/std/mui.oc	/^def Context::begin_window(&this, title: str, rect: Rect, opt: Opt = 0): Res {$/;"	f
bilinear_interp	$OCEN_ROOT/std/image/mod.oc	/^def bilinear_interp(t0: f32, t1: f32, a: f32, b: f32, c: f32, d: f32):f32 {$/;"	f
bind	$OCEN_ROOT/std/socket.oc	/^def UdpSocket::bind(host: str, port: i32): Result<&UdpSocket, SocketStatus> {$/;"	f
bit_dump	$OCEN_ROOT/std/buffer.oc	/^def bit_dump(data: &u8, size: u32) {$/;"	f
bool	$OCEN_ROOT/std/traits/eq.oc	/^def bool::eq(this, other: bool): bool => this == other$/;"	f
bring_to_front	$OCEN_ROOT/std/mui.oc	/^def Context::bring_to_front(&this, cnt: &Container) => cnt.zindex = ++.last_zindex$/;"	f
broadcast	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_cond_broadcast"] def Cond::broadcast(&this): i32$/;"	f
builtin_trap	$OCEN_ROOT/std/mod.oc	/^[extern "oc_trap"] def builtin_trap()$/;"	f
button	$OCEN_ROOT/std/mui.oc	/^def Context::button(&this, label: str, icon: i32 = 0, opt: Opt = AlignCenter): Res {$/;"	f
c_FD_SET	$OCEN_ROOT/std/fcntl.oc	/^[extern "FD_SET"] def c_FD_SET(fd: i32, set: &FdSet)$/;"	f
c_calloc	$OCEN_ROOT/std/mem.oc	/^    [extern "calloc"] def c_calloc(size: u32, elem_size: u32): untyped_ptr$/;"	f
c_free	$OCEN_ROOT/std/mem.oc	/^    [extern "free"] def c_free(ptr: untyped_ptr)$/;"	f
c_malloc	$OCEN_ROOT/std/mem.oc	/^    [extern "malloc"] def c_malloc(size: u32): untyped_ptr$/;"	f
c_realloc	$OCEN_ROOT/std/mem.oc	/^    [extern "realloc"] def c_realloc(old: untyped_ptr, size: u32): untyped_ptr$/;"	f
c_set_main_loop	$OCEN_ROOT/std/og/mod.oc	/^    [extern] def c_set_main_loop(callback: fn(): bool)$/;"	f
calculate_text_width	$OCEN_ROOT/std/ogui/atlas.oc	/^def calculate_text_width(text: str, len: i32): i32 {$/;"	f
call_dbg_on_enum_value	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::call_dbg_on_enum_value(&this, node_ptr: &&AST): &Type {$/;"	f
can_assign	$OCEN_ROOT/compiler/types.oc	/^def Type::can_assign(&this, rhs: &Type): bool {$/;"	f
can_have_methods	$OCEN_ROOT/compiler/types.oc	/^def Type::can_have_methods(&this): bool => match .base {$/;"	f
capture_mouse	$OCEN_ROOT/std/og/mod.oc	/^def capture_mouse(capture: bool) => sdl::capture_mouse(capture)$/;"	f
capture_mouse	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_CaptureMouse"] def capture_mouse(enabled: bool)$/;"	f
ceil	$OCEN_ROOT/std/math.oc	/^[extern "ceilf"] def f32::ceil(this): f32$/;"	f
ch	$OCEN_ROOT/std/hash/sha256.oc	/^    def ch(x: u32, y: u32, z: u32): u32 => (x & y) ^ (~x & z)$/;"	f
char	$OCEN_ROOT/std/mod.oc	/^def char::value_from_hex(this): u8 {$/;"	f
char	$OCEN_ROOT/std/traits/compare.oc	/^def char::compare(this, b: char): i8 => (this > b) as i8 - (this < b) as i8/;"	f
char	$OCEN_ROOT/std/traits/eq.oc	/^def char::eq(this, other: char): bool => this == other$/;"	f
char	$OCEN_ROOT/std/traits/hash.oc	/^def char::hash(this): u32 => this as u32 * 7817$/;"	f
chars	$OCEN_ROOT/std/mod.oc	/^def str::chars(this, start: u32 = 0): CharIterator => CharIterator(this, this.len(), start)$/;"	f
chars	$OCEN_ROOT/std/sv.oc	/^def SV::chars(this, start: u32 = 0): std::CharIterator => std::CharIterator(.data, .len, start)$/;"	f
chdir	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def chdir(a: str): i32$/;"	f
check	$OCEN_ROOT/std/thread.oc	/^def check(a: i32, msg: str = null) {$/;"	f
check_assignment	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_assignment(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {$/;"	f
check_binary_op	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_binary_op(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {$/;"	f
check_block	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_block(&this, node: &AST, is_expr: bool, hint: &Type = null) {$/;"	f
check_call	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_call(&this, node: &AST, hint: &Type = null): &Type {$/;"	f
check_call_args	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_call_args(&this, node: &AST, params: &Vector<&Variable>, is_variadic: boo/;"	f
check_call_args_labelled	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_call_args_labelled(&this, node: &AST, params: &Vector<&Variable>, start: /;"	f
check_clip	$OCEN_ROOT/std/mui.oc	/^def Context::check_clip(&this, r: Rect): Clip {$/;"	f
check_const_expression	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_const_expression(&this, node: &AST, hint: &Type = null): &Type {$/;"	f
check_constructor	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_constructor(&this, node: &AST): &Type {$/;"	f
check_enum_constructor	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_enum_constructor(&this, node: &AST): &Type {$/;"	f
check_error_prop	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_error_prop(&this, node: &AST): &Type {$/;"	f
check_error_unwrap	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_error_unwrap(&this, node: &AST): &Type {$/;"	f
check_expression	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_expression(&this, node: &AST, hint: &Type = null): &Type {$/;"	f
check_expression_helper	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_expression_helper(&this, node: &AST, hint: &Type): &Type {$/;"	f
check_expression_statement	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_expression_statement(&this, node: &AST, body: &AST, is_expr: bool, hint: /;"	f
check_for	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_for(&this, node: &AST) {$/;"	f
check_format_string	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_format_string(&this, node: &AST): &Type {$/;"	f
check_function	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_function(&this, func: &Function) {$/;"	f
check_function_declaration	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_function_declaration(&this, func: &Function) {$/;"	f
check_globals	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_globals(&this, node: &AST, is_const: bool) {$/;"	f
check_if	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_if(&this, node: &AST, is_expr: bool, hint: &Type = null) {$/;"	f
check_index	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_index(&this, node: &AST, hint: &Type, is_being_assigned: bool): &Type {$/;"	f
check_is_expr_in_if_condition	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_is_expr_in_if_condition(&this, cond: &AST) {$/;"	f
check_match	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_match(&this, node: &AST, is_expr: bool, hint: &Type = null) {$/;"	f
check_match_case_and_find_overload	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_match_case_and_find_overload(&this, expr: &AST, cond: &MatchCond): &Funct/;"	f
check_match_case_enum	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_match_case_enum($/;"	f
check_match_for_bool	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_match_for_bool(&this, node: &AST, is_expr: bool, hint: &Type = null) {$/;"	f
check_match_for_enum	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_match_for_enum(&this, enom: &Enum, node: &AST, is_expr: bool, hint: &Type/;"	f
check_member	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_member(&this, node: &AST,  is_being_called: bool, is_try: bool, hint: &Ty/;"	f
check_method_call	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_method_call(&this, method: &Function, node: &AST) {$/;"	f
check_namespace	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_namespace(&this, ns: &Namespace) {$/;"	f
check_operator_overload_function	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_operator_overload_function(&this, func: &Function, op: Operator) {$/;"	f
check_pointer_arith	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_pointer_arith(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {$/;"	f
check_post_import	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_post_import(&this, ns: &Namespace) {$/;"	f
check_pre_import	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_pre_import(&this, ns: &Namespace) {$/;"	f
check_statement	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_statement(&this, node: &AST) {$/;"	f
check_union_constructor	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_union_constructor(&this, node: &AST, params: &Vector<&Variable>) {$/;"	f
check_while	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::check_while(&this, node: &AST) {$/;"	f
checkbox	$OCEN_ROOT/std/mui.oc	/^def Context::checkbox(&this, label: str, state: &bool): Res {$/;"	f
chop_by_delim	$OCEN_ROOT/std/sv.oc	/^def SV::chop_by_delim(&this, delim: char): SV {$/;"	f
chop_by_str	$OCEN_ROOT/std/sv.oc	/^def SV::chop_by_str(&this, delim: str): SV => .chop_by_sv(SV::from_str(delim))$/;"	f
chop_by_sv	$OCEN_ROOT/std/sv.oc	/^def SV::chop_by_sv(&this, delim: SV): SV {$/;"	f
chop_f32	$OCEN_ROOT/std/sv.oc	/^def SV::chop_f32(&this): f32 {$/;"	f
chop_i16	$OCEN_ROOT/std/sv.oc	/^def SV::chop_i16(&this): i16 => .chop_signed("SV::chop_i16") as i16$/;"	f
chop_i32	$OCEN_ROOT/std/sv.oc	/^def SV::chop_i32(&this): i32 => .chop_signed("SV::chop_i32") as i32$/;"	f
chop_i64	$OCEN_ROOT/std/sv.oc	/^def SV::chop_i64(&this): i64 => .chop_signed("SV::chop_i64") as i64$/;"	f
chop_i8	$OCEN_ROOT/std/sv.oc	/^def SV::chop_i8(&this): i8 => .chop_signed("SV::chop_i8") as i8$/;"	f
chop_left	$OCEN_ROOT/std/sv.oc	/^def SV::chop_left(&this, n: u32 = 1): SV {$/;"	f
chop_line	$OCEN_ROOT/std/sv.oc	/^def SV::chop_line(&this): SV => .chop_by_delim('\\n')$/;"	f
chop_right	$OCEN_ROOT/std/sv.oc	/^def SV::chop_right(&this, n: u32 = 1): SV {$/;"	f
chop_signed	$OCEN_ROOT/std/sv.oc	/^def SV::chop_signed(&this, fn_name: str): i64 {$/;"	f
chop_u16	$OCEN_ROOT/std/sv.oc	/^def SV::chop_u16(&this): u16 => .chop_unsigned("SV::chop_u16") as u16$/;"	f
chop_u32	$OCEN_ROOT/std/sv.oc	/^def SV::chop_u32(&this): u32 => .chop_unsigned("SV::chop_u32") as u32$/;"	f
chop_u64	$OCEN_ROOT/std/sv.oc	/^def SV::chop_u64(&this): u64 => .chop_unsigned("SV::chop_u64") as u64$/;"	f
chop_u8	$OCEN_ROOT/std/sv.oc	/^def SV::chop_u8(&this): u8 => .chop_unsigned("SV::chop_u8") as u8$/;"	f
chop_unsigned	$OCEN_ROOT/std/sv.oc	/^def SV::chop_unsigned(&this, fn_name: str): u64 {$/;"	f
chop_word	$OCEN_ROOT/std/sv.oc	/^def SV::chop_word(&this): SV {$/;"	f
circle	$OCEN_ROOT/std/image/draw.oc	/^def circle(img: &Image, x: i32, y: i32, radius: i32, color: Color, segments: u32 = 100) {$/;"	f
circle_f	$OCEN_ROOT/std/image/draw.oc	/^def circle_f(img: &Image, x: f32, y: f32, radius: f32, color: Color, segments: u32 = 100) {$/;"	f
clamp	$OCEN_ROOT/std/math.oc	/^def u32::clamp(this, min: u32, max: u32): u32 => u32::max(u32::min(this, max), min)$/;"	f
clamp01	$OCEN_ROOT/std/math.oc	/^def f64::clamp01(this): f64 => this.clamp(0.0, 1.0)$/;"	f
clamp01	$OCEN_ROOT/std/vec.oc	/^def Vec3::clamp01(this): Vec3<T> {$/;"	f
clear	$OCEN_ROOT/std/buffer.oc	/^def Buffer::clear(&this) {$/;"	f
clear	$OCEN_ROOT/std/compact_map.oc	/^def Map::clear(&this) {$/;"	f
clear	$OCEN_ROOT/std/heap.oc	/^def Heap::clear(&this) {$/;"	f
clear	$OCEN_ROOT/std/image/mod.oc	/^def Image::clear(&this, col: Color = Color(0, 0, 0)) {$/;"	f
clear	$OCEN_ROOT/std/map.oc	/^def Map::clear(&this) {$/;"	f
clear	$OCEN_ROOT/std/og/mod.oc	/^def clear(col: Color) {$/;"	f
clear	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderClear"]     def Renderer::clear(&this)$/;"	f
clear	$OCEN_ROOT/std/set.oc	/^def Set::clear(&this) {$/;"	f
clear	$OCEN_ROOT/std/vector.oc	/^def Vector::clear(&this) {$/;"	f
clear_attributes	$OCEN_ROOT/compiler/parser.oc	/^def Parser::clear_attributes(&this) {$/;"	f
clip_rect_to_bounds	$OCEN_ROOT/std/mui_og/mod.oc	/^def clip_rect_to_bounds(rect: Rect, clip: Rect): Rect {$/;"	f
clip_rect_to_bounds	$OCEN_ROOT/std/ogui/mod.oc	/^def clip_rect_to_bounds(rect: Rect, clip: Rect): Rect {$/;"	f
clock_gettime	$OCEN_ROOT/std/time.oc	/^[extern] def clock_gettime(clock_id: i32, ts: &TimeSpec): i32$/;"	f
close	$OCEN_ROOT/std/fs.oc	/^[extern "fclose"] def File::close(&this)$/;"	f
close	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def close(a: i32): i32$/;"	f
close	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_CloseFont"]        def Font::close(&this)$/;"	f
close	$OCEN_ROOT/std/socket.oc	/^def UdpSocket::close(&this) {$/;"	f
closedir	$OCEN_ROOT/compiler/utils.oc	/^[extern] def closedir(dir: &DIR)$/;"	f
closedir	$OCEN_ROOT/std/fs.oc	/^    [extern] def closedir(dir: &Dir)$/;"	f
collect	$OCEN_ROOT/std/gc.oc	/^def collect() {$/;"	f
collect_all_symbols	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::collect_all_symbols(&this) {$/;"	f
collect_all_symbols_ns	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::collect_all_symbols_ns(&this, ns: &Namespace) {$/;"	f
collect_sym	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::collect_sym(&this, sym: &Symbol) {$/;"	f
colorpicker	$OCEN_ROOT/std/mui.oc	/^def Context::colorpicker(&this, label: str, color: &Color): Res {$/;"	f
compare	$OCEN_ROOT/std/complex.oc	/^def Complex::compare(this, other: Complex): i8 {$/;"	f
compare	$OCEN_ROOT/std/huffman.oc	/^def Node::compare(&this, other: &Node): i8 => .freq.compare(other.freq)$/;"	f
compare	$OCEN_ROOT/std/traits/compare.oc	/^def u8::compare(this, b: u8): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
compress	$OCEN_ROOT/std/huffman.oc	/^def compress(inp: &Buffer): Buffer {$/;"	f
compress	$OCEN_ROOT/std/zlib.oc	/^def compress(data: Buffer): Buffer {$/;"	f
compress_str	$OCEN_ROOT/std/zlib.oc	/^def compress_str(s: str): Buffer => compress(Buffer::from_str(s))$/;"	f
concat	$OCEN_ROOT/std/mod.oc	/^[extern "strcat"] def str::concat(this, src: str)$/;"	f
conj	$OCEN_ROOT/std/complex.oc	/^[extern "conjf"] def Complex::conj(this): Complex$/;"	f
connect	$OCEN_ROOT/std/socket.oc	/^def TcpStream::connect(host: str, port: i32, timeout_secs: i32 = -1): Result<&TcpStream, SocketS/;"	f
constrain_popup_to_screen	$OCEN_ROOT/std/mui.oc	/^def Context::constrain_popup_to_screen(&this) {$/;"	f
consume	$OCEN_ROOT/compiler/parser.oc	/^def Parser::consume(&this, type: TokenType): &Token {$/;"	f
consume	$OCEN_ROOT/std/json.oc	/^def Parser::consume(&this, type: TokenType): &Token {$/;"	f
consume_compound_operator	$OCEN_ROOT/compiler/parser.oc	/^def Parser::consume_compound_operator(&this, op: Operator): Span {$/;"	f
consume_end_of_statement	$OCEN_ROOT/compiler/parser.oc	/^def Parser::consume_end_of_statement(&this) {$/;"	f
consume_if	$OCEN_ROOT/compiler/parser.oc	/^def Parser::consume_if(&this, type: TokenType): bool {$/;"	f
consume_newline_or	$OCEN_ROOT/compiler/parser.oc	/^def Parser::consume_newline_or(&this, type: TokenType) {$/;"	f
consume_tokens_until_newline	$OCEN_ROOT/compiler/parser.oc	/^def Parser::consume_tokens_until_newline(&this) {$/;"	f
contains	$OCEN_ROOT/std/compact_map.oc	/^def Map::contains(&this, key: K): bool {$/;"	f
contains	$OCEN_ROOT/std/map.oc	/^def Map::contains(&this, key: K): bool {$/;"	f
contains	$OCEN_ROOT/std/og/mod.oc	/^def Rect::contains(this, pos: Vec2i): bool {$/;"	f
contains	$OCEN_ROOT/std/set.oc	/^def Set::contains(&this, key: T): bool => .map.contains(key)$/;"	f
contains	$OCEN_ROOT/std/sv.oc	/^def SV::contains(this, c: char): bool => .count(c) > 0$/;"	f
contains	$OCEN_ROOT/std/value.oc	/^def Value::contains(&this, key: str): bool {$/;"	f
contains_loc	$OCEN_ROOT/std/span.oc	/^def Span::contains_loc(this, loc: Location): bool {$/;"	f
copy	$OCEN_ROOT/std/buffer.oc	/^def Buffer::copy(&this): Buffer {$/;"	f
copy	$OCEN_ROOT/std/image/mod.oc	/^def Image::copy(&this): &Image {$/;"	f
copy	$OCEN_ROOT/std/mod.oc	/^[extern "strdup"] def str::copy(this): str$/;"	f
copy	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderCopy"]      def Renderer::copy(&this, texture: &Texture, src: &Rect, dst: &Re/;"	f
copy_and_display	$OCEN_ROOT/std/sdl/mod.oc	/^def Renderer::copy_and_display(&this, texture: &Texture, src: &Rect = null, dst: &Rect = null) {$/;"	f
copy_data_to_cstr	$OCEN_ROOT/std/sv.oc	/^def SV::copy_data_to_cstr(this): str {$/;"	f
copy_ex	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderCopyEx"]    def Renderer::copy_ex(&this, texture: &Texture, src: &Rect, dst: /;"	f
cos	$OCEN_ROOT/std/complex.oc	/^[extern "ccosf"] def Complex::cos(this): Complex$/;"	f
cos	$OCEN_ROOT/std/math.oc	/^[extern "cosf"] def f32::cos(this): f32$/;"	f
couldnt_find_stdlib	$OCEN_ROOT/compiler/parser.oc	/^def Parser::couldnt_find_stdlib(&this) {$/;"	f
count	$OCEN_ROOT/std/sv.oc	/^def SV::count(this, c: char): u64 {$/;"	f
create	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_create"] def Thread::create(&this, attr: &ThreadAttr, start_routine: CallBa/;"	f
create	$OCEN_ROOT/std/video_renderer/ffmpeg.oc	/^def FFMPEGContext::create(width: u32, height: u32, fps: u32, out_name: str, verbose: bool = fals/;"	f
create	$OCEN_ROOT/std/video_renderer/mod.oc	/^def VideoRenderer::create(type: VideoRendererType, width: u32, height: u32, fps: u32, out_name: /;"	f
create	$OCEN_ROOT/std/video_renderer/sdl.oc	/^def SDLContext::create(width: u32, height: u32, fps: u32): &SDLContext {$/;"	f
create_directory	$OCEN_ROOT/std/fs.oc	/^def create_directory(path: str, exists_ok: bool = false) {$/;"	f
create_match_for_error_prop	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::create_match_for_error_prop(&this, node: &AST, expr: &AST, error_prop_base: Err/;"	f
create_match_for_error_unwrap	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::create_match_for_error_unwrap(&this, node: &AST, expr: &AST, error_prop_base: E/;"	f
create_namespace_scopes	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::create_namespace_scopes(&this, ns: &Namespace, parent: &Namespace) {$/;"	f
create_namespaces_for_initial_file	$OCEN_ROOT/compiler/parser.oc	/^def Parser::create_namespaces_for_initial_file(&this, filename: str, single_file: bool) {$/;"	f
create_renderer	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_CreateRenderer"]           def Window::create_renderer(&this, index: i32, flags: i3/;"	f
create_system_cursor	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_CreateSystemCursor"] def create_system_cursor(cursor: CursorType): &Cursor$/;"	f
create_texture	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_CreateTexture"]   def Renderer::create_texture(&this, format: i32, access: i32, w: /;"	f
create_texture_from_surface	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_CreateTextureFromSurface"] def Renderer::create_texture_from_surface(&this, surface/;"	f
create_window	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_CreateWindow"]            def create_window(title: str, x: i32, y: i32, w: i32, h: /;"	f
create_window_renderer	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_CreateWindowAndRenderer"]  def create_window_renderer(width: i32, height: i32, flag/;"	f
cross	$OCEN_ROOT/std/vec.oc	/^def Vec3::cross(this, other: Vec3<T>): Vec3<T> {$/;"	f
ctx_name	$OCEN_ROOT/compiler/passes/code_generator.oc	/^    const ctx_name: str = "_C"$/;"	f
ctx_type	$OCEN_ROOT/compiler/passes/code_generator.oc	/^    def ctx_type(func: &Function): str => `{func.sym.out_name()}Ctx`$/;"	f
cur	$OCEN_ROOT/compiler/ast/program.oc	/^def NSIterator::cur(&this): &Namespace => .curr$/;"	f
cur	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::cur(&this): char => .source[.i]$/;"	f
cur	$OCEN_ROOT/std/bencode.oc	/^def Parser::cur(&this): char => .input.data[.loc.index] as char$/;"	f
cur	$OCEN_ROOT/std/bitio.oc	/^def BitReader::cur(&this): u8 => .data[.idx \/ 8] >> (.idx % 8) as u8 & 1$/;"	f
cur	$OCEN_ROOT/std/compact_map.oc	/^def ValueIterator::cur(&this): V => .iter.cur().value$/;"	f
cur	$OCEN_ROOT/std/fs.oc	/^def DirectoryIterator::cur(&this): DirectoryEntry {$/;"	f
cur	$OCEN_ROOT/std/linkedlist.oc	/^def Iterator::cur(&this): T => .node.value/;"	f
cur	$OCEN_ROOT/std/map.oc	/^def ValueIterator::cur(&this): V => .map_iter.cur().value$/;"	f
cur	$OCEN_ROOT/std/mod.oc	/^def CharIterator::cur(&this): char => .data[.pos]$/;"	f
cur	$OCEN_ROOT/std/set.oc	/^def Iterator::cur(&this): T => .map_iter.cur().key$/;"	f
cur	$OCEN_ROOT/std/sv.oc	/^def SVWordIterator::cur(&this): SV => .sv.chop_word()$/;"	f
cur	$OCEN_ROOT/std/vector.oc	/^def Iterator::cur(&this): T {$/;"	f
current_func	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::current_func(&this): &Function => .scope()?.cur_func$/;"	f
current_return_type	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::current_return_type(&this): &Type => .scope()?.cur_func?.return_type$/;"	f
dbg	$OCEN_ROOT/std/value.oc	/^def Value::dbg(&this): str {$/;"	f
dealloc	$OCEN_ROOT/std/bump_alloc.oc	/^def dealloc(_: mem::State, ptr: untyped_ptr) {}$/;"	f
decay_array	$OCEN_ROOT/compiler/types.oc	/^def Type::decay_array(&this): &Type {$/;"	f
decode	$OCEN_ROOT/std/image/png.oc	/^def decode(data: &Buffer): &Image {$/;"	f
decode	$OCEN_ROOT/std/image/ppm.oc	/^def decode(data: &Buffer): &Image {$/;"	f
decode	$OCEN_ROOT/std/image/qoi.oc	/^def decode(data: &Buffer): &Image {$/;"	f
decode_op_diff	$OCEN_ROOT/std/image/qoi.oc	/^def QOIDecoder::decode_op_diff(&this, first: u8) {$/;"	f
decode_op_index	$OCEN_ROOT/std/image/qoi.oc	/^def QOIDecoder::decode_op_index(&this, first: u8) {$/;"	f
decode_op_luma	$OCEN_ROOT/std/image/qoi.oc	/^def QOIDecoder::decode_op_luma(&this, first: u8) {$/;"	f
decode_op_rgb	$OCEN_ROOT/std/image/qoi.oc	/^def QOIDecoder::decode_op_rgb(&this) {$/;"	f
decode_op_rgba	$OCEN_ROOT/std/image/qoi.oc	/^def QOIDecoder::decode_op_rgba(&this) {$/;"	f
decode_op_run	$OCEN_ROOT/std/image/qoi.oc	/^def QOIDecoder::decode_op_run(&this, first: u8) {$/;"	f
decode_pixels	$OCEN_ROOT/std/image/qoi.oc	/^def QOIDecoder::decode_pixels(&this) {$/;"	f
decode_scanline	$OCEN_ROOT/std/image/png.oc	/^def PNG::decode_scanline(&this, out: &Buffer, scanline: u32, sv: SV) {$/;"	f
decompress	$OCEN_ROOT/std/huffman.oc	/^def decompress(inp: &Buffer): Buffer {$/;"	f
decompress	$OCEN_ROOT/std/zlib.oc	/^def decompress(data: Buffer, bytes_consumed: &u32 = null): Buffer {$/;"	f
decompress_bytes	$OCEN_ROOT/std/zlib.oc	/^def decompress_bytes(data: &u8, size: u32, bytes_consumed: &u32): Buffer {$/;"	f
default	$OCEN_ROOT/std/span.oc	/^def Span::default(): Span {$/;"	f
degrees	$OCEN_ROOT/std/math.oc	/^def degrees(radians: f32): f32 { return radians * 180.0 \/ PI; }$/;"	f
delay	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_Delay"]                   def delay(ms: i32)$/;"	f
deserialize_bits	$OCEN_ROOT/std/huffman.oc	/^def HuffmanTree::deserialize_bits(&this, bio: &BitReader): u16 {$/;"	f
destroy	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_FreeSurface"] def Surface::destroy(&this)$/;"	f
destroy	$OCEN_ROOT/std/thread.oc	/^def Mutex::destroy(&this) => check(.tx.destroy())$/;"	f
destroy_attr	$OCEN_ROOT/std/thread.oc	/^def Thread::destroy_attr(&this) => check(.tattr.destroy())$/;"	f
detach	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_detach"] def Thread::detach(this): i32$/;"	f
determinant	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::determinant(this): f32 {$/;"	f
dfs	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::dfs(&this, sym: &Symbol) {$/;"	f
dfs_type	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::dfs_type(&this, typ: &Type) {$/;"	f
directory_exists	$OCEN_ROOT/compiler/utils.oc	/^def directory_exists(path: str): bool {$/;"	f
directory_exists	$OCEN_ROOT/std/fs.oc	/^def directory_exists(path: str): bool {$/;"	f
dirent	$OCEN_ROOT/std/fs.oc	/^    [extern "struct dirent"] struct dirent {$/;"	f
dirname	$OCEN_ROOT/compiler/parser.oc	/^[extern] def dirname(path: str): str$/;"	f
display	$OCEN_ROOT/compiler/errors.oc	/^def Error::display(&this) {$/;"	f
display_error_messages	$OCEN_ROOT/compiler/errors.oc	/^def display_error_messages(errors: &Vector<&Error>, detail_level: u32) {$/;"	f
display_image	$OCEN_ROOT/std/og/mod.oc	/^def display_image(img: &Image) {$/;"	f
display_line	$OCEN_ROOT/compiler/errors.oc	/^def display_line() {$/;"	f
display_message	$OCEN_ROOT/compiler/errors.oc	/^def display_message(type: MessageType, span: Span, msg: str) {$/;"	f
display_message_span	$OCEN_ROOT/compiler/errors.oc	/^def display_message_span(type: MessageType, span: Span, msg: str, line_after: bool = true) {$/;"	f
display_span	$OCEN_ROOT/compiler/ast/nodes.oc	/^def AST::display_span(&this): Span => match .type {$/;"	f
div	$OCEN_ROOT/std/complex.oc	/^def Complex::div(this, other: Complex): Complex {$/;"	f
div	$OCEN_ROOT/std/vec.oc	/^[operator "\/"] def Vec3::div(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x \/ other.x, .y \/ oth/;"	f
divrs	$OCEN_ROOT/std/vec.oc	/^[operator "\/"] def Vec3::divrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val \/ this.x, val \//;"	f
divs	$OCEN_ROOT/std/vec.oc	/^[operator "\/"] def Vec3::divs(this, val: T): Vec3<T> => Vec3<T>(.x \/ val, .y \/ val, .z \/ val/;"	f
dot	$OCEN_ROOT/std/vec.oc	/^def Vec3::dot(this, other: Vec3<T>): T => .x * other.x + .y * other.y + .z * other.z$/;"	f
double	$OCEN_ROOT/std/prelude.h	/^typedef double f64;$/;"	f
drand48	$OCEN_ROOT/std/random.oc	/^[extern] def drand48(): f64/;"	f
draw	$OCEN_ROOT/std/mui_og/mod.oc	/^def draw(ctx: &mui::Context) {$/;"	f
draw	$OCEN_ROOT/std/ogui/mod.oc	/^def draw(ctx: &mui::Context) {$/;"	f
draw_atlas_quad	$OCEN_ROOT/std/mui_og/mod.oc	/^def draw_atlas_quad(image: &Image, dst: mui::Rect, src: mui::Rect, color: Color) {$/;"	f
draw_atlas_quad	$OCEN_ROOT/std/ogui/mod.oc	/^def draw_atlas_quad(image: &Image, dst: mui::Rect, src: mui::Rect, color: Color) {$/;"	f
draw_bezier	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "bezierColor"]        def std::sdl::Renderer::draw_bezier(&this, vx: &i16, vy: &i16, n: /;"	f
draw_box	$OCEN_ROOT/std/mui.oc	/^def Context::draw_box(&this, rect: Rect, color: Color) {$/;"	f
draw_buffer	$OCEN_ROOT/std/og/mod.oc	/^def draw_buffer() {$/;"	f
draw_circle_color	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "aacircleColor"]      def std::sdl::Renderer::draw_circle_color(&this, x: i32, y: i32, r/;"	f
draw_control_frame	$OCEN_ROOT/std/mui.oc	/^def Context::draw_control_frame(&this, id: u32, rect: Rect, colorid: ColorStyle, opt: Opt) {$/;"	f
draw_control_text	$OCEN_ROOT/std/mui.oc	/^def Context::draw_control_text(&this, str: str, rect: Rect, colorid: ColorStyle, opt: Opt) {$/;"	f
draw_frame	$OCEN_ROOT/std/mui.oc	/^def draw_frame(ctx: &Context, rect: Rect, colorid: ColorStyle) {$/;"	f
draw_icon	$OCEN_ROOT/std/mui.oc	/^def Context::draw_icon(&this, id: u32, rect: Rect, color: Color) {$/;"	f
draw_icon_to_image	$OCEN_ROOT/std/mui_og/mod.oc	/^def draw_icon_to_image(image: &Image, icon_id: u32, rect: mui::Rect, color: Color) {$/;"	f
draw_icon_to_image	$OCEN_ROOT/std/ogui/mod.oc	/^def draw_icon_to_image(image: &Image, icon_id: u32, rect: mui::Rect, color: Color) {$/;"	f
draw_image	$OCEN_ROOT/std/mui.oc	/^def Context::draw_image(&this, image: &Image, rect: Rect) {$/;"	f
draw_image_to_image	$OCEN_ROOT/std/mui_og/mod.oc	/^def draw_image_to_image(dst: &Image, src: &Image, rect: mui::Rect) {$/;"	f
draw_image_to_image	$OCEN_ROOT/std/ogui/mod.oc	/^def draw_image_to_image(dst: &Image, src: &Image, rect: mui::Rect) {$/;"	f
draw_line	$OCEN_ROOT/std/og/mod.oc	/^def draw_line(x1: i32, y1: i32, x2: i32, y2: i32, col: Color) {$/;"	f
draw_line	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderDrawLine"]  def Renderer::draw_line(&this, x1: i32, y1: i32, x2: i32, y2: i32/;"	f
draw_line_v	$OCEN_ROOT/std/og/mod.oc	/^def draw_line_v(p1: Vec2i, p2: Vec2i, col: Color) {$/;"	f
draw_pixel	$OCEN_ROOT/std/og/mod.oc	/^def draw_pixel(x: i32, y: i32, col: Color) {$/;"	f
draw_pixel_v	$OCEN_ROOT/std/og/mod.oc	/^def draw_pixel_v(pos: Vec2i, col: Color) {$/;"	f
draw_point	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderDrawPoint"] def Renderer::draw_point(&this, x: i32, y: i32)$/;"	f
draw_poly_color	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "polygonColor"]       def std::sdl::Renderer::draw_poly_color(&this, vx: &i16, vy: &i16,/;"	f
draw_rect	$OCEN_ROOT/std/mui.oc	/^def Context::draw_rect(&this, rect: Rect, color: Color) {$/;"	f
draw_rect	$OCEN_ROOT/std/og/mod.oc	/^def draw_rect(x: i32, y: i32, w: i32, h: i32, col: Color) {$/;"	f
draw_rect	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderDrawRect"]  def Renderer::draw_rect(&this, rect: &Rect)$/;"	f
draw_rect_to_image	$OCEN_ROOT/std/mui_og/mod.oc	/^def draw_rect_to_image(image: &Image, rect: mui::Rect, color: Color) {$/;"	f
draw_rect_to_image	$OCEN_ROOT/std/ogui/mod.oc	/^def draw_rect_to_image(image: &Image, rect: mui::Rect, color: Color) {$/;"	f
draw_rect_v	$OCEN_ROOT/std/og/mod.oc	/^def draw_rect_v(pos: Vec2i, size: Vec2i, col: Color) {$/;"	f
draw_text	$OCEN_ROOT/std/mui.oc	/^def Context::draw_text(&this, font: Font, text: str, len: i32, pos: Vec2i, color: Color) {$/;"	f
draw_text_to_image	$OCEN_ROOT/std/mui_og/mod.oc	/^def draw_text_to_image(image: &Image, pos: Vec2i, color: Color, clip: Rect, text: str, len: u32)/;"	f
draw_text_to_image	$OCEN_ROOT/std/ogui/mod.oc	/^def draw_text_to_image(image: &Image, pos: Vec2i, color: Color, clip: Rect, text: str, len: u32)/;"	f
draw_tri_color	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "trigonColor"]        def std::sdl::Renderer::draw_tri_color(&this, x1: i32, y1: i32, x2/;"	f
dump	$OCEN_ROOT/compiler/ast/program.oc	/^def Namespace::dump(&this) {$/;"	f
dump_backtrace	$OCEN_ROOT/std/mod.oc	/^[extern] def dump_backtrace()$/;"	f
dup2	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def dup2(a: i32, b: i32): i32$/;"	f
easy_cleanup	$OCEN_ROOT/std/curl.oc	/^[extern "curl_easy_cleanup"] def Context::easy_cleanup(&this)$/;"	f
easy_init	$OCEN_ROOT/std/curl.oc	/^[extern "curl_easy_init"] def Context::easy_init(): &Context$/;"	f
easy_perform	$OCEN_ROOT/std/curl.oc	/^[extern "curl_easy_perform"] def Context::easy_perform(&this): Status$/;"	f
easy_setopt	$OCEN_ROOT/std/curl.oc	/^def Context::easy_setopt($/;"	f
edit_distance	$OCEN_ROOT/compiler/utils.oc	/^def edit_distance(str1: str, str2: str): u32 {$/;"	f
encode	$OCEN_ROOT/std/image/png.oc	/^def encode(img: &Image, data: &Buffer) {$/;"	f
encode	$OCEN_ROOT/std/image/ppm.oc	/^def encode(img: &Image, data: &Buffer) {$/;"	f
encode	$OCEN_ROOT/std/image/qoi.oc	/^def encode(img: &Image, data: &Buffer) {$/;"	f
encode_end	$OCEN_ROOT/std/image/qoi.oc	/^def QOIEncoder::encode_end(&this) {$/;"	f
encode_header	$OCEN_ROOT/std/image/qoi.oc	/^def QOIEncoder::encode_header(&this) {$/;"	f
encode_pixel	$OCEN_ROOT/std/image/qoi.oc	/^def QOIEncoder::encode_pixel(&this, pix: RGBA) {$/;"	f
encode_pixels	$OCEN_ROOT/std/image/qoi.oc	/^def QOIEncoder::encode_pixels(&this) {$/;"	f
end	$OCEN_ROOT/std/mui.oc	/^def Context::end(&this) {$/;"	f
end	$OCEN_ROOT/std/variadic.oc	/^[extern "va_end"] def VarArgs::end(this)$/;"	f
end	$OCEN_ROOT/std/zlib.oc	/^    [extern "inflateEnd"] def Stream::end(&this): i32$/;"	f
end_panel	$OCEN_ROOT/std/mui.oc	/^def Context::end_panel(&this) {$/;"	f
end_popup	$OCEN_ROOT/std/mui.oc	/^def Context::end_popup(&this) {$/;"	f
end_root_container	$OCEN_ROOT/std/mui.oc	/^def Context::end_root_container(&this) {$/;"	f
end_treenode	$OCEN_ROOT/std/mui.oc	/^def Context::end_treenode(&this) {$/;"	f
end_window	$OCEN_ROOT/std/mui.oc	/^def Context::end_window(&this) {$/;"	f
ends_with	$OCEN_ROOT/std/mod.oc	/^def str::ends_with(this, suffix: str): bool {$/;"	f
ends_with_str	$OCEN_ROOT/std/sv.oc	/^def SV::ends_with_str(this, other: str): bool => .ends_with_sv(SV::from_str(other))$/;"	f
ends_with_sv	$OCEN_ROOT/std/sv.oc	/^def SV::ends_with_sv(this, other: SV): bool {$/;"	f
ensure	$OCEN_ROOT/std/value.oc	/^def Value::ensure(&this, type: ValueType) {$/;"	f
enum	$OCEN_ROOT/compiler/passes/code_generator.oc	/^        .out <<= f"typedef enum {name}__kind {name}__kind;\\n"$/;"	f
ep0	$OCEN_ROOT/std/hash/sha256.oc	/^    def ep0(x: u32): u32 => rotate_right(x, 2) ^ rotate_right(x, 13) ^ rotate_right(x, 22)$/;"	f
ep1	$OCEN_ROOT/std/hash/sha256.oc	/^    def ep1(x: u32): u32 => rotate_right(x, 6) ^ rotate_right(x, 11) ^ rotate_right(x, 25)$/;"	f
eq	$OCEN_ROOT/compiler/ast/operators.oc	/^def OperatorOverload::eq(this, other: OperatorOverload): bool {$/;"	f
eq	$OCEN_ROOT/compiler/attributes.oc	/^def AttributeType::eq(this, other: AttributeType): bool => this == other$/;"	f
eq	$OCEN_ROOT/compiler/types.oc	/^def Type::eq(&this, other: &Type, strict: bool = false): bool {$/;"	f
eq	$OCEN_ROOT/std/complex.oc	/^def Complex::eq(this, other: Complex): bool {$/;"	f
eq	$OCEN_ROOT/std/hash/sha1.oc	/^def SHA1Hash::eq(this, other: SHA1Hash): bool => memcmp(.data, other.data, 20) == 0$/;"	f
eq	$OCEN_ROOT/std/hash/sha256.oc	/^def SHA256Hash::eq(this, other: SHA256Hash): bool => memcmp(.data, other.data, 32) == 0/;"	f
eq	$OCEN_ROOT/std/image/qoi.oc	/^def RGBA::eq(this, other: RGBA): bool {$/;"	f
eq	$OCEN_ROOT/std/mod.oc	/^def str::eq(this, other: str): bool {$/;"	f
eq	$OCEN_ROOT/std/sdl/mod.oc	/^def Key::eq(this, other: Key): bool => this == other$/;"	f
eq	$OCEN_ROOT/std/span.oc	/^def Span::eq(this, other: Span): bool => .start.eq(other.start) and .end.eq(other.end)$/;"	f
eq	$OCEN_ROOT/std/sv.oc	/^[operator "=="] def SV::eq(this, other: SV): bool => .len == other.len and memcmp(.data, other.d/;"	f
eq	$OCEN_ROOT/std/traits/eq.oc	/^def untyped_ptr::eq(this, other: untyped_ptr): bool => this == other/;"	f
eq	$OCEN_ROOT/std/vec.oc	/^def Vec3::eq(this, other: Vec3<T>): bool => .x == other.x and .y == other.y and .z == other.z$/;"	f
eq_bool	$OCEN_ROOT/std/value.oc	/^def Value::eq_bool(&this, other: bool): bool {$/;"	f
eq_i64	$OCEN_ROOT/std/value.oc	/^def Value::eq_i64(&this, other: i64): bool {$/;"	f
eq_str	$OCEN_ROOT/std/sv.oc	/^[operator "=="] def SV::eq_str(this, other: str): bool => .eq(SV::from_str(other))$/;"	f
eq_str	$OCEN_ROOT/std/value.oc	/^def Value::eq_str(&this, other: str): bool {$/;"	f
eq_u32	$OCEN_ROOT/std/value.oc	/^def Value::eq_u32(&this, other: u32): bool {$/;"	f
errno	$OCEN_ROOT/std/libc/errno.oc	/^[extern] const errno: i32$/;"	f
error	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::error(&this, err: &Error): &Error {$/;"	f
error	$OCEN_ROOT/compiler/parser.oc	/^def Parser::error(&this, err: &Error): &Error {$/;"	f
error	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::error(&this, err: &Error): &Error => .o.error(err)$/;"	f
error	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::error(&this, err: &Error): &Error {$/;"	f
error	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::error(&this, err: &Error): &Error => .o.error(err)$/;"	f
error_msg	$OCEN_ROOT/compiler/parser.oc	/^def Parser::error_msg(&this, msg: str): &Error {$/;"	f
execvp	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def execvp(a: str, b: &str): i32$/;"	f
exit	$OCEN_ROOT/std/libc/mod.oc	/^[extern] [exits] def exit(code: i32)$/;"	f
exit	$OCEN_ROOT/std/mod.oc	/^[extern] [exits] def exit(code: i32 = 0)$/;"	f
exit	$OCEN_ROOT/std/thread.oc	/^[extern "pthread_exit"]  def exit(retval: untyped_ptr)$/;"	f
exit_with_errors_if_any	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::exit_with_errors_if_any(&this) {$/;"	f
exp	$OCEN_ROOT/std/complex.oc	/^[extern "cexpf"] def Complex::exp(this): Complex$/;"	f
exp	$OCEN_ROOT/std/math.oc	/^[extern "exp"] def f32::exp(this): f32$/;"	f
expand	$OCEN_ROOT/std/mui.oc	/^def Rect::expand(this, n: i32): Rect => Rect(.x - n, .y - n, .width + n * 2, .height + n * 2)$/;"	f
extend	$OCEN_ROOT/std/compact_map.oc	/^def Map::extend(&this, other: &Map<K, V>) {$/;"	f
extend	$OCEN_ROOT/std/map.oc	/^def Map::extend(&this, other: &Map<K, V>) {$/;"	f
extend	$OCEN_ROOT/std/set.oc	/^def Set::extend(&this, other: &Set<T>) {$/;"	f
extend	$OCEN_ROOT/std/vector.oc	/^def Vector::extend(&this, other: &Vector<T>) {$/;"	f
f32	$OCEN_ROOT/std/math.oc	/^def f32::min(this, b: f32): f32 => if this < b then this else b$/;"	f
f32	$OCEN_ROOT/std/traits/compare.oc	/^def f32::compare(this, b: f32): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
f32	$OCEN_ROOT/std/traits/eq.oc	/^def f32::eq(this, other: f32): bool => this == other$/;"	f
f32	$OCEN_ROOT/std/traits/hash.oc	/^def f32::hash(this): u32 => this as u32 * 7817$/;"	f
f64	$OCEN_ROOT/std/math.oc	/^def f64::min(this, b: f64): f64 => if this < b then this else b$/;"	f
f64	$OCEN_ROOT/std/traits/compare.oc	/^def f64::compare(this, b: f64): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
f64	$OCEN_ROOT/std/traits/eq.oc	/^def f64::eq(this, other: f64): bool => this == other$/;"	f
f64	$OCEN_ROOT/std/traits/hash.oc	/^def f64::hash(this): u32 => (this as u64).hash()$/;"	f
fclose	$OCEN_ROOT/std/fs.oc	/^    [extern] def fclose(file: &File): i32$/;"	f
fcntl	$OCEN_ROOT/std/fcntl.oc	/^[extern "fcntl"] def fcntl(fd: i32, cmd: i32, arg: i32): i32$/;"	f
fft	$OCEN_ROOT/std/fft.oc	/^def fft(data: &Complex, N: u32, out: &Complex) {$/;"	f
fft2	$OCEN_ROOT/std/fft.oc	/^def fft2(inp: &Complex, R: u32, C: u32, out: &Complex) {$/;"	f
fft2_impl	$OCEN_ROOT/std/fft.oc	/^def fft2_impl(inp: &Complex, R: u32, C: u32, out: &Complex, inv: bool) {$/;"	f
fft_impl	$OCEN_ROOT/std/fft.oc	/^def fft_impl(data: &Complex, N: u32, out: &Complex, step: u32, factor: f32) {$/;"	f
fgets	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^[extern] def fgets(buf: str, size: u32, file: &fs::File): str$/;"	f
field	$OCEN_ROOT/compiler/parser.oc	/^        .error(Error::new(.token().span, "Expected ':' after struct field names for type"))$/;"	f
file_exists	$OCEN_ROOT/std/fs.oc	/^def file_exists(path: str): bool {$/;"	f
file_info	$OCEN_ROOT/std/fs.oc	/^def file_info(path: str): FileMetadata {$/;"	f
fileno	$OCEN_ROOT/std/fs.oc	/^    [extern] def fileno(file: &File): i32$/;"	f
fill_circle_color	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "filledCircleColor"]  def std::sdl::Renderer::fill_circle_color(&this, x: i32, y: i32, r/;"	f
fill_poly_color	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "filledPolygonColor"] def std::sdl::Renderer::fill_poly_color(&this, vx: &i16, vy: &i16,/;"	f
fill_rect	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderFillRect"]  def Renderer::fill_rect(&this, rect: &Rect)$/;"	f
fill_tri_color	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "filledTrigonColor"]  def std::sdl::Renderer::fill_tri_color(&this, x1: i32, y1: i32, x2/;"	f
final	$OCEN_ROOT/std/hash/sha256.oc	/^def Context::final(&this, hash: &u8) {$/;"	f
find	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find(&this, program: &Program): bool {$/;"	f
find	$OCEN_ROOT/std/disjoint_set.oc	/^def DisjointSet::find(&this, x: T): T {$/;"	f
find	$OCEN_ROOT/std/vector.oc	/^def Vector::find(&this, cb: @fn(T): bool): i32 {$/;"	f
find_and_replace_overloaded_op	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::find_and_replace_overloaded_op(&this, op: Operator, node: &AST, arg1: &AST, arg/;"	f
find_arg	$OCEN_ROOT/std/argparse.oc	/^def find_arg(parser: &Parser, _flag: str, positional_idx: &i32): &Arg {$/;"	f
find_closure_type	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::find_closure_type(&this, params: &Vector<&Variable>, ret: &Type): &Type {$/;"	f
find_external_library	$OCEN_ROOT/compiler/parser.oc	/^def Parser::find_external_library(&this, name: str): LibraryInfo {$/;"	f
find_importable_symbol	$OCEN_ROOT/compiler/ast/program.oc	/^def Namespace::find_importable_symbol(&this, name: str): &Symbol {$/;"	f
find_in_block	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_block(&this, node: &AST): bool {$/;"	f
find_in_call_args	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_call_args(&this, node: &AST, args: &Vector<&Argument>): bool {$/;"	f
find_in_function	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_function(&this, func: &Function): bool {$/;"	f
find_in_identifier	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_identifier(&this, node: &AST): bool {$/;"	f
find_in_import_part	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_import_part(&this, base: &Symbol, part: &ImportPart, node: &AST): bool => ma/;"	f
find_in_literal	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_literal(&this, node: &AST): bool {$/;"	f
find_in_match_conds	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_match_conds(&this, conds: &Vector<&MatchCond>): bool {$/;"	f
find_in_node	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_node(&this, node: &AST): bool {$/;"	f
find_in_program	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_program(&this, ns: &Namespace): bool {$/;"	f
find_in_symbol	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::find_in_symbol(&this, sym: &Symbol, name: str, allow_templated: bool = false): /;"	f
find_in_symbol_or_error	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::find_in_symbol_or_error(&this, sym: &Symbol, name: str, span: Span, error: bool/;"	f
find_in_type	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_type(&this, type: &Type): bool {$/;"	f
find_in_var	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_in_var(&this, var: &Variable, node: &AST): bool {$/;"	f
find_main_function	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::find_main_function(&this, program: &Program): &Function {$/;"	f
find_or_import_stdlib	$OCEN_ROOT/compiler/parser.oc	/^def Parser::find_or_import_stdlib(&this): &Namespace {$/;"	f
find_signature_help	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::find_signature_help(&this, node: &AST, args: &Vector<&Argument>, param_idx: u32): bo/;"	f
find_str	$OCEN_ROOT/std/sv.oc	/^def SV::find_str(&this, s: str): i32 {$/;"	f
find_template_instance	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::find_template_instance(&this, template_instances: &Vector<&TemplateInstance>, a/;"	f
find_word_suggestion	$OCEN_ROOT/compiler/utils.oc	/^def find_word_suggestion(s: str, options: &Vector<str>): str {$/;"	f
finish	$OCEN_ROOT/std/bitio.oc	/^def BitWriter::finish(&this) {$/;"	f
finish	$OCEN_ROOT/std/video_renderer/ffmpeg.oc	/^def FFMPEGContext::finish(&this): bool {$/;"	f
finish	$OCEN_ROOT/std/video_renderer/mod.oc	/^def VideoRenderer::finish(&this) {$/;"	f
finish	$OCEN_ROOT/std/video_renderer/sdl.oc	/^def SDLContext::finish(&this) {$/;"	f
float	$OCEN_ROOT/std/prelude.h	/^typedef float f32;$/;"	f
floor	$OCEN_ROOT/std/math.oc	/^[extern "floorf"] def f32::floor(this): f32$/;"	f
flush	$OCEN_ROOT/std/fs.oc	/^[extern "fflush"] def File::flush(&this)$/;"	f
flush_stdio	$OCEN_ROOT/std/fs.oc	/^def flush_stdio() {$/;"	f
fn_field_name	$OCEN_ROOT/compiler/passes/code_generator.oc	/^    const fn_field_name: str = "fn"$/;"	f
fopen	$OCEN_ROOT/std/fs.oc	/^    [extern] def fopen(path: str, mode: str = "r"): &File$/;"	f
for	$OCEN_ROOT/compiler/passes/typechecker.oc	/^                    "Cannot use a typedef for a type when defining any of it's members.\\nUse fu/;"	f
for_each_command	$OCEN_ROOT/std/mui.oc	/^def Context::for_each_command(&this, callback: @fn(&Command)) {$/;"	f
for_rotate_axis	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::for_rotate_axis(axis: Vec3f, angle: f32): Matrix4f {$/;"	f
for_rotate_x	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::for_rotate_x(a: f32): Matrix4f => Matrix4f::make($/;"	f
for_rotate_y	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::for_rotate_y(a: f32): Matrix4f => Matrix4f::make($/;"	f
for_rotate_z	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::for_rotate_z(a: f32): Matrix4f => Matrix4f::make($/;"	f
for_scale	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::for_scale(v: Vec3f): Matrix4f => Matrix4f::make($/;"	f
for_translate	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::for_translate(v: Vec3f): Matrix4f => Matrix4f::make($/;"	f
fork	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def fork(): i32$/;"	f
format	$OCEN_ROOT/std/mod.oc	/^def format(fmt: str, ...): str {$/;"	f
format_string_custom_argument	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::format_string_custom_argument(&this, type: &Type, expr: &AST) {$/;"	f
format_string_custom_specifier	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::format_string_custom_specifier(&this, type: &Type, expr: &AST) {$/;"	f
format_usage	$OCEN_ROOT/compiler/main.oc	/^def format_usage(code: i32) {$/;"	f
fread	$OCEN_ROOT/std/fs.oc	/^    [extern] def fread(ptr: untyped_ptr, size: u32, nmemb: u32, file: &File): i32$/;"	f
free	$OCEN_ROOT/compiler/attributes.oc	/^def Attribute::free(&this) {$/;"	f
free	$OCEN_ROOT/compiler/parser.oc	/^def Parser::free(&this) {$/;"	f
free	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::free(&this) {$/;"	f
free	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::free(&this) {$/;"	f
free	$OCEN_ROOT/std/buffer.oc	/^def Buffer::free(&this) {$/;"	f
free	$OCEN_ROOT/std/compact_map.oc	/^def Map::free(&this) {$/;"	f
free	$OCEN_ROOT/std/deque.oc	/^def Deque::free(&this) {$/;"	f
free	$OCEN_ROOT/std/heap.oc	/^def Heap::free(&this) {$/;"	f
free	$OCEN_ROOT/std/huffman.oc	/^def HuffmanTree::free(&this) {$/;"	f
free	$OCEN_ROOT/std/image/mod.oc	/^def Image::free(&this) {$/;"	f
free	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def free(ptr: untyped_ptr)$/;"	f
free	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::free(&this) {$/;"	f
free	$OCEN_ROOT/std/map.oc	/^def Map::free(&this) {$/;"	f
free	$OCEN_ROOT/std/mem.oc	/^def free(ptr: untyped_ptr) {$/;"	f
free	$OCEN_ROOT/std/midi.oc	/^def Track::free(&this) {$/;"	f
free	$OCEN_ROOT/std/mod.oc	/^def str::free(&this) {$/;"	f
free	$OCEN_ROOT/std/set.oc	/^def Set::free(&this) {$/;"	f
free	$OCEN_ROOT/std/socket.oc	/^def RecvFromResult::free(&this) {$/;"	f
free	$OCEN_ROOT/std/value.oc	/^def Value::free(&this) {$/;"	f
free	$OCEN_ROOT/std/vector.oc	/^def Vector::free(&this) {$/;"	f
free_all	$OCEN_ROOT/std/curl.oc	/^[extern "curl_slist_free_all"] def SList::free_all(&this)$/;"	f
free_chunk	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_FreeChunk"] def free_chunk(chunk: &Sound)$/;"	f
free_list	$OCEN_ROOT/std/map.oc	/^def Item::free_list(&this) {$/;"	f
from	$OCEN_ROOT/compiler/passes/code_generator.oc	/^        lhs_type.base != Enum => .error(Error::new(is_expr.lhs.span, "Codegen error, expected en/;"	f
from	$OCEN_ROOT/std/hash/sha1.oc	/^def SHA1Hash::from(data: Buffer): SHA1Hash {$/;"	f
from	$OCEN_ROOT/std/hash/sha256.oc	/^def SHA256Hash::from(data: Buffer): SHA256Hash {$/;"	f
from_buf	$OCEN_ROOT/std/sv.oc	/^def SV::from_buf(buf: Buffer): SV => SV(buf.data as str, buf.size)$/;"	f
from_data	$OCEN_ROOT/std/bitio.oc	/^def BitReader::from_data(data: &u8, num_bits: u32): BitReader {$/;"	f
from_error	$OCEN_ROOT/std/process.oc	/^def Output::from_error(error_code: i32): Output {$/;"	f
from_ident	$OCEN_ROOT/compiler/tokens.oc	/^def Token::from_ident(text: str, span: Span): &Token {$/;"	f
from_local_variable	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::from_local_variable(name: str, var: &Variable, span: Span): &Symbol {$/;"	f
from_operator_overload	$OCEN_ROOT/compiler/ast/operators.oc	/^def Operator::from_operator_overload(s: str, params: $[&Variable]): Operator => match s {$/;"	f
from_option	$OCEN_ROOT/std/result.oc	/^def Result::from_option(opt: Option<T>, err: E): Result<T, E> => match opt {$/;"	f
from_serialized_bits	$OCEN_ROOT/std/huffman.oc	/^def HuffmanTree::from_serialized_bits(bio: &BitReader): &HuffmanTree {$/;"	f
from_sized_str	$OCEN_ROOT/std/buffer.oc	/^def Buffer::from_sized_str(s: str, size: u32): Buffer {$/;"	f
from_str	$OCEN_ROOT/compiler/attributes.oc	/^def AttributeType::from_str(s: str): AttributeType => match s {$/;"	f
from_str	$OCEN_ROOT/std/buffer.oc	/^def Buffer::from_str(s: str): Buffer {$/;"	f
from_str	$OCEN_ROOT/std/sv.oc	/^def SV::from_str(s: str): SV => SV(s, s.len())$/;"	f
from_sv	$OCEN_ROOT/std/bitio.oc	/^def BitReader::from_sv(sv: SV, num_bits: u32 = 0): BitReader {$/;"	f
from_sv	$OCEN_ROOT/std/buffer.oc	/^def Buffer::from_sv(sv: SV): Buffer {$/;"	f
from_text	$OCEN_ROOT/compiler/tokens.oc	/^def TokenType::from_text(text: str): TokenType => match text {$/;"	f
from_text	$OCEN_ROOT/std/huffman.oc	/^def HuffmanTree::from_text(inp: SV): &HuffmanTree {$/;"	f
from_token	$OCEN_ROOT/compiler/ast/operators.oc	/^def Operator::from_token(tok: &Token): Operator => match tok.type {$/;"	f
from_type	$OCEN_ROOT/compiler/tokens.oc	/^def Token::from_type(type: TokenType, span: Span): &Token => Token::new(type, span, "")$/;"	f
from_v	$OCEN_ROOT/std/og/mod.oc	/^def Rect::from_v(pos: Vec2i, size: Vec2i): Rect {$/;"	f
from_vec	$OCEN_ROOT/std/heap.oc	/^def Heap::from_vec(mode: Mode, data: &Vector<T>): &Heap<T> {$/;"	f
front	$OCEN_ROOT/std/deque.oc	/^def Deque::front(&this): T {$/;"	f
fseek	$OCEN_ROOT/std/fs.oc	/^    [extern] def fseek(file: &File, offset: i64, mode: SeekMode): i32$/;"	f
ftell	$OCEN_ROOT/std/fs.oc	/^    [extern] def ftell(file: &File): i64$/;"	f
ftruncate	$OCEN_ROOT/std/fs.oc	/^    [extern] def ftruncate(fd: i32, size: i64): i32$/;"	f
fwrite	$OCEN_ROOT/std/fs.oc	/^    [extern] def fwrite(ptr: untyped_ptr, size: u32, nmemb: u32, file: &File): i32$/;"	f
gen_block	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_block(&this, node: &AST, with_braces: bool = true) {$/;"	f
gen_builtin	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_builtin(&this, type: &Type): &Value {$/;"	f
gen_builtins	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_builtins(&this, program: &Program): &Value {$/;"	f
gen_call	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_call(&this, node: &AST, is_expr: bool) {$/;"	f
gen_call_args	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_call_args(&this, args: &Vector<&Argument>, is_variadic_format: bool) {$/;"	f
gen_closure_call	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_closure_call(&this, node: &AST, sym: &Symbol) {$/;"	f
gen_closure_def	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_closure_def(&this, clos: &Function) {$/;"	f
gen_closure_func	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_closure_func(&this, clos: &Function) {$/;"	f
gen_closure_func_decl	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_closure_func_decl(&this, clos: &Function) {$/;"	f
gen_closure_type_def	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_closure_type_def(&this, sym: &Symbol) {$/;"	f
gen_closure_type_typedef	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_closure_type_typedef(&this, sym: &Symbol) {$/;"	f
gen_closure_typedef	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_closure_typedef(&this, clos: &Function) {$/;"	f
gen_completion_items_from_ns	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_completion_items_from_ns(completions: &Value, ns: &Namespace, seen: &Set<str>) {$/;"	f
gen_completions_from_scope	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_completions_from_scope(scope: &Scope, completions: &Value, hint_type: &Type, seen: &Set</;"	f
gen_completions_from_symbol	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_completions_from_symbol(sym: &Symbol, node: &AST, completions: &Value, seen: &Set<str>) /;"	f
gen_constant	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_constant(&this, node: &AST) {$/;"	f
gen_constants	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_constants(&this, ns: &Namespace) {$/;"	f
gen_constructor	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_constructor(&this, node: &AST, struc: &Structure) {$/;"	f
gen_control_body	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_control_body(&this, node: &AST, body: &AST) {$/;"	f
gen_create_new	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_create_new(&this, node: &AST) {$/;"	f
gen_custom_match	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_custom_match(&this, node: &AST) {$/;"	f
gen_debug_info	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_debug_info(&this, span: Span, force: bool = false) {$/;"	f
gen_defers_upto	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_defers_upto(&this, end_scope: &Scope) {$/;"	f
gen_end_expr_statement	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_end_expr_statement(&this) =>   .out += "})"$/;"	f
gen_enum	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_enum(&this, enom: &Enum): &Value {$/;"	f
gen_enum_constructor	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_enum_constructor(&this, variant: &EnumVariant, args: &Vector<&Argument> =/;"	f
gen_enum_dbg_method	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_enum_dbg_method(&this, enom: &Enum) {$/;"	f
gen_enum_def	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_enum_def(&this, enom: &Enum) {$/;"	f
gen_enum_typedef	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_enum_typedef(&this, enom: &Enum) {$/;"	f
gen_expression	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_expression(&this, node: &AST, is_top_level: bool = false, is_statement: b/;"	f
gen_format_string	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_format_string(&this, node: &AST) {$/;"	f
gen_format_string_part	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_format_string_part(&this, part: str) {$/;"	f
gen_format_string_variadic	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_format_string_variadic(&this, node: &AST, newline_after: bool) {$/;"	f
gen_func_param_string	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_func_param_string(i: u32, param: &Variable, is_non_static_method: bool = false): str {$/;"	f
gen_function	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_function(&this, func: &Function): &Value {$/;"	f
gen_function	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_function(&this, func: &Function) {$/;"	f
gen_function_body	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_function_body(&this, func: &Function) {$/;"	f
gen_function_decl	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_function_decl(&this, func: &Function) {$/;"	f
gen_function_decl_toplevel	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_function_decl_toplevel(&this, func: &Function) {$/;"	f
gen_function_decls	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_function_decls(&this, ns: &Namespace) {$/;"	f
gen_functions	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_functions(&this, ns: &Namespace) {$/;"	f
gen_global_variables	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_global_variables(&this, ns: &Namespace) {$/;"	f
gen_hover_string	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_hover_string(sym: &Symbol): str => match sym.type {$/;"	f
gen_hover_string_with_docs	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_hover_string_with_docs(sym: &Symbol): &Value {$/;"	f
gen_if	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_if(&this, node: &AST) {$/;"	f
gen_if_is_expr_body	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_if_is_expr_body($/;"	f
gen_if_is_expr_branch	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_if_is_expr_branch($/;"	f
gen_if_is_expr_cond	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_if_is_expr_cond(&this, var_name: str, conds: &Vector<&MatchCond>) {$/;"	f
gen_in_yield_context	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_in_yield_context(&this, node: &AST) {$/;"	f
gen_indent	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_indent(&this) {$/;"	f
gen_inlay_hint	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_inlay_hint(var: &Variable, path: str): &Value {$/;"	f
gen_internal_print	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_internal_print(&this, node: &AST, newline_after: bool, is_stderr: bool): /;"	f
gen_location	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_location(&this, obj: &Value, span: Span) {$/;"	f
gen_map_literal	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_map_literal(&this, node: &AST) {$/;"	f
gen_match	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_match(&this, node: &AST) {$/;"	f
gen_match_bool	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_match_bool(&this, node: &AST) {$/;"	f
gen_match_case_body	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_match_case_body(&this, node: &AST, body: &AST) {$/;"	f
gen_match_enum	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_match_enum(&this, node: &AST) {$/;"	f
gen_match_enum_cases_body	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_match_enum_cases_body($/;"	f
gen_match_enum_switch_line	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_match_enum_switch_line(&this, expr: &AST): str {$/;"	f
gen_methods	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_methods(&this, type: &Type): &Value {$/;"	f
gen_ns	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_ns(&this, ns: &Namespace): &Value {$/;"	f
gen_signature_help	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_signature_help(node: &AST, active_param: u32): &Value {$/;"	f
gen_span_json_with_filename	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_span_json_with_filename(span: Span, search_loc: Location): &Value {$/;"	f
gen_start_expr_statement	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_start_expr_statement(&this) => .out += "({"$/;"	f
gen_statement	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_statement(&this, node: &AST) {$/;"	f
gen_string_literal	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_string_literal(&this, literal: str) {$/;"	f
gen_struct	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_struct(&this, struc: &Structure): &Value {$/;"	f
gen_struct_def	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_struct_def(&this, struc: &Structure) {$/;"	f
gen_struct_typedef	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_struct_typedef(&this, struc: &Structure) {$/;"	f
gen_sym_def	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_sym_def(&this, sym: &Symbol) => match sym.type {$/;"	f
gen_sym_typedef	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_sym_typedef(&this, sym: &Symbol) => match sym.type {$/;"	f
gen_template_params	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_template_params(args: &Vector<&Type>): str {$/;"	f
gen_templated_type	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_templated_type(&this, base: &Type, args: &Vector<&Type>): str {$/;"	f
gen_test_mode_main	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_test_mode_main(&this) {$/;"	f
gen_type	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_type(&this, type: &Type) {$/;"	f
gen_type_and_name	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_type_and_name(&this, type: &Type, name: str) {$/;"	f
gen_type_methods_into	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_type_methods_into(obj: &Value, type: &Type) {$/;"	f
gen_type_string	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def gen_type_string(type: &Type, full: bool = true): str => match type.base {$/;"	f
gen_typename	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_typename(&this, type: &Type): &Value {$/;"	f
gen_typename_str	$OCEN_ROOT/compiler/docgen.oc	/^def DocGenerator::gen_typename_str(&this, type: &Type): str {$/;"	f
gen_var_declaration	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_var_declaration(&this, node: &AST) {$/;"	f
gen_vector_literal	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_vector_literal(&this, node: &AST) {$/;"	f
gen_yield_expression	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::gen_yield_expression(&this, expr: &AST) {$/;"	f
generate	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::generate(&this): str {$/;"	f
get	$OCEN_ROOT/compiler/passes/register_types.oc	/^def Finder::get(this, name: str): Finder => .to(name, error: true)$/;"	f
get	$OCEN_ROOT/std/compact_map.oc	/^def Map::get(&this, key: K, defolt: V): V {$/;"	f
get	$OCEN_ROOT/std/huffman.oc	/^def CharCode::get(&this, idx: u32): u8 {$/;"	f
get	$OCEN_ROOT/std/image/mod.oc	/^def Image::get(&this, x: u32, y: u32): Color => .data[y * .width + x]$/;"	f
get	$OCEN_ROOT/std/map.oc	/^def Map::get(&this, key: K, defolt: V): V {$/;"	f
get	$OCEN_ROOT/std/mui.oc	/^def Style::get(this, colorid: ColorStyle): Color => .colors[colorid as i32]$/;"	f
get	$OCEN_ROOT/std/og/state.oc	/^def KeyState::get(&this, k: sdl::Key): bool => .keys[k as u32]$/;"	f
get	$OCEN_ROOT/std/readline.oc	/^[extern "readline"] def get(prompt: str): str$/;"	f
get	$OCEN_ROOT/std/sv.oc	/^def SV::get(this, n: u32): SV => SV(this.data, n)$/;"	f
get	$OCEN_ROOT/std/value.oc	/^def Value::get(&this, key: str, defolt: &Value = null): &Value {$/;"	f
get_atlas_rect	$OCEN_ROOT/std/ogui/atlas.oc	/^def get_atlas_rect(idx: i32): Rect {$/;"	f
get_attr_type	$OCEN_ROOT/std/thread.oc	/^def Mutex::get_attr_type(&this): MutexMode => .mode$/;"	f
get_avg_frametime	$OCEN_ROOT/std/og/state.oc	/^def get_avg_frametime(): f32 => frametime_total \/ FRAMETIMES_COUNT as f32$/;"	f
get_base_type	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::get_base_type(&this, base: BaseType, span: Span): &Type {$/;"	f
get_base_type	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::get_base_type(&this, base: BaseType, span: Span): &Type => .o.program.get_base_/;"	f
get_break_label_for_loop	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::get_break_label_for_loop(&this, node: &AST): str {$/;"	f
get_buffer	$OCEN_ROOT/std/og/mod.oc	/^def get_buffer(): &Texture {$/;"	f
get_buffer_sized	$OCEN_ROOT/std/og/mod.oc	/^def get_buffer_sized(w: i32, h: i32): &Texture {$/;"	f
get_button	$OCEN_ROOT/std/og/state.oc	/^def MouseState::get_button(&this, b: sdl::MouseButton): bool => .buttons[b as u32]$/;"	f
get_byte_at	$OCEN_ROOT/std/buffer.oc	/^def Buffer::get_byte_at(this, index: u32): u8 {$/;"	f
get_char_rect	$OCEN_ROOT/std/ogui/atlas.oc	/^def get_char_rect(chr: char): Rect {$/;"	f
get_clip_rect	$OCEN_ROOT/std/mui.oc	/^def Context::get_clip_rect(&this): Rect => .clip_stack.back()$/;"	f
get_closure_type	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::get_closure_type(&this, params: &Vector<&Variable>, return_type: &Type, old: &T/;"	f
get_compress_bound	$OCEN_ROOT/std/zlib.oc	/^    [extern "compressBound"] def get_compress_bound(size: u64): uLongf$/;"	f
get_container	$OCEN_ROOT/std/mui.oc	/^def Context::get_container(&this, id: u32, opt: Opt): &Container {$/;"	f
get_container_name	$OCEN_ROOT/std/mui.oc	/^def Context::get_container_name(&this, name: str): &Container {$/;"	f
get_crc	$OCEN_ROOT/std/image/png.oc	/^def get_crc(buf: &u8, len: u32, init: u32 = 0xffffffff): u32 {$/;"	f
get_current_container	$OCEN_ROOT/std/mui.oc	/^def Context::get_current_container(&this): &Container {$/;"	f
get_current_time	$OCEN_ROOT/std/og/mod.oc	/^def get_current_time(): f32 => get_ticks() as f32 \/ 1000.0$/;"	f
get_deep_copy	$OCEN_ROOT/compiler/ast/program.oc	/^def get_deep_copy<T>($/;"	f
get_digit	$OCEN_ROOT/std/mod.oc	/^def char::get_digit(this): u32 => this as u32 - '0' as u32$/;"	f
get_err	$OCEN_ROOT/std/libc/errno.oc	/^def get_err(): str => strerror(errno) as str$/;"	f
get_error	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_GetError"] def get_error(): str$/;"	f
get_error	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetError"]                def get_error(): str$/;"	f
get_error	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_GetError"] def get_error(): str/;"	f
get_error_context	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::get_error_context(&this): &ErrorContext {$/;"	f
get_extern_from_attr	$OCEN_ROOT/compiler/parser.oc	/^def Parser::get_extern_from_attr(&this, sym: &Symbol, attr: &Attribute) {$/;"	f
get_field	$OCEN_ROOT/compiler/ast/nodes.oc	/^def Structure::get_field(&this, name: str): &Variable {$/;"	f
get_field_by_idx	$OCEN_ROOT/compiler/ast/nodes.oc	/^def EnumVariant::get_field_by_idx(&this, idx: u32): &Variable {$/;"	f
get_flags	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetWindowFlags"] def Window::get_flags(&this): i32$/;"	f
get_frame_time	$OCEN_ROOT/std/og/mod.oc	/^def get_frame_time(): f32 => state::frame_time$/;"	f
get_hex_digit	$OCEN_ROOT/std/mod.oc	/^def char::get_hex_digit(this): u8 => char::value_from_hex(this)$/;"	f
get_id	$OCEN_ROOT/std/mui.oc	/^def Context::get_id(&this, data: untyped_ptr, size: u32): u32 {$/;"	f
get_index	$OCEN_ROOT/std/compact_map.oc	/^def Map::get_index(&this, key: K, hash: u32): u32 {$/;"	f
get_interpolated	$OCEN_ROOT/std/image/mod.oc	/^def Image::get_interpolated(&this, xf: f32, yf: f32): Color {$/;"	f
get_item	$OCEN_ROOT/std/compact_map.oc	/^def Map::get_item(&this, key: K): &Item<K, V> {$/;"	f
get_item	$OCEN_ROOT/std/map.oc	/^def Map::get_item(&this, key: K): &Item<K, V> {$/;"	f
get_keyboard_state	$OCEN_ROOT/std/sdl/mod.oc	/^def get_keyboard_state(): &u8 => impl::get_keyboard_state() as &u8$/;"	f
get_layout	$OCEN_ROOT/std/mui.oc	/^def Context::get_layout(&this): &Layout => .layout_stack.back_ptr()$/;"	f
get_location	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def get_location(req: &Value): Loc {$/;"	f
get_member	$OCEN_ROOT/compiler/types.oc	/^def Type::get_member(&this, name: str): &Symbol {$/;"	f
get_mouse_delta	$OCEN_ROOT/std/og/mod.oc	/^def get_mouse_delta(): Vec2i => state::mouse.vec \/\/ from SDL_MOUSEMOTION event$/;"	f
get_mouse_pos	$OCEN_ROOT/std/og/mod.oc	/^def get_mouse_pos(): Vec2i => state::mouse.pos$/;"	f
get_mouse_scroll	$OCEN_ROOT/std/og/mod.oc	/^def get_mouse_scroll(): Vec2i => state::mouse.scroll \/\/ from SDL_MOUSEWHEEL event$/;"	f
get_mouse_state	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetMouseState"]           def get_mouse_state(x: &i32, y: &i32): i32$/;"	f
get_op	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::get_op(&this, node: &AST): str => match node.type {$/;"	f
get_output	$OCEN_ROOT/std/process.oc	/^def get_output($/;"	f
get_position	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetWindowPosition"]       def Window::get_position(&this, x: &i32, y: &i32)$/;"	f
get_project_root	$OCEN_ROOT/compiler/ast/program.oc	/^def Namespace::get_project_root(&this, span: Span, program_for_errors: &Program): &Namespace {$/;"	f
get_range	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def get_range(val: &Value): &Value {$/;"	f
get_relative_mouse_state	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetRelativeMouseState"]   def get_relative_mouse_state(x: &i32, y: &i32): i32$/;"	f
get_shared_field	$OCEN_ROOT/compiler/ast/nodes.oc	/^def Enum::get_shared_field(&this, name: str): &Variable {$/;"	f
get_size	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetWindowSize"]  def Window::get_size(&this, w: &i32, h: &i32)$/;"	f
get_source_text	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::get_source_text(&this, span: Span): str {$/;"	f
get_specific_field	$OCEN_ROOT/compiler/ast/nodes.oc	/^def EnumVariant::get_specific_field(&this, name: str): &Variable {$/;"	f
get_surface	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetWindowSurface"]        def Window::get_surface(&this): &Surface$/;"	f
get_symbol_typedef	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def get_symbol_typedef(sym: &Symbol): &Type => match sym.type {$/;"	f
get_text_height	$OCEN_ROOT/std/ogui/atlas.oc	/^def get_text_height(): i32 => 18$/;"	f
get_text_size	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_SizeText"]         def Font::get_text_size(&this, text: str, w: &i32, h: &i32)$/;"	f
get_ticks	$OCEN_ROOT/std/og/mod.oc	/^def get_ticks(): u32 => sdl::get_ticks() as u32$/;"	f
get_ticks	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_GetTicks"]                def get_ticks(): i32$/;"	f
get_time_monotonic_ms	$OCEN_ROOT/std/time.oc	/^def get_time_monotonic_ms(): f64 {$/;"	f
get_time_monotonic_ns	$OCEN_ROOT/std/time.oc	/^def get_time_monotonic_ns(): u64 {$/;"	f
get_type_by_name	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::get_type_by_name(&this, name: str, span: Span): &Type {$/;"	f
get_type_by_name	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::get_type_by_name(&this, name: str, span: Span): &Type => .o.program.get_type_by/;"	f
get_type_name_string	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::get_type_name_string(&this, type: &Type, name: str, is_func_def: bool): str {$/;"	f
get_unique_reference_spans	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def get_unique_reference_spans(sym: &Symbol, for_rename: bool): &Vector<Span> {$/;"	f
get_uri	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def get_uri(orig_uri: &Value, val: &Value): &Value {$/;"	f
get_variant	$OCEN_ROOT/compiler/ast/nodes.oc	/^def Enum::get_variant(&this, name: str): &EnumVariant {$/;"	f
get_wheel	$OCEN_ROOT/std/og/state.oc	/^def MouseState::get_wheel(&this, w: MouseWheel): bool => .wheel_dirs[w as u32]$/;"	f
get_window_size	$OCEN_ROOT/std/og/mod.oc	/^def get_window_size(): Vec2i => state::window_size$/;"	f
getdetachstate	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_attr_getdetachstate"] def ThreadAttr::getdetachstate(&this, detachstate: &D/;"	f
getenv	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def getenv(name: str): str$/;"	f
gethostbyname	$OCEN_ROOT/std/socket.oc	/^    [extern] def gethostbyname(name: str): &HostEnt$/;"	f
getschedpolicy	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_attr_getschedpolicy"] def ThreadAttr::getschedpolicy(&this, policy: &SchedP/;"	f
getstacksize	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_attr_getstacksize"]   def ThreadAttr::getstacksize(&this, getss:&i32): i32$/;"	f
glBegin	$OCEN_ROOT/std/glut.oc	/^[extern] def glBegin(mode: i32)$/;"	f
glClear	$OCEN_ROOT/std/glut.oc	/^[extern] def glClear(mask: i32)$/;"	f
glColor3f	$OCEN_ROOT/std/glut.oc	/^[extern] def glColor3f(r: f32, g: f32, b: f32)$/;"	f
glEnable	$OCEN_ROOT/std/glut.oc	/^[extern] def glEnable(cap: i32)$/;"	f
glEnd	$OCEN_ROOT/std/glut.oc	/^[extern] def glEnd()$/;"	f
glFlush	$OCEN_ROOT/std/glut.oc	/^[extern] def glFlush()$/;"	f
glLoadIdentity	$OCEN_ROOT/std/glut.oc	/^[extern] def glLoadIdentity()$/;"	f
glMatrixMode	$OCEN_ROOT/std/glut.oc	/^[extern] def glMatrixMode(mode: i32)$/;"	f
glPopMatrix	$OCEN_ROOT/std/glut.oc	/^[extern] def glPopMatrix()$/;"	f
glPushMatrix	$OCEN_ROOT/std/glut.oc	/^[extern] def glPushMatrix()$/;"	f
glRotatef	$OCEN_ROOT/std/glut.oc	/^[extern] def glRotatef(angle: f32, x: f32, y: f32, z: f32)$/;"	f
glTranslatef	$OCEN_ROOT/std/glut.oc	/^[extern] def glTranslatef(x: f32, y: f32, z: f32)$/;"	f
glVertex3f	$OCEN_ROOT/std/glut.oc	/^[extern] def glVertex3f(x: f32, y: f32, z: f32)$/;"	f
glViewport	$OCEN_ROOT/std/glut.oc	/^[extern] def glViewport(x: i32, y: i32, width: i32, height: i32)$/;"	f
global_cleanup	$OCEN_ROOT/std/curl.oc	/^[extern "curl_global_cleanup"] def global_cleanup()$/;"	f
global_init	$OCEN_ROOT/std/curl.oc	/^[extern "curl_global_init"] def global_init(flags: u64): u64$/;"	f
gluLookAt	$OCEN_ROOT/std/glut.oc	/^[extern] def gluLookAt($/;"	f
gluPerspective	$OCEN_ROOT/std/glut.oc	/^[extern] def gluPerspective(fovy: f32, aspect: f32, zNear: f32, zFar: f32)$/;"	f
glutCreateWindow	$OCEN_ROOT/std/glut.oc	/^[extern] def glutCreateWindow(title: str)$/;"	f
glutDisplayFunc	$OCEN_ROOT/std/glut.oc	/^[extern] def glutDisplayFunc(func: fn())$/;"	f
glutInit	$OCEN_ROOT/std/glut.oc	/^[extern] def glutInit(argc: &i32, argv: &str)$/;"	f
glutInitDisplayMode	$OCEN_ROOT/std/glut.oc	/^[extern] def glutInitDisplayMode(mode: i32)$/;"	f
glutInitWindowPosition	$OCEN_ROOT/std/glut.oc	/^[extern] def glutInitWindowPosition(x: i32, y: i32)$/;"	f
glutInitWindowSize	$OCEN_ROOT/std/glut.oc	/^[extern] def glutInitWindowSize(width: i32, height: i32)$/;"	f
glutMainLoop	$OCEN_ROOT/std/glut.oc	/^[extern] def glutMainLoop()$/;"	f
glutPostRedisplay	$OCEN_ROOT/std/glut.oc	/^[extern] def glutPostRedisplay()$/;"	f
glutReshapeFunc	$OCEN_ROOT/std/glut.oc	/^[extern] def glutReshapeFunc(func: fn(i32, i32))$/;"	f
glutSwapBuffers	$OCEN_ROOT/std/glut.oc	/^[extern] def glutSwapBuffers()$/;"	f
glutTimerFunc	$OCEN_ROOT/std/glut.oc	/^[extern] def glutTimerFunc(time: i32, func: fn(i32), value: i32)$/;"	f
glutWireSphere	$OCEN_ROOT/std/glut.oc	/^[extern] def glutWireSphere(radius: f32, slices: i32, stacks: i32)/;"	f
grab_input	$OCEN_ROOT/std/og/mod.oc	/^def grab_input(grab: bool) => sdl::set_relative_mouse_mode(grab)$/;"	f
handle_buffer_change	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_buffer_change(&this, buf: &Buffer, range: &Value, new_text: &Buffer) {$/;"	f
handle_completion	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_completion(&this, req: &Value) {$/;"	f
handle_definition	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_definition(&this, req: &Value) {$/;"	f
handle_did_change	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_did_change(&this, req: &Value) {$/;"	f
handle_did_close	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_did_close(&this, req: &Value) {$/;"	f
handle_did_open	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_did_open(&this, req: &Value) {$/;"	f
handle_document_symbols	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def handle_document_symbols(program: &Program, path: str) {$/;"	f
handle_hover	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_hover(&this, req: &Value) {$/;"	f
handle_import_path_base	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::handle_import_path_base($/;"	f
handle_import_statement	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::handle_import_statement(&this, node: &AST) {$/;"	f
handle_imports	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::handle_imports(&this, ns: &Namespace, is_global: bool = false) {$/;"	f
handle_initialize	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_initialize(&this, req: &Value) {$/;"	f
handle_initialized	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_initialized(&this, req: &Value) {$/;"	f
handle_location_command	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def handle_location_command(program: &Program, type: CommandType, loc: Location) {$/;"	f
handle_mui_inputs	$OCEN_ROOT/std/mui_og/mod.oc	/^def handle_mui_inputs(ctx: &mui::Context) {$/;"	f
handle_mui_inputs	$OCEN_ROOT/std/ogui/mod.oc	/^def handle_mui_inputs(ctx: &mui::Context) {$/;"	f
handle_on_document_symbols	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_on_document_symbols(&this, req: &Value) {$/;"	f
handle_pixel	$OCEN_ROOT/std/image/qoi.oc	/^def QOIEncoder::handle_pixel(&this, pix: RGBA, num: u32 = 1) {$/;"	f
handle_references	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_references(&this, req: &Value) {$/;"	f
handle_rename	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_rename(&this, req: &Value) {$/;"	f
handle_request	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_request(&this, ): bool {$/;"	f
handle_resize	$OCEN_ROOT/std/mui_og/mod.oc	/^def handle_resize(ctx: &mui::Context) {$/;"	f
handle_resize	$OCEN_ROOT/std/ogui/mod.oc	/^def handle_resize(ctx: &mui::Context) {$/;"	f
handle_sdl_events	$OCEN_ROOT/std/og/utils.oc	/^def handle_sdl_events() {$/;"	f
handle_shutdown	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_shutdown(&this, req: &Value) {$/;"	f
handle_signature_help	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_signature_help(&this, req: &Value) {$/;"	f
handle_type_definition	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_type_definition(&this, req: &Value) {$/;"	f
handle_validate	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def handle_validate(program: &Program, path: str) {$/;"	f
handle_validate_document	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::handle_validate_document(&this) {$/;"	f
has_bits	$OCEN_ROOT/std/bitio.oc	/^def BitReader::has_bits(&this): bool => .idx < .num_bits$/;"	f
has_value	$OCEN_ROOT/compiler/ast/program.oc	/^def NSIterator::has_value(&this): bool => .curr?$/;"	f
has_value	$OCEN_ROOT/std/bitio.oc	/^def BitReader::has_value(&this): bool => .idx < .num_bits$/;"	f
has_value	$OCEN_ROOT/std/compact_map.oc	/^def ValueIterator::has_value(&this): bool => .iter.has_value()$/;"	f
has_value	$OCEN_ROOT/std/fs.oc	/^def DirectoryIterator::has_value(&this): bool => .dp?$/;"	f
has_value	$OCEN_ROOT/std/linkedlist.oc	/^def Iterator::has_value(&this): bool => .node?$/;"	f
has_value	$OCEN_ROOT/std/map.oc	/^def ValueIterator::has_value(&this): bool => .map_iter.has_value()$/;"	f
has_value	$OCEN_ROOT/std/mod.oc	/^def CharIterator::has_value(&this): bool => .pos < .len$/;"	f
has_value	$OCEN_ROOT/std/set.oc	/^def Iterator::has_value(&this): bool => .map_iter.has_value()$/;"	f
has_value	$OCEN_ROOT/std/sv.oc	/^def SVWordIterator::has_value(&this): bool => not .sv.is_empty()$/;"	f
has_value	$OCEN_ROOT/std/vector.oc	/^def Iterator::has_value(&this): bool => .index < .vec.size$/;"	f
hash	$OCEN_ROOT/compiler/ast/operators.oc	/^def OperatorOverload::hash(this): u32 {$/;"	f
hash	$OCEN_ROOT/compiler/attributes.oc	/^def AttributeType::hash(this): u32 => this as u32$/;"	f
hash	$OCEN_ROOT/std/hash/sha1.oc	/^def hash(input: Buffer): Buffer {$/;"	f
hash	$OCEN_ROOT/std/hash/sha256.oc	/^def hash(input: Buffer): Buffer {$/;"	f
hash	$OCEN_ROOT/std/image/qoi.oc	/^def RGBA::hash(this): u32 {$/;"	f
hash	$OCEN_ROOT/std/map.oc	/^def Map::hash(&this, key: K): u32 {$/;"	f
hash	$OCEN_ROOT/std/mui.oc	/^def hash(state: &u32, data: untyped_ptr, size: u32): u32 {$/;"	f
hash	$OCEN_ROOT/std/sdl/mod.oc	/^def Key::hash(this): u32 => (this as u32).hash()$/;"	f
hash	$OCEN_ROOT/std/span.oc	/^def Span::hash(this): u32 => pair_hash(.start.hash(), .end.index.hash())$/;"	f
hash	$OCEN_ROOT/std/sv.oc	/^def SV::hash(this): u32 {$/;"	f
hash	$OCEN_ROOT/std/traits/hash.oc	/^def untyped_ptr::hash(this): u32 => ptr_hash(this)$/;"	f
hash	$OCEN_ROOT/std/vec.oc	/^def Vec3::hash(this): u32 => pair_hash(.x.hash(), pair_hash(.y.hash(), .z.hash()))$/;"	f
hash_bytes	$OCEN_ROOT/std/traits/hash.oc	/^def hash_bytes(data: &u8, len: u32): u32 {$/;"	f
hash_into	$OCEN_ROOT/std/hash/sha1.oc	/^def hash_into(input: Buffer, output: &u8) {$/;"	f
hash_into	$OCEN_ROOT/std/hash/sha256.oc	/^def hash_into(input: Buffer, output: &u8) {$/;"	f
hash_str	$OCEN_ROOT/std/hash/sha1.oc	/^def hash_str(data: str): Buffer => hash(Buffer::from_str(data))$/;"	f
hash_str	$OCEN_ROOT/std/hash/sha256.oc	/^def hash_str(data: str): Buffer => hash(Buffer::from_str(data))$/;"	f
header	$OCEN_ROOT/std/mui.oc	/^def Context::header(&this, label: str, opt: Opt = 0): Res {$/;"	f
helper_gen_function_type	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::helper_gen_function_type($/;"	f
helper_gen_type	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::helper_gen_type(&this, top: &Type, cur: &Type, acc: str, is_func_def: bool): /;"	f
hex_dump	$OCEN_ROOT/std/buffer.oc	/^def hex_dump(data: &u8, size: u32) {$/;"	f
hex_dump	$OCEN_ROOT/std/hash/sha1.oc	/^def SHA1Hash::hex_dump(this) => hex_dump(.data, 20)$/;"	f
hex_dump	$OCEN_ROOT/std/hash/sha256.oc	/^def SHA256Hash::hex_dump(this) => hex_dump(.data, 32)$/;"	f
hex_from_value	$OCEN_ROOT/std/mod.oc	/^def char::hex_from_value(val: u8): char {$/;"	f
hostent	$OCEN_ROOT/std/socket.oc	/^    [extern "struct hostent"]$/;"	f
hsv_to_rgb	$OCEN_ROOT/std/mui.oc	/^def hsv_to_rgb(h: f32, s: f32, v: f32): Color {$/;"	f
htonl	$OCEN_ROOT/std/socket.oc	/^    [extern] def htonl(val: i32): i32$/;"	f
htons	$OCEN_ROOT/std/socket.oc	/^    [extern] def htons(val: i32): i32$/;"	f
http_request	$OCEN_ROOT/std/curl.oc	/^def http_request(url: str, data: &Buffer = null): Buffer {$/;"	f
http_request_auth	$OCEN_ROOT/std/curl.oc	/^def http_request_auth($/;"	f
human_readable_size	$OCEN_ROOT/std/gc.oc	/^def human_readable_size(bytes: i64, output: str) {$/;"	f
i16	$OCEN_ROOT/std/math.oc	/^def i16::abs(this): i16 => if this < 0 then -this else this$/;"	f
i16	$OCEN_ROOT/std/traits/compare.oc	/^def i16::compare(this, b: i16): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
i16	$OCEN_ROOT/std/traits/eq.oc	/^def i16::eq(this, other: i16): bool => this == other$/;"	f
i16	$OCEN_ROOT/std/traits/hash.oc	/^def i16::hash(this): u32 => this as u32 * 7817$/;"	f
i32	$OCEN_ROOT/std/math.oc	/^def i32::clamp(this, min: i32, max: i32): i32 => i32::max(i32::min(this, max), min)$/;"	f
i32	$OCEN_ROOT/std/mod.oc	/^def i32::min(this, b: i32): i32 => if this < b then this else b$/;"	f
i32	$OCEN_ROOT/std/traits/compare.oc	/^def i32::compare(this, b: i32): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
i32	$OCEN_ROOT/std/traits/eq.oc	/^def i32::eq(this, other: i32): bool => this == other$/;"	f
i32	$OCEN_ROOT/std/traits/hash.oc	/^def i32::hash(this): u32 => this as u32 * 7817$/;"	f
i64	$OCEN_ROOT/std/math.oc	/^def i64::abs(this): i64 => if this < 0 then -this else this$/;"	f
i64	$OCEN_ROOT/std/traits/compare.oc	/^def i64::compare(this, b: i64): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
i64	$OCEN_ROOT/std/traits/eq.oc	/^def i64::eq(this, other: i64): bool => this == other$/;"	f
i64	$OCEN_ROOT/std/traits/hash.oc	/^def i64::hash(this): u32 => pair_hash((this as u32).hash(), ((this >> 32) as u32).hash())$/;"	f
i8	$OCEN_ROOT/std/math.oc	/^def i8::abs(this): i8 => if this < 0 then -this else this$/;"	f
i8	$OCEN_ROOT/std/mod.oc	/^def i8::min(this, b: i8): i8 => if this < b then this else b$/;"	f
i8	$OCEN_ROOT/std/traits/compare.oc	/^def i8::compare(this, b: i8): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
i8	$OCEN_ROOT/std/traits/eq.oc	/^def i8::eq(this, other: i8): bool => this == other$/;"	f
i8	$OCEN_ROOT/std/traits/hash.oc	/^def i8::hash(this): u32 => this as u32 * 7817$/;"	f
identity	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::identity(): Matrix4f => Matrix4f::make($/;"	f
ifft	$OCEN_ROOT/std/fft.oc	/^def ifft(data: &Complex, N: u32, out: &Complex) {$/;"	f
ifft2	$OCEN_ROOT/std/fft.oc	/^def ifft2(inp: &Complex, R: u32, C: u32, out: &Complex) {$/;"	f
imag	$OCEN_ROOT/std/complex.oc	/^[extern "cimagf"] def Complex::imag(this): f32$/;"	f
image	$OCEN_ROOT/std/mui.oc	/^def Context::image(&this, label: str, img: &Image) {$/;"	f
img_pix	$OCEN_ROOT/std/image/qoi.oc	/^def QOIEncoder::img_pix(&this, idx: u32): RGBA {$/;"	f
import_all_from_namespace	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::import_all_from_namespace(&this, ns: &Namespace, export: bool) {$/;"	f
import_all_from_symbol	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::import_all_from_symbol(&this, sym: &Symbol, export: bool) {$/;"	f
import_external_lib	$OCEN_ROOT/compiler/parser.oc	/^def Parser::import_external_lib(&this, name: str): &Namespace {$/;"	f
import_from_stdlib	$OCEN_ROOT/compiler/parser.oc	/^def Parser::import_from_stdlib(&this, name: str, span: Span): &Namespace {$/;"	f
in_addr	$OCEN_ROOT/std/socket.oc	/^    [extern "struct in_addr"]$/;"	f
in_hover_root	$OCEN_ROOT/std/mui.oc	/^def Context::in_hover_root(&this): bool {$/;"	f
inc	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::inc(&this) {$/;"	f
inc	$OCEN_ROOT/std/bencode.oc	/^def Parser::inc(&this) => .loc.index += 1$/;"	f
include_prelude_only	$OCEN_ROOT/compiler/parser.oc	/^def Parser::include_prelude_only(&this) {$/;"	f
index	$OCEN_ROOT/std/vec.oc	/^def Vec3::index(this, idx: u32): T => (&this as &T)[idx]$/;"	f
inet_ntop	$OCEN_ROOT/std/socket.oc	/^    [extern] def inet_ntop(af: i32, src: untyped_ptr, dst: str, size: i32): str$/;"	f
inet_pton	$OCEN_ROOT/std/socket.oc	/^    [extern] def inet_pton(af: i32, src: str, dst: untyped_ptr): i32$/;"	f
inf	$OCEN_ROOT/std/math.oc	/^def f64::inf(): f64 => INFINITY$/;"	f
inflate	$OCEN_ROOT/std/zlib.oc	/^    [extern "inflate"] def Stream::inflate(&this, flush: i32): i32$/;"	f
init	$OCEN_ROOT/std/gc.oc	/^def init(base: untyped_ptr) {$/;"	f
init	$OCEN_ROOT/std/mui.oc	/^def init(): &Context {$/;"	f
init	$OCEN_ROOT/std/mui_og/mod.oc	/^def init(width: u32, height: u32, title: str = "mui"): &mui::Context {$/;"	f
init	$OCEN_ROOT/std/og/mod.oc	/^def init(width: u32, height: u32, title: str, fullscreen: bool = false) {$/;"	f
init	$OCEN_ROOT/std/ogui/mod.oc	/^def init(width: u32, height: u32, title: str = "mui"): &mui::Context {$/;"	f
init	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_Init"]                    def init(flags: i32): i32$/;"	f
init	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_Init"]     def init(): i32$/;"	f
init	$OCEN_ROOT/std/thread.oc	/^def Barrier::init(&this, count: i32) {$/;"	f
init	$OCEN_ROOT/std/zlib.oc	/^    [extern "inflateInit"] def Stream::init(&this): i32$/;"	f
init_logging	$OCEN_ROOT/std/logging.oc	/^def init_logging(level: LogLevel = Info, time_format: str = "%H:%M:%S") {$/;"	f
initialize	$OCEN_ROOT/std/bump_alloc.oc	/^def initialize() {$/;"	f
input_keydown	$OCEN_ROOT/std/mui.oc	/^def Context::input_keydown(&this, key: Key) {$/;"	f
input_keyup	$OCEN_ROOT/std/mui.oc	/^def Context::input_keyup(&this, key: Key) {$/;"	f
input_mousedown	$OCEN_ROOT/std/mui.oc	/^def Context::input_mousedown(&this, x: i32, y: i32, btn: Mouse) {$/;"	f
input_mousemove	$OCEN_ROOT/std/mui.oc	/^def Context::input_mousemove(&this, x: i32, y: i32) => .mouse_pos = Vec2i(x, y)$/;"	f
input_mouseup	$OCEN_ROOT/std/mui.oc	/^def Context::input_mouseup(&this, x: i32, y: i32, btn: Mouse) {$/;"	f
input_scroll	$OCEN_ROOT/std/mui.oc	/^def Context::input_scroll(&this, x: i32, y: i32) {$/;"	f
input_text	$OCEN_ROOT/std/mui.oc	/^def Context::input_text(&this, text: str) {$/;"	f
insert	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Scope::insert(&this, name: str, symbol: &Symbol) {$/;"	f
insert	$OCEN_ROOT/std/buffer.oc	/^def Buffer::insert(&this, index: u32, buf: &Buffer) {$/;"	f
insert	$OCEN_ROOT/std/compact_map.oc	/^def Map::insert(&this, key: K, value: V) {$/;"	f
insert	$OCEN_ROOT/std/disjoint_set.oc	/^def DisjointSet::insert(&this, x: T): T {$/;"	f
insert	$OCEN_ROOT/std/map.oc	/^def Map::insert(&this, key: K, value: V) {$/;"	f
insert	$OCEN_ROOT/std/value.oc	/^def Value::insert(&this, key: str, value: &Value) {$/;"	f
insert_bool	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_bool(&this, key: str, b: bool) => .insert(key, Value::new_boo/;"	f
insert_completion_item	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def insert_completion_item(completions: &Value, sym: &Symbol, seen: &Set<str>, name: str = null)/;"	f
insert_f32	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_f32(&this, key: str, f: f32) => .insert(key, Value::new_float/;"	f
insert_f64	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_f64(&this, key: str, f: f64) => .insert(key, Value::new_float/;"	f
insert_i32	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_i32(&this, key: str, i: i32) => .insert(key, Value::new_int(i/;"	f
insert_i64	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_i64(&this, key: str, i: i64) => .insert(key, Value::new_int(i/;"	f
insert_into_scope_checked	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::insert_into_scope_checked(&this, item: &Symbol, name: str = null) {$/;"	f
insert_into_scope_checked_and_export	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::insert_into_scope_checked_and_export(&this, export: bool, item: &Symbol, name: /;"	f
insert_str	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_str(&this, key: str, s: str) => .insert(key, Value::new_str(s/;"	f
insert_u32	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_u32(&this, key: str, i: u32) => .insert(key, Value::new_int(i/;"	f
insert_u64	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::insert_u64(&this, key: str, i: u64) => .insert(key, Value::new_int(i/;"	f
int16_t	$OCEN_ROOT/std/prelude.h	/^typedef int16_t i16;$/;"	f
int32_t	$OCEN_ROOT/std/prelude.h	/^typedef int32_t i32;$/;"	f
int64_t	$OCEN_ROOT/std/prelude.h	/^typedef int64_t i64;$/;"	f
int8_t	$OCEN_ROOT/std/prelude.h	/^typedef int8_t i8;$/;"	f
interp	$OCEN_ROOT/std/image/mod.oc	/^def interp(t: f32, a: f32, b: f32): f32 {$/;"	f
intersect	$OCEN_ROOT/std/mui.oc	/^def Rect::intersect(this, other: Rect): Rect {$/;"	f
into_option	$OCEN_ROOT/std/result.oc	/^def Result::into_option(this): Option<T> => match this {$/;"	f
into_result	$OCEN_ROOT/std/option.oc	/^def Option::into_result(this, msg: str): Result<T, str> => match this {$/;"	f
invert	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::invert(&this): Matrix4f {$/;"	f
is	$OCEN_ROOT/std/value.oc	/^def Value::is(this, type: ValueType): bool => .type == type$/;"	f
is_alnum	$OCEN_ROOT/std/mod.oc	/^def char::is_alnum(this): bool => libc::isalnum(this)$/;"	f
is_alpha	$OCEN_ROOT/std/mod.oc	/^def char::is_alpha(this): bool => libc::isalpha(this)$/;"	f
is_before	$OCEN_ROOT/std/span.oc	/^def Location::is_before(&this, other: Location): bool {$/;"	f
is_callable	$OCEN_ROOT/compiler/types.oc	/^def BaseType::is_callable(this): bool => this == FunctionPtr or this == Closure$/;"	f
is_close	$OCEN_ROOT/std/math.oc	/^def f64::is_close(this, other: f64, thresh: f64 = 0.0001): bool => (this - other).abs() < thresh$/;"	f
is_compound_operator	$OCEN_ROOT/compiler/parser.oc	/^def Parser::is_compound_operator(&this, op: Operator): bool => match op {$/;"	f
is_digit	$OCEN_ROOT/std/mod.oc	/^def char::is_digit(this): bool => libc::isdigit(this)$/;"	f
is_empty	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::is_empty(&this): bool => .index >= .size/;"	f
is_empty	$OCEN_ROOT/std/compact_map.oc	/^def Map::is_empty(&this): bool => .items.size == 0$/;"	f
is_empty	$OCEN_ROOT/std/deque.oc	/^def Deque::is_empty(&this): bool => .size == 0/;"	f
is_empty	$OCEN_ROOT/std/heap.oc	/^def Heap::is_empty(&this): bool => .vec.is_empty()$/;"	f
is_empty	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::is_empty(&this): bool => .head == null$/;"	f
is_empty	$OCEN_ROOT/std/map.oc	/^def Map::is_empty(&this): bool => .size == 0$/;"	f
is_empty	$OCEN_ROOT/std/set.oc	/^def Set::is_empty(&this): bool => .map.size == 0$/;"	f
is_empty	$OCEN_ROOT/std/sv.oc	/^def SV::is_empty(&this): bool => .len == 0$/;"	f
is_empty	$OCEN_ROOT/std/vector.oc	/^def Vector::is_empty(&this): bool => .size == 0$/;"	f
is_end_of_statement	$OCEN_ROOT/compiler/parser.oc	/^def Parser::is_end_of_statement(&this): bool {$/;"	f
is_enum_flag	$OCEN_ROOT/compiler/types.oc	/^def Type::is_enum_flag(&this): bool => .base == BaseType::Enum and .u.enom.is_flag_enum$/;"	f
is_error	$OCEN_ROOT/std/result.oc	/^def Result::is_error(this): bool => match this {$/;"	f
is_float	$OCEN_ROOT/compiler/types.oc	/^def Type::is_float(&this): bool => .base == BaseType::F32 or .base == BaseType::F64$/;"	f
is_formattable	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::is_formattable(&this, typ: &Type, expr: &AST): Formattable {$/;"	f
is_hex_digit	$OCEN_ROOT/std/mod.oc	/^def char::is_hex_digit(this): bool => libc::isxdigit(this)$/;"	f
is_identifier	$OCEN_ROOT/compiler/ast/nodes.oc	/^def AST::is_identifier(&this): bool => match .type {$/;"	f
is_identifier	$OCEN_ROOT/compiler/tokens.oc	/^def Token::is_identifier(this, name: str): bool => match .type {$/;"	f
is_integer	$OCEN_ROOT/compiler/types.oc	/^def Type::is_integer(&this): bool => match .base {$/;"	f
is_key_down	$OCEN_ROOT/std/og/mod.oc	/^def is_key_down(k: sdl::Key): bool => state::keys.get(k) == true$/;"	f
is_key_pressed	$OCEN_ROOT/std/og/mod.oc	/^def is_key_pressed(k: sdl::Key): bool => state::prev_keys.get(k) == false and state::keys.get(k)/;"	f
is_key_released	$OCEN_ROOT/std/og/mod.oc	/^def is_key_released(k: sdl::Key): bool => state::prev_keys.get(k) == true and state::keys.get(k)/;"	f
is_key_up	$OCEN_ROOT/std/og/mod.oc	/^def is_key_up(k: sdl::Key): bool => state::keys.get(k) == false$/;"	f
is_lower	$OCEN_ROOT/std/mod.oc	/^def char::is_lower(this): bool => libc::islower(this)$/;"	f
is_lvalue	$OCEN_ROOT/compiler/ast/nodes.oc	/^def AST::is_lvalue(&this): bool => match .type {$/;"	f
is_mouse_down	$OCEN_ROOT/std/og/mod.oc	/^def is_mouse_down(b: sdl::MouseButton): bool$/;"	f
is_mouse_pressed	$OCEN_ROOT/std/og/mod.oc	/^def is_mouse_pressed(b: sdl::MouseButton): bool$/;"	f
is_mouse_released	$OCEN_ROOT/std/og/mod.oc	/^def is_mouse_released(b: sdl::MouseButton): bool$/;"	f
is_mouse_up	$OCEN_ROOT/std/og/mod.oc	/^def is_mouse_up(b: sdl::MouseButton): bool$/;"	f
is_none	$OCEN_ROOT/std/option.oc	/^def Option::is_none(this): bool => match this {$/;"	f
is_numeric	$OCEN_ROOT/compiler/types.oc	/^def Type::is_numeric(&this): bool => match .base {$/;"	f
is_numeric_or_char	$OCEN_ROOT/compiler/types.oc	/^def Type::is_numeric_or_char(&this): bool => .is_numeric() or .base == BaseType::Char$/;"	f
is_pointer_to	$OCEN_ROOT/compiler/types.oc	/^def Type::is_pointer_to(&this, base: BaseType): bool => .base == Pointer and .u.ptr.base == base$/;"	f
is_power_of_2	$OCEN_ROOT/std/fft.oc	/^def is_power_of_2(x: u32): bool => x & (x - 1) == 0$/;"	f
is_print	$OCEN_ROOT/std/mod.oc	/^def char::is_print(this): bool => libc::isprint(this)$/;"	f
is_resolved	$OCEN_ROOT/compiler/types.oc	/^def Type::is_resolved(&this): bool => match .base {$/;"	f
is_running	$OCEN_ROOT/std/og/mod.oc	/^def is_running(): bool {$/;"	f
is_scroll	$OCEN_ROOT/std/og/mod.oc	/^def is_scroll(w: state::MouseWheel): bool => state::mouse.get_wheel(w)$/;"	f
is_some	$OCEN_ROOT/std/option.oc	/^def Option::is_some(this): bool => not .is_none()$/;"	f
is_space	$OCEN_ROOT/std/mod.oc	/^def char::is_space(this): bool => libc::isspace(this)$/;"	f
is_str	$OCEN_ROOT/compiler/types.oc	/^def Type::is_str(&this): bool {$/;"	f
is_template_instance	$OCEN_ROOT/compiler/ast/nodes.oc	/^def Function::is_template_instance(&this): bool {$/;"	f
is_templated	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::is_templated(&this): bool => this? and .template?$/;"	f
is_upper	$OCEN_ROOT/std/mod.oc	/^def char::is_upper(this): bool => libc::isupper(this)$/;"	f
is_valid	$OCEN_ROOT/std/span.oc	/^def Span::is_valid(this): bool {$/;"	f
is_valid_ident_char	$OCEN_ROOT/compiler/lexer.oc	/^def is_valid_ident_char(c: char): bool {$/;"	f
is_valid_utf8_start	$OCEN_ROOT/compiler/lexer.oc	/^def is_valid_utf8_start(c: char, out_sz: &u32 = null): bool {$/;"	f
is_word	$OCEN_ROOT/compiler/tokens.oc	/^def Token::is_word(this): bool => match .type {$/;"	f
isalnum	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def isalnum(c: char): bool$/;"	f
isalpha	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def isalpha(c: char): bool$/;"	f
isdigit	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def isdigit(c: char): bool$/;"	f
islower	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def islower(c: char): bool$/;"	f
isnan	$OCEN_ROOT/std/math.oc	/^[extern "isnan"] def f32::isnan(this): bool$/;"	f
isprint	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def isprint(c: char): bool$/;"	f
isspace	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def isspace(c: char): bool$/;"	f
isupper	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def isupper(c: char): bool$/;"	f
isxdigit	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def isxdigit(c: char): bool$/;"	f
iter	$OCEN_ROOT/std/compact_map.oc	/^def Map::iter(&this): Iterator<K, V> => Iterator<K, V>(.items.iter())$/;"	f
iter	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::iter(&this): Iterator<T> => Iterator<T>(.head, forward: true)$/;"	f
iter	$OCEN_ROOT/std/map.oc	/^def Map::iter(&this): Iterator<K, V> {$/;"	f
iter	$OCEN_ROOT/std/set.oc	/^def Set::iter(&this): Iterator<T> => Iterator<T>::make(this)$/;"	f
iter	$OCEN_ROOT/std/vector.oc	/^def Vector::iter(&this): Iterator<T> => Iterator<T>::make(this)$/;"	f
iter_bits	$OCEN_ROOT/std/huffman.oc	/^def CharCode::iter_bits(&this): BitReader => BitReader(.code, num_bits: .bits, idx: 0)$/;"	f
iter_i64	$OCEN_ROOT/std/sv.oc	/^def SV::iter_i64(this): SVNumberIterator<i64> => SVNumberIterator<i64>::make(this)$/;"	f
iter_keys	$OCEN_ROOT/std/compact_map.oc	/^def Map::iter_keys(&this): KeyIterator<K, V> => KeyIterator<K, V>(.items.iter())$/;"	f
iter_keys	$OCEN_ROOT/std/map.oc	/^def Map::iter_keys(&this): KeyIterator<K, V> => KeyIterator<K, V>(.iter())$/;"	f
iter_namespaces	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::iter_namespaces(&this): NSIterator {$/;"	f
iter_nums	$OCEN_ROOT/std/sv.oc	/^def SV::iter_nums(this): SVNumberIterator<u64> => SVNumberIterator<u64>::make(this)$/;"	f
iter_pred	$OCEN_ROOT/std/sv.oc	/^def SV::iter_pred(this, pred: fn(SV): u32): SVPredicateIterator => SVPredicateIterator::make(thi/;"	f
iter_rev	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::iter_rev(&this): Iterator<T> => Iterator<T>(.head, forward: false)$/;"	f
iter_u64	$OCEN_ROOT/std/sv.oc	/^def SV::iter_u64(this): SVNumberIterator<u64> => SVNumberIterator<u64>::make(this)$/;"	f
iter_values	$OCEN_ROOT/std/compact_map.oc	/^def Map::iter_values(&this): ValueIterator<K, V> => ValueIterator<K, V>(.items.iter())$/;"	f
iter_values	$OCEN_ROOT/std/map.oc	/^def Map::iter_values(&this): ValueIterator<K, V> => ValueIterator<K, V>(.iter())$/;"	f
iterate_directory	$OCEN_ROOT/std/fs.oc	/^def iterate_directory(path: str, skip_self_and_parent: bool = true): DirectoryIterator {$/;"	f
join	$OCEN_ROOT/std/span.oc	/^def Span::join(this, other: Span): Span {$/;"	f
join	$OCEN_ROOT/std/thread.oc	/^def Thread::join(&this, b: &untyped_ptr = null) => check(.tid.join( b))$/;"	f
join_display	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::join_display(a: str, b: str): str => if a.len() == 0 then b else `{a}::{b}`$/;"	f
join_full_name	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::join_full_name(a: str, b: str): str => if a.len() == 0 then b else `{a}_{b}`$/;"	f
jump_back	$OCEN_ROOT/std/setjmp.oc	/^def ErrorContext::jump_back(this, status: i32)/;"	f
key	$OCEN_ROOT/std/map.oc	/^def Iterator::key(&this): K {$/;"	f
label	$OCEN_ROOT/std/mui.oc	/^def Context::label(&this, text: str, opt: Opt = 0) {$/;"	f
labelf	$OCEN_ROOT/std/mui.oc	/^def Context::labelf(&this, text: str, opt: Opt = 0) {$/;"	f
layout_begin_column	$OCEN_ROOT/std/mui.oc	/^def Context::layout_begin_column(&this) => .push_layout(.layout_next(), Vec2i(0, 0))$/;"	f
layout_end_column	$OCEN_ROOT/std/mui.oc	/^def Context::layout_end_column(&this) {$/;"	f
layout_height	$OCEN_ROOT/std/mui.oc	/^def Context::layout_height(&this, height: i32) => .get_layout().size.y = height$/;"	f
layout_next	$OCEN_ROOT/std/mui.oc	/^def Context::layout_next(&this): Rect {$/;"	f
layout_row	$OCEN_ROOT/std/mui.oc	/^def Context::layout_row(&this, items: i32, widths: &i32, height: i32) {$/;"	f
layout_set_next	$OCEN_ROOT/std/mui.oc	/^def Context::layout_set_next(&this, r: Rect, relative: bool) {$/;"	f
layout_width	$OCEN_ROOT/std/mui.oc	/^def Context::layout_width(&this, width: i32) => .get_layout().size.x = width$/;"	f
len	$OCEN_ROOT/std/mod.oc	/^[extern "strlen"] def str::len(this): u32$/;"	f
length	$OCEN_ROOT/std/vec.oc	/^def Vec3::length(this): f32 => ((.x * .x + .y * .y + .z * .z) as f32).sqrt()$/;"	f
length_sq	$OCEN_ROOT/std/vec.oc	/^def Vec3::length_sq(this): T => .x * .x + .y * .y + .z * .z$/;"	f
lex	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex(&this): &Vector<&Token> {$/;"	f
lex_char_literal	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex_char_literal(&this) {$/;"	f
lex_comment	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex_comment(&this) {$/;"	f
lex_int_literal_different_base	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex_int_literal_different_base(&this): &Token {$/;"	f
lex_numeric_literal	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex_numeric_literal(&this) {$/;"	f
lex_numeric_literal_helper	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex_numeric_literal_helper(&this): &Token {$/;"	f
lex_raw_string_literal	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex_raw_string_literal(&this) {$/;"	f
lex_string_literal	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::lex_string_literal(&this, has_seen_f: bool) {$/;"	f
line	$OCEN_ROOT/std/image/draw.oc	/^def line(img: &Image, x1: i32, y1: i32, x2: i32, y2: i32, color: Color) {$/;"	f
line_f	$OCEN_ROOT/std/image/draw.oc	/^def line_f(img: &Image, x1: f32, y1: f32, x2: f32, y2: f32, color: Color) {$/;"	f
lines	$OCEN_ROOT/std/sv.oc	/^def SV::lines(this): SVLineIterator => SVLineIterator(this)$/;"	f
listen	$OCEN_ROOT/std/socket.oc	/^    [extern] def listen(sockfd: i32, backlog: i32): i32$/;"	f
load	$OCEN_ROOT/std/image/mod.oc	/^def Image::load(filename: str): &Image {$/;"	f
load	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_OpenFont"]         def Font::load(path: str, size: i32): &Font$/;"	f
load_atlas_texture	$OCEN_ROOT/std/ogui/atlas.oc	/^def load_atlas_texture(): &Image {$/;"	f
load_file	$OCEN_ROOT/compiler/parser.oc	/^def Parser::load_file(&this, filename: str, contents: str = null) {$/;"	f
load_image	$OCEN_ROOT/std/sdl/image.oc	/^[extern "IMG_LoadTexture"] def std::sdl::Renderer::load_image(&this, path: str): &Texture$/;"	f
load_import_path	$OCEN_ROOT/compiler/parser.oc	/^def Parser::load_import_path(&this, import_stmt: &AST): bool {$/;"	f
load_import_path_from_base	$OCEN_ROOT/compiler/parser.oc	/^def Parser::load_import_path_from_base(&this, parts: &Vector<&ImportPart>, base: &Namespace): bo/;"	f
load_single_import_part	$OCEN_ROOT/compiler/parser.oc	/^def Parser::load_single_import_part(&this, base: &Namespace, name: str, span: Span): &Namespace /;"	f
load_wav	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_LoadWAV"] def load_wav(path: str): &Sound$/;"	f
localtime	$OCEN_ROOT/std/time.oc	/^[extern] def localtime(t: &Time): &TM$/;"	f
lock	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_LockTexture"]    def Texture::lock(&this, rect: &Rect, pixels: &untyped_ptr, pitch:/;"	f
lock	$OCEN_ROOT/std/thread.oc	/^def Mutex::lock(&this) => check(.tx.lock())$/;"	f
log	$OCEN_ROOT/std/complex.oc	/^[extern "clogf"] def Complex::log(this): Complex$/;"	f
log	$OCEN_ROOT/std/logging.oc	/^def log(level: LogLevel, fmt: str, ...) {$/;"	f
log	$OCEN_ROOT/std/math.oc	/^[extern "logf"] def f32::log(this): f32$/;"	f
log2	$OCEN_ROOT/std/math.oc	/^[extern "log2f"] def f32::log2(this): f32$/;"	f
lookup_local	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Scope::lookup_local(&this, name: str): &Symbol {$/;"	f
lookup_recursive	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Scope::lookup_recursive(&this, name: str): &Symbol {$/;"	f
loosely_resolve_templated_enum	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::loosely_resolve_templated_enum(&this, enom: &Enum) {$/;"	f
loosely_resolve_templated_struct	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::loosely_resolve_templated_struct(&this, struc: &Structure) {$/;"	f
lsp_log	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def lsp_log(msg: str) {$/;"	f
lsp_usage	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def lsp_usage(code: i32, full: bool) {$/;"	f
main	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def main(argc: i32, argv: &str, contents: str = null): i32 {$/;"	f
main	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def main(argc: i32, argv: &str): i32 {$/;"	f
main	$OCEN_ROOT/compiler/main.oc	/^def main(argc: i32, argv: &str): i32 {$/;"	f
main_loop	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def main_loop() {$/;"	f
maj	$OCEN_ROOT/std/hash/sha256.oc	/^    def maj(x: u32, y: u32, z: u32): u32 => (x & y) ^ (x & z) ^ (y & z)$/;"	f
make	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::make(source: str, filename: str, errors: &Vector<&Error> = null): Lexer {$/;"	f
make	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::make(cmd: CommandType, loc: Location): Finder {$/;"	f
make	$OCEN_ROOT/compiler/parser.oc	/^def Parser::make(program: &Program, ns: &Namespace): Parser {$/;"	f
make	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::make(program: &Program): CodeGenerator {$/;"	f
make	$OCEN_ROOT/std/argparse.oc	/^def Parser::make(description: str): Parser => Parser($/;"	f
make	$OCEN_ROOT/std/bitio.oc	/^def BitWriter::make(buffer: &Buffer): BitWriter {$/;"	f
make	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::make(data: &u8, size: u32): BytesReader {$/;"	f
make	$OCEN_ROOT/std/hash/sha256.oc	/^def Context::make(): Context {$/;"	f
make	$OCEN_ROOT/std/huffman.oc	/^def HuffmanCodes::make(tree: &HuffmanTree): HuffmanCodes {$/;"	f
make	$OCEN_ROOT/std/image/qoi.oc	/^def QOIEncoder::make(img: &Image, buffer: &Buffer): QOIEncoder {$/;"	f
make	$OCEN_ROOT/std/json.oc	/^def Parser::make(tokens: &Vector<&Token>): Parser {$/;"	f
make	$OCEN_ROOT/std/map.oc	/^def Iterator::make(map: &Map<K, V>): Iterator<K, V> {$/;"	f
make	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::make($/;"	f
make	$OCEN_ROOT/std/random.oc	/^def RandomState::make(s: u32 = 0): RandomState {$/;"	f
make	$OCEN_ROOT/std/set.oc	/^def Iterator::make(set: &Set<T>): Iterator<T> => Iterator<T>(set.map.iter())$/;"	f
make	$OCEN_ROOT/std/sv.oc	/^def SVPredicateIterator::make(sv: SV, pred: fn(SV): u32): SVPredicateIterator {$/;"	f
make	$OCEN_ROOT/std/thread.oc	/^def Thread::make(callback: fn(untyped_ptr): untyped_ptr, arg: untyped_ptr = null): Thread {$/;"	f
make	$OCEN_ROOT/std/timer.oc	/^def Timer::make(msg: str): Timer {$/;"	f
make	$OCEN_ROOT/std/vector.oc	/^def Iterator::make(vec: &Vector<T>): Iterator<T> => Iterator<T>(vec, 0)$/;"	f
make_crc_table	$OCEN_ROOT/std/image/png.oc	/^def make_crc_table() {$/;"	f
make_sv	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::make_sv(source: SV, filename: str, errors: &Vector<&Error> = null): Lexer {$/;"	f
mark	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::mark(&this, node: &AST) {$/;"	f
mark_enum	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::mark_enum(&this, e: &Enum) {$/;"	f
mark_function	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::mark_function(&this, f: &Function) {$/;"	f
mark_object	$OCEN_ROOT/std/gc.oc	/^    def mark_object(header: &Header) {$/;"	f
mark_range	$OCEN_ROOT/std/gc.oc	/^    def mark_range(start: untyped_ptr, end: untyped_ptr) {$/;"	f
mark_struct	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::mark_struct(&this, s: &Structure) {$/;"	f
mark_sym	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::mark_sym(&this, sym: &Symbol) {$/;"	f
mark_sym_as_dead_by_default	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::mark_sym_as_dead_by_default(&this, sym: &Symbol) {$/;"	f
mark_type	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::mark_type(&this, typ: &Type) {$/;"	f
matches	$OCEN_ROOT/compiler/ast/scopes.oc	/^def TemplateInstance::matches(&this, other: &Vector<&Type>): bool {$/;"	f
max	$OCEN_ROOT/std/math.oc	/^def f64::max(this, b: f64): f64 => if this > b then this else b$/;"	f
max	$OCEN_ROOT/std/mod.oc	/^def u8::max(this, other: u8): u8 => if this > other then this else other$/;"	f
maximize	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_MaximizeWindow"] def Window::maximize(&this)$/;"	f
memcmp	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def memcmp(s: untyped_ptr, other: untyped_ptr, n: u32): i32$/;"	f
memcpy	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def memcpy(dest: untyped_ptr, src: untyped_ptr, size: u32)$/;"	f
memmove	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def memmove(dest: untyped_ptr, src: untyped_ptr, size: u32)$/;"	f
memset	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def memset(dest: untyped_ptr, c: u8, size: u32)$/;"	f
merge	$OCEN_ROOT/std/disjoint_set.oc	/^def DisjointSet::merge(&this, x: T, y: T) {$/;"	f
min	$OCEN_ROOT/std/math.oc	/^def f64::min(this, b: f64): f64 => if this < b then this else b$/;"	f
min	$OCEN_ROOT/std/mod.oc	/^def u8::min(this, other: u8): u8 => if this < other then this else other$/;"	f
min_i32	$OCEN_ROOT/std/ogui/atlas.oc	/^def min_i32(a: i32, b: i32): i32 => if a < b then a else b$/;"	f
mkdir	$OCEN_ROOT/std/fs.oc	/^    [extern] def mkdir(path: str, mode: i32 = 0o777): i32$/;"	f
mktime	$OCEN_ROOT/std/time.oc	/^[extern] def mktime(tm: &TM): Time$/;"	f
mod	$OCEN_ROOT/std/math.oc	/^[operator "%"] [extern "fmodf"] def f32::mod(this, b: f32): f32$/;"	f
mouse_over	$OCEN_ROOT/std/mui.oc	/^def Context::mouse_over(&this, rect: Rect): bool {$/;"	f
mul	$OCEN_ROOT/std/complex.oc	/^def Complex::mul(this, other: Complex): Complex {$/;"	f
mul	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::mul(this, other: Matrix4f): Matrix4f {$/;"	f
mult	$OCEN_ROOT/std/vec.oc	/^[operator "*"] def Vec3::mult(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x * other.x, .y * other/;"	f
multrs	$OCEN_ROOT/std/vec.oc	/^[operator "*"] def Vec3::multrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val * this.x, val * t/;"	f
mults	$OCEN_ROOT/std/vec.oc	/^[operator "*"] def Vec3::mults(this, val: T): Vec3<T> => Vec3<T>(.x * val, .y * val, .z * val)$/;"	f
mulv	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::mulv(this, v: Vec3f): Vec3f {$/;"	f
mulv_no_translation	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::mulv_no_translation(this, v: Vec3f): Vec3f {$/;"	f
my_calloc	$OCEN_ROOT/std/mem.oc	/^    def my_calloc(state: State, size: u32): untyped_ptr                                   => c_c/;"	f
my_free	$OCEN_ROOT/std/mem.oc	/^    def my_free(state: State, ptr: untyped_ptr)                                           => c_f/;"	f
my_realloc	$OCEN_ROOT/std/mem.oc	/^    def my_realloc(state: State, ptr: untyped_ptr, old_size: u32, size: u32): untyped_ptr => c_r/;"	f
needs_lhs_pointer_for_overload	$OCEN_ROOT/compiler/ast/operators.oc	/^def Operator::needs_lhs_pointer_for_overload(this): bool => match this {$/;"	f
negate	$OCEN_ROOT/std/vec.oc	/^[operator "-"] def Vec3::negate(this): Vec3<T> => Vec3<T>(-.x, -.y, -.z)$/;"	f
new	$OCEN_ROOT/compiler/ast/nodes.oc	/^def Variable::new(type: &Type): &Variable {$/;"	f
new	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::new(): &Program {$/;"	f
new	$OCEN_ROOT/compiler/ast/scopes.oc	/^def TemplateInstance::new(args: &Vector<&Type>, parent: &Symbol, resolved: &Symbol): &TemplateIn/;"	f
new	$OCEN_ROOT/compiler/attributes.oc	/^def Attribute::new(type: AttributeType, span: Span): &Attribute {$/;"	f
new	$OCEN_ROOT/compiler/errors.oc	/^def Error::new(span: Span, msg: str): &Error {$/;"	f
new	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::new(program: &Program): &GenericPass {$/;"	f
new	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::new(program: &Program): &MarkDeadCode {$/;"	f
new	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::new(program: &Program): &ReorderSymbols {$/;"	f
new	$OCEN_ROOT/compiler/tokens.oc	/^def Token::new(type: TokenType, span: Span, text: str): &Token {$/;"	f
new	$OCEN_ROOT/std/bencode.oc	/^def Parser::new(input: Buffer): Parser {$/;"	f
new	$OCEN_ROOT/std/compact_map.oc	/^def Map::new(capacity: u32 = 16): &Map<K, V> {$/;"	f
new	$OCEN_ROOT/std/complex.oc	/^[extern "CMPLXF"] def Complex::new(real: f32, imag: f32): Complex$/;"	f
new	$OCEN_ROOT/std/deque.oc	/^def Deque::new(capacity: u32 = 16): &Deque<T> {$/;"	f
new	$OCEN_ROOT/std/disjoint_set.oc	/^def DisjointSet::new(): &DisjointSet<T> {$/;"	f
new	$OCEN_ROOT/std/heap.oc	/^def Heap::new(mode: Mode, capacity: u32 = 32): &Heap<T> {$/;"	f
new	$OCEN_ROOT/std/image/mod.oc	/^def Image::new(width: u32, height: u32): &Image {$/;"	f
new	$OCEN_ROOT/std/linkedlist.oc	/^def Node::new(val: T, next: &Node<T> = null, prev: &Node<T> = null): &Node<T> {$/;"	f
new	$OCEN_ROOT/std/map.oc	/^def Map::new(capacity: u32 = 8): &Map<K, V> {$/;"	f
new	$OCEN_ROOT/std/set.oc	/^def Set::new(): &Set<T> {$/;"	f
new	$OCEN_ROOT/std/value.oc	/^def Value::new(type: ValueType): &Value {$/;"	f
new	$OCEN_ROOT/std/vector.oc	/^def Vector::new(capacity: u32 = 16): &Vector<T> {$/;"	f
new_binop	$OCEN_ROOT/compiler/ast/nodes.oc	/^def AST::new_binop(op: Operator, lhs: &AST, rhs: &AST, op_span: Span): &AST {$/;"	f
new_bool	$OCEN_ROOT/std/value.oc	/^def Value::new_bool(bul: bool): &Value {$/;"	f
new_dict	$OCEN_ROOT/std/value.oc	/^def Value::new_dict(map: &Map<str, &Value>): &Value {$/;"	f
new_float	$OCEN_ROOT/std/value.oc	/^def Value::new_float(num: f64): &Value {$/;"	f
new_hint	$OCEN_ROOT/compiler/errors.oc	/^def Error::new_hint(span: Span, msg: str, span2: Span, hint: str): &Error {$/;"	f
new_int	$OCEN_ROOT/std/value.oc	/^def Value::new_int(num: i64): &Value {$/;"	f
new_list	$OCEN_ROOT/std/value.oc	/^def Value::new_list(vec: &Vector<&Value>): &Value {$/;"	f
new_note	$OCEN_ROOT/compiler/errors.oc	/^def Error::new_note(span: Span, msg: str, note: str): &Error {$/;"	f
new_resolved	$OCEN_ROOT/compiler/types.oc	/^def Type::new_resolved(base: BaseType, span: Span): &Type {$/;"	f
new_str	$OCEN_ROOT/std/buffer.oc	/^def Buffer::new_str(this): str => (.data as str).copy()$/;"	f
new_str	$OCEN_ROOT/std/value.oc	/^def Value::new_str(s: str): &Value {$/;"	f
new_str_buf	$OCEN_ROOT/std/value.oc	/^def Value::new_str_buf(buf: Buffer): &Value {$/;"	f
new_unop	$OCEN_ROOT/compiler/ast/nodes.oc	/^def AST::new_unop(op: Operator, span: Span, expr: &AST): &AST {$/;"	f
new_unresolved	$OCEN_ROOT/compiler/parser.oc	/^        sym.u.type_def = Type::new_unresolved(name, type.span)$/;"	f
new_unresolved	$OCEN_ROOT/compiler/types.oc	/^def Type::new_unresolved(name: str, span: Span): &Type {$/;"	f
new_unresolved_base	$OCEN_ROOT/compiler/types.oc	/^def Type::new_unresolved_base(base: BaseType, span: Span): &Type {$/;"	f
new_with_parent	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::new_with_parent(type: SymbolType, ns: &Namespace, parent: &Symbol, name: str, span: /;"	f
next	$OCEN_ROOT/compiler/ast/program.oc	/^def NSIterator::next(&this) {$/;"	f
next	$OCEN_ROOT/std/bitio.oc	/^def BitReader::next(&this) => .idx += 1/;"	f
next	$OCEN_ROOT/std/compact_map.oc	/^def ValueIterator::next(&this) { .iter.next() }$/;"	f
next	$OCEN_ROOT/std/fs.oc	/^def DirectoryIterator::next(&this) {$/;"	f
next	$OCEN_ROOT/std/linkedlist.oc	/^def Iterator::next(&this) {$/;"	f
next	$OCEN_ROOT/std/map.oc	/^def ValueIterator::next(&this) {$/;"	f
next	$OCEN_ROOT/std/mod.oc	/^def CharIterator::next(&this): u32 => .pos++$/;"	f
next	$OCEN_ROOT/std/set.oc	/^def Iterator::next(&this) {$/;"	f
next	$OCEN_ROOT/std/sv.oc	/^def SVWordIterator::next(&this) {}$/;"	f
next	$OCEN_ROOT/std/vector.oc	/^def Iterator::next(&this) {$/;"	f
next_power_of_2	$OCEN_ROOT/std/fft.oc	/^def next_power_of_2(x: u32): u32 {$/;"	f
normalized	$OCEN_ROOT/std/vec.oc	/^def Vec3::normalized(this): Vec3f {$/;"	f
ns	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::ns(&this): &Namespace {$/;"	f
nth_element	$OCEN_ROOT/std/sort.oc	/^def nth_element<T>(data: &T, size: u32, n: u32) => nth_element_by<T>(data, size, n, |a: T, b: T|/;"	f
nth_element_by	$OCEN_ROOT/std/sort.oc	/^def nth_element_by<T>(data: &T, size: u32, n: u32, cmp: @fn(T,T): i8): T {$/;"	f
ntohl	$OCEN_ROOT/std/socket.oc	/^    [extern] def ntohl(val: i32): i32$/;"	f
ntohs	$OCEN_ROOT/std/socket.oc	/^    [extern] def ntohs(val: i32): i32$/;"	f
num_fields	$OCEN_ROOT/compiler/ast/nodes.oc	/^def EnumVariant::num_fields(&this): u32 => .parent.shared_fields.size + .specific_fields.size$/;"	f
num_overload_params	$OCEN_ROOT/compiler/ast/operators.oc	/^def Operator::num_overload_params(this): u32 => match this {$/;"	f
number	$OCEN_ROOT/std/mui.oc	/^def Context::number(&this, value: &f32, step: f32, fmt: str = SLIDER_FMT, opt: Opt = AlignCenter/;"	f
number_textbox	$OCEN_ROOT/std/mui.oc	/^def Context::number_textbox(&this, value: &f32, r: Rect, id: u32): bool {$/;"	f
og_2_mui_key	$OCEN_ROOT/std/mui_og/mod.oc	/^def og_2_mui_key(key: og::Key): mui::Key => match key {$/;"	f
og_2_mui_key	$OCEN_ROOT/std/ogui/mod.oc	/^def og_2_mui_key(key: og::Key): mui::Key => match key {$/;"	f
og_main_fn	$OCEN_ROOT/std/og/mod.oc	/^    def og_main_fn(): bool {$/;"	f
only_chop_left	$OCEN_ROOT/std/sv.oc	/^def SV::only_chop_left(&this, n: u32 = 1) {$/;"	f
open	$OCEN_ROOT/std/fs.oc	/^def File::open(path: str, mode: str = "r"): &File {$/;"	f
open_audio	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_OpenAudio"] def open_audio(frequency: i32, format: u16, channels: i32, chunksize: i/;"	f
open_popup	$OCEN_ROOT/std/mui.oc	/^def Context::open_popup(&this, name: str) {$/;"	f
opendir	$OCEN_ROOT/compiler/utils.oc	/^[extern] def opendir(path: str): &DIR$/;"	f
opendir	$OCEN_ROOT/std/fs.oc	/^    [extern] def opendir(path: str): &Dir$/;"	f
out_name	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::out_name(&this): str {$/;"	f
overlaps_vec	$OCEN_ROOT/std/mui.oc	/^def Rect::overlaps_vec(this, other: Vec2i): bool {$/;"	f
paeth_predictor	$OCEN_ROOT/std/image/png.oc	/^def paeth_predictor(ua: u8, ub: u8, uc: u8): u8 {$/;"	f
pair_hash	$OCEN_ROOT/std/traits/hash.oc	/^def pair_hash(a: u32, b: u32): u32 => a * 33 ^ b$/;"	f
panic	$OCEN_ROOT/compiler/errors.oc	/^def Error::panic(&this) {$/;"	f
panic	$OCEN_ROOT/std/mod.oc	/^def panic(msg: str = "<panic>") {$/;"	f
parse	$OCEN_ROOT/std/argparse.oc	/^def Parser::parse(&this, argc: i32, argv: &str) {$/;"	f
parse	$OCEN_ROOT/std/bencode.oc	/^def parse(input: Buffer): &Value {$/;"	f
parse	$OCEN_ROOT/std/image/png.oc	/^def Chunk::parse(io: &BytesReader): Chunk {$/;"	f
parse	$OCEN_ROOT/std/json.oc	/^def parse(source: str, filename: str = "<anonymous>"): &Value {$/;"	f
parse_additive	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_additive(&this, end_type: TokenType): &AST {$/;"	f
parse_args	$OCEN_ROOT/compiler/main.oc	/^def parse_args(argc: &i32, argv: &&str, program: &Program) {$/;"	f
parse_array	$OCEN_ROOT/std/json.oc	/^def Parser::parse_array(&this): &Value {$/;"	f
parse_array_literal	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_array_literal(&this): &AST {$/;"	f
parse_atom	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_atom(&this, end_type: TokenType): &AST {$/;"	f
parse_attribute	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_attribute(&this) {$/;"	f
parse_attributes_if_any	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_attributes_if_any(&this) {$/;"	f
parse_block	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_block(&this): &AST {$/;"	f
parse_bw_and	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_bw_and(&this, end_type: TokenType): &AST {$/;"	f
parse_bw_or	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_bw_or(&this, end_type: TokenType): &AST {$/;"	f
parse_bw_xor	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_bw_xor(&this, end_type: TokenType): &AST {$/;"	f
parse_call	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_call(&this, callee: &AST): &AST {$/;"	f
parse_cast	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_cast(&this, end_type: TokenType): &AST {$/;"	f
parse_closure	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_closure(&this): &Function {$/;"	f
parse_compiler_option	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_compiler_option(&this) {$/;"	f
parse_dict	$OCEN_ROOT/std/bencode.oc	/^def Parser::parse_dict(&this): &Value {$/;"	f
parse_enum	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_enum(&this): &Enum {$/;"	f
parse_expression	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_expression(&this, end_type: TokenType): &AST {$/;"	f
parse_extern_into_symbol	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_extern_into_symbol(&this, sym: &Symbol) {$/;"	f
parse_file	$OCEN_ROOT/std/midi.oc	/^def parse_file(filename: str): MidiFile {$/;"	f
parse_for	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_for(&this): &AST {$/;"	f
parse_for_each	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_for_each(&this, start_span: Span): &AST {$/;"	f
parse_format_string	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_format_string(&this): &AST {$/;"	f
parse_from_file	$OCEN_ROOT/std/json.oc	/^def parse_from_file(filename: str): &Value {$/;"	f
parse_function	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_function(&this): &Function {$/;"	f
parse_function_args	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_function_args(&this, func: &Function, end: TokenType, need_types: bool = true)/;"	f
parse_function_body	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_function_body(&this, func: &Function): &AST {$/;"	f
parse_global_value	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_global_value(&this, is_const: bool): &AST {$/;"	f
parse_identifier	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_identifier(&this): &AST {$/;"	f
parse_if	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_if(&this): &AST {$/;"	f
parse_import	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_import(&this): &AST {$/;"	f
parse_import_path	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_import_path(&this, end_type: TokenType): &Vector<&ImportPart> {$/;"	f
parse_int	$OCEN_ROOT/std/bencode.oc	/^def Parser::parse_int(&this): &Value {$/;"	f
parse_int_internal	$OCEN_ROOT/std/bencode.oc	/^def Parser::parse_int_internal(&this): i64 {$/;"	f
parse_is	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_is(&this, end_type: TokenType): &AST {$/;"	f
parse_list	$OCEN_ROOT/std/bencode.oc	/^def Parser::parse_list(&this): &Value {$/;"	f
parse_literal_suffix_type	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_literal_suffix_type(&this, suffix: &Token): &Type {$/;"	f
parse_logical_and	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_logical_and(&this, end_type: TokenType): &AST {$/;"	f
parse_logical_not	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_logical_not(&this, end_type: TokenType): &AST {$/;"	f
parse_logical_or	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_logical_or(&this, end_type: TokenType): &AST {$/;"	f
parse_match	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_match(&this): &AST {$/;"	f
parse_match_case_conds	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_match_case_conds(&this, end_type: TokenType): &Vector<&MatchCond> {$/;"	f
parse_midi	$OCEN_ROOT/std/midi.oc	/^def Parser::parse_midi(&this, io: &BytesReader): MidiFile {$/;"	f
parse_multi_if	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_multi_if(&this, start_tok: &Token): &AST {$/;"	f
parse_namespace_until	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_namespace_until(&this, end_type: TokenType) {$/;"	f
parse_num_literal_float	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_num_literal_float(&this, text: str): f64 {$/;"	f
parse_num_literal_int	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_num_literal_int(&this, text: str): u64 {$/;"	f
parse_object	$OCEN_ROOT/std/json.oc	/^def Parser::parse_object(&this): &Value {$/;"	f
parse_postfix	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_postfix(&this, end_type: TokenType): &AST {$/;"	f
parse_prefix	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_prefix(&this, end_type: TokenType): &AST {$/;"	f
parse_relational	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_relational(&this, end_type: TokenType): &AST {$/;"	f
parse_scoped_identifier	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_scoped_identifier(&this, consume_template: bool = true): &AST {$/;"	f
parse_shift	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_shift(&this, end_type: TokenType): &AST {$/;"	f
parse_statement	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_statement(&this): &AST {$/;"	f
parse_string	$OCEN_ROOT/std/bencode.oc	/^def Parser::parse_string(&this): &Value {$/;"	f
parse_string_hash	$OCEN_ROOT/std/hash/sha1.oc	/^def SHA1Hash::parse_string_hash(hash_str: str): SHA1Hash {$/;"	f
parse_string_internal	$OCEN_ROOT/std/bencode.oc	/^def Parser::parse_string_internal(&this): Buffer {$/;"	f
parse_struct	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_struct(&this): &Structure {$/;"	f
parse_struct_field	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_struct_field(&this, struc: &Structure): bool {$/;"	f
parse_sv	$OCEN_ROOT/std/json.oc	/^def parse_sv(source: SV, filename: str = "<anonymous>"): &Value {$/;"	f
parse_template_params	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_template_params(&this, sym: &Symbol, out_span: &Span = null) {$/;"	f
parse_term	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_term(&this, end_type: TokenType): &AST {$/;"	f
parse_toplevel	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_toplevel(program: &Program, filename: str, file_contents: str = null, include_/;"	f
parse_track	$OCEN_ROOT/std/midi.oc	/^def Parser::parse_track(&this, io: &BytesReader): Track {$/;"	f
parse_type	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_type(&this): &Type => match .token().type {$/;"	f
parse_value	$OCEN_ROOT/std/json.oc	/^def Parser::parse_value(&this): &Value => match .token().type {$/;"	f
parse_var_declaration	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_var_declaration(&this): &AST {$/;"	f
parse_var_initializer	$OCEN_ROOT/compiler/parser.oc	/^def Parser::parse_var_initializer(&this): &AST {$/;"	f
partition	$OCEN_ROOT/std/sort.oc	/^def partition<T>(data: &T, size: u32) => partition_by<T>(data, size, T::compare)$/;"	f
partition_by	$OCEN_ROOT/std/sort.oc	/^def partition_by<T>(data: &T, size: u32, cmp: fn(T): bool): u32 {$/;"	f
partition_by_closure	$OCEN_ROOT/std/sort.oc	/^def partition_by_closure<T>(data: &T, size: u32, cmp: @fn(T): bool): u32 {$/;"	f
pause	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_Pause"] def pause(channel: i32)$/;"	f
peek	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::peek(&this, offset: u32 = 1): char {$/;"	f
peek	$OCEN_ROOT/compiler/parser.oc	/^def Parser::peek(&this, off: i32 = 1): &Token {$/;"	f
peek	$OCEN_ROOT/std/heap.oc	/^def Heap::peek(&this): T {$/;"	f
peek_token_is	$OCEN_ROOT/compiler/parser.oc	/^def Parser::peek_token_is(&this, off: u32, type: TokenType): bool {$/;"	f
pipe	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def pipe(fds: &i32): i32$/;"	f
play_channel	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_PlayChannel"] def play_channel(channel: i32, chunk: &Sound, loops: i32): i32$/;"	f
poll_event	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_PollEvent"]        def poll_event(event: &Event): bool$/;"	f
pool_get	$OCEN_ROOT/std/mui.oc	/^def Context::pool_get(&this, items: &PoolItem, len: i32, id: u32): i32 {$/;"	f
pool_init	$OCEN_ROOT/std/mui.oc	/^def Context::pool_init(&this, items: &PoolItem, len: i32, id: u32): i32 {$/;"	f
pool_update	$OCEN_ROOT/std/mui.oc	/^def Context::pool_update(&this, items: &PoolItem, idx: i32) => items[idx].last_update = .frame$/;"	f
pop	$OCEN_ROOT/std/heap.oc	/^def Heap::pop(&this): T {$/;"	f
pop	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::pop(&this): T {$/;"	f
pop	$OCEN_ROOT/std/vector.oc	/^def Vector::pop(&this): T {$/;"	f
pop_at	$OCEN_ROOT/std/vector.oc	/^def Vector::pop_at(&this, i: u32): T {$/;"	f
pop_back	$OCEN_ROOT/std/deque.oc	/^def Deque::pop_back(&this): T {$/;"	f
pop_clip_rect	$OCEN_ROOT/std/mui.oc	/^def Context::pop_clip_rect(&this): Rect {$/;"	f
pop_container	$OCEN_ROOT/std/mui.oc	/^def Context::pop_container(&this) {$/;"	f
pop_error_context	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::pop_error_context(&this) {$/;"	f
pop_front	$OCEN_ROOT/std/deque.oc	/^def Deque::pop_front(&this): T {$/;"	f
pop_front	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::pop_front(&this): T {$/;"	f
pop_id	$OCEN_ROOT/std/mui.oc	/^def Context::pop_id(&this): u32 => .id_stack.pop()$/;"	f
pop_namespace	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::pop_namespace(&this): &Namespace {$/;"	f
pop_scope	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::pop_scope(&this): &Scope {$/;"	f
pos	$OCEN_ROOT/std/mui.oc	/^def Rect::pos(this): Vec2i => Vec2i(.x, .y)$/;"	f
pow	$OCEN_ROOT/std/math.oc	/^[extern "powf"] def f32::pow(this, exp: f32): f32$/;"	f
pre_check_function	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::pre_check_function(&this, ns: &Namespace, func: &Function) {$/;"	f
pre_check_globals	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::pre_check_globals(&this, node: &AST, is_const: bool) {$/;"	f
present	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RenderPresent"]   def Renderer::present(&this)$/;"	f
print	$OCEN_ROOT/std/huffman.oc	/^def HuffmanCodes::print(&this) {$/;"	f
print	$OCEN_ROOT/std/sv.oc	/^def SV::print(&this, msg: str=null) {$/;"	f
print_indent	$OCEN_ROOT/compiler/passes/namespace_dump.oc	/^def NamespaceDump::print_indent(&this) {$/;"	f
print_namespace	$OCEN_ROOT/compiler/passes/namespace_dump.oc	/^def NamespaceDump::print_namespace(&this, ns: &Namespace) {$/;"	f
print_stats	$OCEN_ROOT/std/gc.oc	/^def print_stats() {$/;"	f
print_test_stats	$OCEN_ROOT/std/testing.oc	/^def print_test_stats() {$/;"	f
ptr_hash	$OCEN_ROOT/std/traits/hash.oc	/^def ptr_hash(ptr: untyped_ptr): u32 => (ptr as u64).hash()$/;"	f
push	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::push(&this, token: &Token) {$/;"	f
push	$OCEN_ROOT/std/heap.oc	/^def Heap::push(&this, value: T) {$/;"	f
push	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::push(&this, val: T): &Node<T> {$/;"	f
push	$OCEN_ROOT/std/value.oc	/^def Value::push(&this, value: &Value) {$/;"	f
push	$OCEN_ROOT/std/vector.oc	/^def Vector::push(&this, value: T) {$/;"	f
push_back	$OCEN_ROOT/std/deque.oc	/^def Deque::push_back(&this, value: T) {$/;"	f
push_bool	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_bool(&this, b: bool) => .push(Value::new_bool(b))$/;"	f
push_clip_rect	$OCEN_ROOT/std/mui.oc	/^def Context::push_clip_rect(&this, rect: Rect) {$/;"	f
push_container_body	$OCEN_ROOT/std/mui.oc	/^def Context::push_container_body(&this, cnt: &Container, body: Rect, opt: Opt) {$/;"	f
push_f32	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_f32(&this, f: f32) => .push(Value::new_float(f as f64))$/;"	f
push_f64	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_f64(&this, f: f64) => .push(Value::new_float(f))$/;"	f
push_front	$OCEN_ROOT/std/deque.oc	/^def Deque::push_front(&this, value: T) {$/;"	f
push_front	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::push_front(&this, val: T): &Node<T> {$/;"	f
push_front	$OCEN_ROOT/std/vector.oc	/^def Vector::push_front(&this, value: T) {$/;"	f
push_i32	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_i32(&this, i: i32) => .push(Value::new_int(i as i64))$/;"	f
push_i64	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_i64(&this, i: i64) => .push(Value::new_int(i))$/;"	f
push_id	$OCEN_ROOT/std/mui.oc	/^def Context::push_id(&this, data: untyped_ptr, size: u32) => .id_stack.push(.get_id(data, size))$/;"	f
push_layout	$OCEN_ROOT/std/mui.oc	/^def Context::push_layout(&this, body: Rect, scroll: Vec2i) {$/;"	f
push_namespace	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::push_namespace(&this, ns: &Namespace) {$/;"	f
push_scope	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::push_scope(&this, scope: &Scope) {$/;"	f
push_str	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_str(&this, s: str) => .push(Value::new_str(s))$/;"	f
push_type	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::push_type(&this, type: TokenType, len: u32 = 1) {$/;"	f
push_u32	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_u32(&this, i: u32) => .push(Value::new_int(i as i64))$/;"	f
push_u64	$OCEN_ROOT/std/value.oc	/^[operator "+="] def Value::push_u64(&this, i: u64) => .push(Value::new_int(i as i64))$/;"	f
puts	$OCEN_ROOT/std/fs.oc	/^def File::puts(&this, s: str) {$/;"	f
query	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_QueryTexture"]   def Texture::query(&this, a: untyped_ptr, b: untyped_ptr, w: &i32,/;"	f
quit	$OCEN_ROOT/std/og/mod.oc	/^def quit() {$/;"	f
quit	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_Quit"] def quit()$/;"	f
quit	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_Quit"]                    def quit()$/;"	f
quit	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_Quit"]     def quit(): i32$/;"	f
radians	$OCEN_ROOT/std/math.oc	/^def radians(degrees: f32): f32 { return degrees * PI \/ 180.0; }$/;"	f
rand	$OCEN_ROOT/std/random.oc	/^    [extern] def rand(): u32$/;"	f
rand01	$OCEN_ROOT/std/math.oc	/^[extern "drand48"] def rand01(): f32$/;"	f
randf32	$OCEN_ROOT/std/random.oc	/^def randf32(state: &RandomState=null): f32 => (randint(state) as f32) \/ 4294967296.0$/;"	f
randf64	$OCEN_ROOT/std/random.oc	/^def randf64(state: &RandomState=null): f64 => (randint(state) as f64) \/ 4294967296.0$/;"	f
randi32	$OCEN_ROOT/std/random.oc	/^def randi32(state: &RandomState=null): i32 => (randint(state) as i32)$/;"	f
randint	$OCEN_ROOT/std/math.oc	/^[extern "rand"] def randint(): i32$/;"	f
randint	$OCEN_ROOT/std/random.oc	/^def randint(state: &RandomState=null): u32 {$/;"	f
randu32	$OCEN_ROOT/std/random.oc	/^def randu32(state: &RandomState=null): u32 => randint(state)$/;"	f
randu64	$OCEN_ROOT/std/random.oc	/^def randu64(state: &RandomState=null): u64 => (randint(state) as u64) << 32 | randint(state) as /;"	f
read	$OCEN_ROOT/std/fs.oc	/^def File::read(&this, buf: untyped_ptr, size: u32): i32 {$/;"	f
read	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def read(a: i32, b: untyped_ptr, c: u32): i32$/;"	f
read	$OCEN_ROOT/std/socket.oc	/^def TcpStream::read(&this, buf: &Buffer): u32 {$/;"	f
read_bit	$OCEN_ROOT/std/bitio.oc	/^def BitReader::read_bit(&this): u8 {$/;"	f
read_bytes	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_bytes(&this, _dst: untyped_ptr, count: u32) {$/;"	f
read_bytes_sv	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_bytes_sv(&this, count: u32): SV {$/;"	f
read_char	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_char(&this): char {$/;"	f
read_exactly	$OCEN_ROOT/std/socket.oc	/^def Socket::read_exactly(&this, buf: &Buffer, size: u32): u32 {$/;"	f
read_file	$OCEN_ROOT/std/fs.oc	/^def read_file(path: str): Buffer {$/;"	f
read_file_inc	$OCEN_ROOT/std/fs.oc	/^def read_file_inc(path: str): Buffer {$/;"	f
read_i16	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_i16(&this, endian: Endian = Big): i16 { return .read_u16(endian) as i16 }$/;"	f
read_i32	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_i32(&this, endian: Endian = Big): i32 { return .read_u32(endian) as i32 }$/;"	f
read_i64	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_i64(&this, endian: Endian = Big): i64 { return .read_u64(endian) as i64 }$/;"	f
read_i8	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_i8(&this): i8 { return .read_u8() as i8 }$/;"	f
read_message	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def read_message(): str {$/;"	f
read_u16	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_u16(&this, endian: Endian = Big): u16 {$/;"	f
read_u32	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_u32(&this, endian: Endian = Big): u32 {$/;"	f
read_u64	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_u64(&this, endian: Endian = Big): u64 {$/;"	f
read_u8	$OCEN_ROOT/std/bitio.oc	/^def BitReader::read_u8(&this): u8 {$/;"	f
read_u8	$OCEN_ROOT/std/buffer.oc	/^def BytesReader::read_u8(&this): u8 {$/;"	f
read_var_length	$OCEN_ROOT/std/midi.oc	/^def read_var_length(io: &BytesReader): u32 {$/;"	f
readdir	$OCEN_ROOT/std/fs.oc	/^    [extern] def readdir(dir: &Dir): &dirent$/;"	f
reader	$OCEN_ROOT/std/buffer.oc	/^def Buffer::reader(this): BytesReader => BytesReader::make(.data, .size)$/;"	f
reader	$OCEN_ROOT/std/sv.oc	/^def SV::reader(this): BytesReader => BytesReader::make(.data as &u8, .len)$/;"	f
real	$OCEN_ROOT/std/complex.oc	/^[extern "crealf"] def Complex::real(this): f32$/;"	f
realloc	$OCEN_ROOT/std/mem.oc	/^def realloc<T>(ptr: &T, old_count: u32, new_count: u32): &T {$/;"	f
realpath	$OCEN_ROOT/std/fs.oc	/^def realpath(path: str): str {$/;"	f
recv_from	$OCEN_ROOT/std/socket.oc	/^def UdpSocket::recv_from(&this, buf: &Buffer, max_size: u32 = 65535): Result<&RecvFromResult, So/;"	f
recvfrom	$OCEN_ROOT/std/socket.oc	/^def Socket::recvfrom(&this, buf: &Buffer, max_size: u32): Result<&RecvFromResult, SocketStatus> /;"	f
reflect	$OCEN_ROOT/std/vec.oc	/^def Vec3::reflect(this, normal: Vec3<T>): Vec3<T> => .sub(normal.mults(2 as T * .dot(normal)))$/;"	f
register_alias	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_alias(&this, name: str, orig: &Type) {$/;"	f
register_base_type	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_base_type(&this, base: BaseType) {$/;"	f
register_builtin_types	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_builtin_types(&this) {$/;"	f
register_cached_types	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_cached_types(&this) {$/;"	f
register_enum	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_enum(&this, ns: &Namespace, enum_: &Enum) {$/;"	f
register_globals	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_globals(&this, node: &AST) {$/;"	f
register_namespace	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_namespace(&this, ns: &Namespace) {$/;"	f
register_print_function	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_print_function(&this, name: str) {$/;"	f
register_struct	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::register_struct(&this, ns: &Namespace, struc: &Structure) {$/;"	f
remove	$OCEN_ROOT/std/compact_map.oc	/^def Map::remove(&this, key: K) {$/;"	f
remove	$OCEN_ROOT/std/fs.oc	/^def remove(path: str) {$/;"	f
remove	$OCEN_ROOT/std/map.oc	/^def Map::remove(&this, key: K) {$/;"	f
remove	$OCEN_ROOT/std/set.oc	/^def Set::remove(&this, key: T) {$/;"	f
remove_alias	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::remove_alias(&this): &Symbol => match .type {$/;"	f
remove_last_n	$OCEN_ROOT/std/mod.oc	/^def str::remove_last_n(this, n: u32) {$/;"	f
remove_node	$OCEN_ROOT/std/linkedlist.oc	/^def LinkedList::remove_node(&this, node: &Node<T>) {$/;"	f
rename	$OCEN_ROOT/std/fs.oc	/^def rename(old_filename: str, new_filename: str) {$/;"	f
render_solid	$OCEN_ROOT/std/sdl/ttf.oc	/^[extern "TTF_RenderText_Solid"] def Font::render_solid(&this, text: str, color: Color): &Surface$/;"	f
reorder_structs	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::reorder_structs(&this) {$/;"	f
replace	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def str::replace(&this, other: str) {$/;"	f
replace_with	$OCEN_ROOT/std/mod.oc	/^def str::replace_with(&this, other: str) {$/;"	f
reset_to_default_allocator	$OCEN_ROOT/std/mem.oc	/^def reset_to_default_allocator() {$/;"	f
resize	$OCEN_ROOT/std/compact_map.oc	/^def Map::resize(&this, new_capacity: u32) {$/;"	f
resize	$OCEN_ROOT/std/deque.oc	/^def Deque::resize(&this, new_capacity: u32) {$/;"	f
resize	$OCEN_ROOT/std/image/mod.oc	/^def Image::resize(&this, new_width: u32, new_height: u32): &Image {$/;"	f
resize	$OCEN_ROOT/std/map.oc	/^def Map::resize(&this) {$/;"	f
resize	$OCEN_ROOT/std/vector.oc	/^def Vector::resize(&this, new_capacity: u32) {$/;"	f
resize_if_necessary	$OCEN_ROOT/std/buffer.oc	/^def Buffer::resize_if_necessary(&this, new_size: u32) {$/;"	f
resize_if_necessary	$OCEN_ROOT/std/compact_map.oc	/^def Map::resize_if_necessary(&this) {$/;"	f
resolve_doc_links	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_doc_links(&this, sym: &Symbol) {$/;"	f
resolve_enum	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_enum(&this, enom: &Enum) {$/;"	f
resolve_scoped_identifier	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_scoped_identifier(&this, node: &AST, error: bool = true, hint: &Type = /;"	f
resolve_struct	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_struct(&this, struc: &Structure) {$/;"	f
resolve_templated_enum	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_templated_enum(&this, enom: &Enum, instance: &TemplateInstance) {$/;"	f
resolve_templated_function	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_templated_function(&this, func: &Function, instance: &TemplateInstance)/;"	f
resolve_templated_methods	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_templated_methods(&this, old_type: &Type, cur_type: &Type) {$/;"	f
resolve_templated_struct	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_templated_struct(&this, struc: &Structure, instance: &TemplateInstance)/;"	f
resolve_templated_symbol	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_templated_symbol(&this, sym: &Symbol, template_args: &Vector<&Type>, sp/;"	f
resolve_type	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::resolve_type($/;"	f
restore	$OCEN_ROOT/std/bump_alloc.oc	/^def restore(new_cursor: u64) => cursor = new_cursor/;"	f
restore	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_RestoreWindow"]  def Window::restore(&this)$/;"	f
resume	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_Resume"] def resume(channel: i32)$/;"	f
rgb_to_hsv	$OCEN_ROOT/std/mui.oc	/^def rgb_to_hsv(color: Color): HSV {$/;"	f
rotate	$OCEN_ROOT/std/image/mod.oc	/^def Image::rotate(&this, dir: RotationDirection = RotationDirection::Clockwise): &Image {$/;"	f
rotate	$OCEN_ROOT/std/vec.oc	/^def Vec2::rotate(&this, angle: f32): Vec2f {$/;"	f
rotateX	$OCEN_ROOT/std/vec.oc	/^def Vec3::rotateX(this, angle: f32): Vec3f {$/;"	f
rotateY	$OCEN_ROOT/std/vec.oc	/^def Vec3::rotateY(this, angle: f32): Vec3f {$/;"	f
rotateZ	$OCEN_ROOT/std/vec.oc	/^def Vec3::rotateZ(this, angle: f32): Vec3f {$/;"	f
rotate_axis	$OCEN_ROOT/std/vec.oc	/^def Vec3::rotate_axis(this, axis: Vec3f, angle: f32): Vec3f {$/;"	f
rotate_left	$OCEN_ROOT/std/hash/utils.oc	/^def rotate_left(value: u32, bits: u32): u32 {$/;"	f
rotate_right	$OCEN_ROOT/std/hash/utils.oc	/^def rotate_right(value: u32, bits: u32): u32 {$/;"	f
rotation_matrix_for	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::rotation_matrix_for(vec: Vec3f): Matrix4f {$/;"	f
run	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::run(program: &Program): str {$/;"	f
run	$OCEN_ROOT/compiler/passes/mark_dead_code.oc	/^def MarkDeadCode::run(program: &Program) {$/;"	f
run	$OCEN_ROOT/compiler/passes/namespace_dump.oc	/^def NamespaceDump::run(program: &Program) {$/;"	f
run	$OCEN_ROOT/compiler/passes/register_types.oc	/^def RegisterTypes::run(program: &Program) {$/;"	f
run	$OCEN_ROOT/compiler/passes/reorder_symbols.oc	/^def ReorderSymbols::run(program: &Program) {$/;"	f
run	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::run(program: &Program) {$/;"	f
run	$OCEN_ROOT/std/huffman.oc	/^def Decompressor::run(&this, cur: u16) {$/;"	f
run_codegen_passes	$OCEN_ROOT/compiler/passes/mod.oc	/^def run_codegen_passes(program: &Program): str {$/;"	f
run_executable	$OCEN_ROOT/compiler/main.oc	/^def run_executable(argc: i32, argv: &str) {$/;"	f
run_lsp_backend	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::run_lsp_backend($/;"	f
run_lsp_backend_raw	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::run_lsp_backend_raw($/;"	f
run_main_loop	$OCEN_ROOT/std/sdl/mod.oc	/^def run_main_loop(callback: @fn(): bool) {$/;"	f
run_test	$OCEN_ROOT/std/testing.oc	/^def run_test(func: fn(), test_name: str) {$/;"	f
run_typecheck_passes	$OCEN_ROOT/compiler/passes/mod.oc	/^def run_typecheck_passes(program: &Program) {$/;"	f
save	$OCEN_ROOT/std/image/mod.oc	/^def Image::save(&this, filename: str) {$/;"	f
save_and_compile_code	$OCEN_ROOT/compiler/main.oc	/^def save_and_compile_code(program: &Program, code: str) {$/;"	f
save_val	$OCEN_ROOT/std/argparse.oc	/^def Arg::save_val(&this, s: str) {$/;"	f
scale	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::scale(this, t: f32): Matrix4f {$/;"	f
scope	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def CodeGenerator::scope(&this): &Scope => .o.scope()$/;"	f
scope	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::scope(&this): &Scope {$/;"	f
scope	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::scope(&this): &Scope => .o.scope()$/;"	f
scrollbar_x	$OCEN_ROOT/std/mui.oc	/^def Context::scrollbar_x(&this, cnt: &Container, body: &Rect, cs: Vec2i) {$/;"	f
scrollbar_y	$OCEN_ROOT/std/mui.oc	/^def Context::scrollbar_y(&this, cnt: &Container, body: &Rect, cs: Vec2i) {$/;"	f
scrollbars	$OCEN_ROOT/std/mui.oc	/^def Context::scrollbars(&this, cnt: &Container, body: &Rect) {$/;"	f
seed	$OCEN_ROOT/std/random.oc	/^def RandomState::seed(&this, s: u32) {$/;"	f
seek	$OCEN_ROOT/std/fs.oc	/^def File::seek(&this, offset: i64, mode: SeekMode) {$/;"	f
select	$OCEN_ROOT/std/fcntl.oc	/^[extern "select"] def select(nfds: i32, readfds: &FdSet, writefds: &FdSet, exceptfds: &FdSet, ti/;"	f
send_frame	$OCEN_ROOT/std/video_renderer/ffmpeg.oc	/^def FFMPEGContext::send_frame(&this, img: &Image): bool {$/;"	f
send_frame	$OCEN_ROOT/std/video_renderer/mod.oc	/^def VideoRenderer::send_frame(&this, img: &Image) {$/;"	f
send_frame	$OCEN_ROOT/std/video_renderer/sdl.oc	/^def SDLContext::send_frame(&this, img: &Image) {$/;"	f
send_message	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def send_message(content: &Value) {$/;"	f
send_response	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def send_response(req: &Value, result: &Value) {$/;"	f
send_to	$OCEN_ROOT/std/socket.oc	/^def UdpSocket::send_to(&this, buf: &Buffer, target: str): Result<i64, SocketStatus> {$/;"	f
sendto	$OCEN_ROOT/std/socket.oc	/^def Socket::sendto(&this, buf: &Buffer, host: str, port: i32): i64 {$/;"	f
serialize	$OCEN_ROOT/std/bencode.oc	/^def serialize(val: &Value): Buffer {$/;"	f
serialize	$OCEN_ROOT/std/json.oc	/^def serialize(val: &Value): Buffer {$/;"	f
serialize_bits	$OCEN_ROOT/std/huffman.oc	/^def HuffmanTree::serialize_bits(&this, bio: &BitWriter, cur: u16) {$/;"	f
serialize_into	$OCEN_ROOT/std/bencode.oc	/^def serialize_into(val: &Value, sb: &Buffer) {$/;"	f
serialize_into	$OCEN_ROOT/std/json.oc	/^def serialize_into(val: &Value, sb: &Buffer) {$/;"	f
set	$OCEN_ROOT/std/fcntl.oc	/^def FdSet::set(&this, fd: i32) => c_FD_SET(fd, this)$/;"	f
set	$OCEN_ROOT/std/huffman.oc	/^def CharCode::set(&this, idx: u32, bit: u8) {$/;"	f
set	$OCEN_ROOT/std/image/mod.oc	/^def Image::set(&this, x: u32, y: u32, col: Color) { .data[y * .width + x] = col }$/;"	f
set	$OCEN_ROOT/std/value.oc	/^def Value::set(&this, idx: u32, value: &Value) {$/;"	f
set	$OCEN_ROOT/std/vector.oc	/^def Vector::set(&this, i: u32, val: T) {$/;"	f
set_allocator	$OCEN_ROOT/std/mem.oc	/^def set_allocator($/;"	f
set_attr	$OCEN_ROOT/std/thread.oc	/^def Thread::set_attr(&this,stack_size:u64,dstate:DetachState,policy:SchedPolicy){$/;"	f
set_blend_mode	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetRenderDrawBlendMode"]   def Renderer::set_blend_mode(&this, blend: BlendMode)$/;"	f
set_bool	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_bool(&this, idx: u32, b: bool) => .set(idx, Value::new_bool(b))$/;"	f
set_clip	$OCEN_ROOT/std/mui.oc	/^def Context::set_clip(&this, rect: Rect) {$/;"	f
set_cursor	$OCEN_ROOT/std/og/mod.oc	/^def set_cursor(c: sdl::CursorType) {$/;"	f
set_cursor	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetCursor"]          def set_cursor(cursor: &Cursor)$/;"	f
set_detach_state	$OCEN_ROOT/std/thread.oc	/^def Thread::set_detach_state(&this, dstate: DetachState = Detached) {$/;"	f
set_draw_color	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetRenderDrawColor"]       def Renderer::set_draw_color(&this, r: i32, g: i32, b: i/;"	f
set_f32	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_f32(&this, idx: u32, f: f32) => .set(idx, Value::new_float(f as /;"	f
set_f64	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_f64(&this, idx: u32, f: f64) => .set(idx, Value::new_float(f))$/;"	f
set_focus	$OCEN_ROOT/std/mui.oc	/^def Context::set_focus(&this, id: u32) {$/;"	f
set_fullscreen	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetWindowFullscreen"]     def Window::set_fullscreen(&this, fullscreen: i32): i32$/;"	f
set_global	$OCEN_ROOT/std/gc.oc	/^def set_global(ptr: untyped_ptr): untyped_ptr {$/;"	f
set_hint	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetHint"] def set_hint(hint: str, value: str): bool$/;"	f
set_i32	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_i32(&this, idx: u32, i: i32) => .set(idx, Value::new_int(i as i6/;"	f
set_i64	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_i64(&this, idx: u32, i: i64) => .set(idx, Value::new_int(i))$/;"	f
set_jump_point	$OCEN_ROOT/std/setjmp.oc	/^def ErrorContext::set_jump_point(this): i32$/;"	f
set_main_loop	$OCEN_ROOT/std/og/mod.oc	/^def set_main_loop(callback: fn(): bool) {$/;"	f
set_mode	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetWindowFullscreen"] def Window::set_mode(&this, mode: WindowMode)$/;"	f
set_position	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetWindowPosition"]       def Window::set_position(&this, x: i32, y: i32)$/;"	f
set_relative_mouse_mode	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetRelativeMouseMode"] def set_relative_mouse_mode(enabled: bool)$/;"	f
set_resizable	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetWindowResizable"]  def Window::set_resizable(&this, resizable: bool)$/;"	f
set_resolved_symbol	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::set_resolved_symbol(&this, node: &AST, sym: &Symbol) {$/;"	f
set_sched_policy	$OCEN_ROOT/std/thread.oc	/^def Thread::set_sched_policy(&this, policy: SchedPolicy) {$/;"	f
set_signal_handler	$OCEN_ROOT/std/signal.oc	/^def set_signal_handler(sig: Signal, callback: fn(i32)) {$/;"	f
set_size	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetWindowSize"]  def Window::set_size(&this, w: i32, h: i32)$/;"	f
set_stack	$OCEN_ROOT/std/thread.oc	/^def Thread::set_stack(&this, stack_size: u64) {$/;"	f
set_str	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_str(&this, idx: u32, s: str) => .set(idx, Value::new_str(s))$/;"	f
set_title	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_SetWindowTitle"]           def Window::set_title(&this, title: str)$/;"	f
set_u32	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_u32(&this, idx: u32, i: u32) => .set(idx, Value::new_int(i as i6/;"	f
set_u64	$OCEN_ROOT/std/value.oc	/^[operator "[]="] def Value::set_u64(&this, idx: u32, i: u64) => .set(idx, Value::new_int(i as i6/;"	f
set_usage	$OCEN_ROOT/compiler/lsp/cli/finder.oc	/^def Finder::set_usage(&this, sym: &Symbol, node: &AST): bool {$/;"	f
setdetachstate	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_attr_setdetachstate"] def ThreadAttr::setdetachstate(&this, detachstate: De/;"	f
setschedpolicy	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_attr_setschedpolicy"] def ThreadAttr::setschedpolicy(&this, policy: SchedPo/;"	f
setsockopt	$OCEN_ROOT/std/socket.oc	/^    [extern] def setsockopt(sockfd: i32, level: i32, optname: i32, optval: untyped_ptr, optlen: /;"	f
setstacksize	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_attr_setstacksize"]   def ThreadAttr::setstacksize(&this, tack_size:u64): i/;"	f
settype	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_mutexattr_settype"] def MutexAttr::settype(&this, tty: MutexMode): i32$/;"	f
setup_from_node	$OCEN_ROOT/std/huffman.oc	/^def HuffmanCodes::setup_from_node(&this, tree: &HuffmanTree, cur: u16, code: CharCode, idx: u32)/;"	f
setup_library_paths	$OCEN_ROOT/compiler/ast/program.oc	/^def Program::setup_library_paths(&this) {$/;"	f
setvbuf	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^[extern] def setvbuf(file: &fs::File, buffer: str, mode: i32, size: u64): i32$/;"	f
shallow_copy	$OCEN_ROOT/compiler/types.oc	/^def Type::shallow_copy(old: &Type): &Type {$/;"	f
shift_args	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def shift_args(argc: &i32, argv: &&str): str {$/;"	f
shift_args	$OCEN_ROOT/std/mod.oc	/^def shift_args(argc: &i32, argv: &&str, where: str = "here"): str {$/;"	f
should_swap	$OCEN_ROOT/std/heap.oc	/^def Heap::should_swap(&this, a: u32, b: u32): bool {$/;"	f
show_cursor	$OCEN_ROOT/std/og/mod.oc	/^def show_cursor(show: bool) => sdl::show_cursor(show)$/;"	f
show_cursor	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_ShowCursor"]              def show_cursor(toggle: bool)$/;"	f
shutdown	$OCEN_ROOT/std/gc.oc	/^def shutdown() {$/;"	f
sift_down	$OCEN_ROOT/std/heap.oc	/^def Heap::sift_down(&this, i: u32 = 0) {$/;"	f
sift_up	$OCEN_ROOT/std/heap.oc	/^def Heap::sift_up(&this, i: u32) {$/;"	f
sig0	$OCEN_ROOT/std/hash/sha256.oc	/^    def sig0(x: u32): u32 => rotate_right(x, 7) ^ rotate_right(x, 18) ^ (x >> 3)$/;"	f
sig1	$OCEN_ROOT/std/hash/sha256.oc	/^    def sig1(x: u32): u32 => rotate_right(x, 17) ^ rotate_right(x, 19) ^ (x >> 10)$/;"	f
sigaction	$OCEN_ROOT/std/signal.oc	/^def sigaction(sig: Signal, act: &SigAction, oldact: &SigAction = null): i32$/;"	f
signal	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_cond_signal"] def Cond::signal(&this): i32$/;"	f
signal_handler	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def signal_handler(sig: i32) {$/;"	f
signal_handler	$OCEN_ROOT/compiler/main.oc	/^def signal_handler(sig: i32) {$/;"	f
sin	$OCEN_ROOT/std/complex.oc	/^[extern "csinf"] def Complex::sin(this): Complex$/;"	f
sin	$OCEN_ROOT/std/math.oc	/^[extern "sinf"] def f32::sin(this): f32$/;"	f
size	$OCEN_ROOT/std/compact_map.oc	/^def Map::size(&this): u32 => .items.size$/;"	f
size	$OCEN_ROOT/std/fs.oc	/^def File::size(&this): u32 {$/;"	f
size	$OCEN_ROOT/std/heap.oc	/^def Heap::size(&this): u32 => .vec.size$/;"	f
size	$OCEN_ROOT/std/mui.oc	/^def Rect::size(this): Vec2i => Vec2i(.width, .height)$/;"	f
skip	$OCEN_ROOT/std/sv.oc	/^def SV::skip(this, n: u32): SV {$/;"	f
sleep	$OCEN_ROOT/std/thread.oc	/^[extern "sleep"]         def sleep(seconds: u32)$/;"	f
slice	$OCEN_ROOT/std/sv.oc	/^def SV::slice(this, off: u32, end: u32 = 0): SV {$/;"	f
slider	$OCEN_ROOT/std/mui.oc	/^def Context::slider(&this, value: &f32, low: f32, high: f32, step: f32 = 0.0, fmt: str = SLIDER_/;"	f
snapshot	$OCEN_ROOT/std/bump_alloc.oc	/^def snapshot(): u64 => cursor$/;"	f
snprintf	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def snprintf(buf: str, size: u32, fmt: str, ...): i32$/;"	f
sockaddr_in	$OCEN_ROOT/std/socket.oc	/^    [extern "struct sockaddr_in"]$/;"	f
socket	$OCEN_ROOT/std/socket.oc	/^    [extern] def socket(domain: i32, type: i32, protocol: i32): i32$/;"	f
sort	$OCEN_ROOT/std/heap.oc	/^def Heap::sort(&this) {$/;"	f
sort	$OCEN_ROOT/std/sort.oc	/^def sort<T>(data: &T, size: u32) => sort_by<T>(data, size, |a: T, b: T|: i8 => a.compare(b))$/;"	f
sort_by	$OCEN_ROOT/std/sort.oc	/^def sort_by<T>(data: &T, size: u32, cmp: @fn(T,T): i8) {$/;"	f
split_str	$OCEN_ROOT/std/sv.oc	/^def SV::split_str(this, delim: str): SVSplitIterator => SVSplitIterator(this, SV::from_str(delim/;"	f
split_sv	$OCEN_ROOT/std/sv.oc	/^def SV::split_sv(this, delim: SV): SVSplitIterator => SVSplitIterator(this, delim)$/;"	f
split_words	$OCEN_ROOT/std/sv.oc	/^def SV::split_words(this): SVWordIterator => SVWordIterator(this)$/;"	f
sprintf	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def sprintf(buf: str, fmt: str, ...): i32$/;"	f
sprintf_unsafe	$OCEN_ROOT/std/libc/mod.oc	/^def sprintf_unsafe(buf: str, fmt: str, ...): i32$/;"	f
sqrt	$OCEN_ROOT/std/math.oc	/^[extern "sqrtf"] def f32::sqrt(this): f32$/;"	f
srand	$OCEN_ROOT/std/random.oc	/^    [extern] def srand(seed: u32)$/;"	f
start	$OCEN_ROOT/std/thread.oc	/^def Thread::start(&this) => check(.tid.create(null, .cb, .args))$/;"	f
start	$OCEN_ROOT/std/variadic.oc	/^[extern "va_start"] def VarArgs::start(this, ...)$/;"	f
start_and_join	$OCEN_ROOT/std/thread.oc	/^def Thread::start_and_join(&this) {$/;"	f
starts_right_after	$OCEN_ROOT/std/span.oc	/^def Span::starts_right_after(this, other: Span): bool {$/;"	f
starts_with	$OCEN_ROOT/compiler/lexer.oc	/^def Lexer::starts_with(&this, s: str): bool {$/;"	f
starts_with	$OCEN_ROOT/std/mod.oc	/^def str::starts_with(this, prefix: str): bool {$/;"	f
starts_with_str	$OCEN_ROOT/std/sv.oc	/^def SV::starts_with_str(this, other: str): bool => .starts_with_sv(SV::from_str(other))$/;"	f
starts_with_sv	$OCEN_ROOT/std/sv.oc	/^def SV::starts_with_sv(this, other: SV): bool {$/;"	f
stat	$OCEN_ROOT/std/fs.oc	/^    [extern] def stat(path: str, buf: &FileStat): i32$/;"	f
std	$OCEN_ROOT/std/sdl/gfx.oc	/^[extern "trigonColor"]        def std::sdl::Renderer::draw_tri_color(&this, x1: i32, y1: i32, x2/;"	f
std	$OCEN_ROOT/std/sdl/image.oc	/^[extern "IMG_LoadTexture"] def std::sdl::Renderer::load_image(&this, path: str): &Texture$/;"	f
stop	$OCEN_ROOT/std/timer.oc	/^def Timer::stop(&this) {$/;"	f
str	$OCEN_ROOT/compiler/errors.oc	/^def MessageType::str(this): str => match this {$/;"	f
str	$OCEN_ROOT/compiler/passes/code_generator.oc	/^def str::replace(&this, other: str) {$/;"	f
str	$OCEN_ROOT/compiler/tokens.oc	/^def TokenType::str(this): str => match this {$/;"	f
str	$OCEN_ROOT/compiler/types.oc	/^def Type::str(&this): str => match .base {$/;"	f
str	$OCEN_ROOT/std/buffer.oc	/^def Buffer::str(this): str => .data as str$/;"	f
str	$OCEN_ROOT/std/curl.oc	/^[extern "curl_easy_strerror"] def Status::str(this): str$/;"	f
str	$OCEN_ROOT/std/mod.oc	/^def str::to_u32(this): u32 => this.to_i32() as u32 \/\/ FIXME: this doesn't always work$/;"	f
str	$OCEN_ROOT/std/span.oc	/^def Span::str(this): str => `{.start.str()} => {.end.str()}`$/;"	f
str	$OCEN_ROOT/std/traits/compare.oc	/^def str::compare(this, b: str): i8 => std::libc::strcmp(this, b).compare(0)$/;"	f
str	$OCEN_ROOT/std/traits/hash.oc	/^def str::hash(this): u32 => hash_bytes(this as &u8, this.len())$/;"	f
str	$OCEN_ROOT/std/value.oc	/^def ValueType::str(this): str => .dbg()$/;"	f
strcat	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strcat(dst: str, src: str): str$/;"	f
strchr	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strchr(s: str, c: i32): str$/;"	f
strcmp	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strcmp(a: str, b: str): i32$/;"	f
strcpy	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strcpy(dst: str, src: str): str$/;"	f
strerror	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strerror(errnum: i32): str$/;"	f
strftime	$OCEN_ROOT/std/time.oc	/^[extern] def strftime(s: untyped_ptr, maxsize: u32, format: str, timeptr: &TM): u32$/;"	f
stringify	$OCEN_ROOT/std/hash/sha1.oc	/^def SHA1Hash::stringify(this): str {$/;"	f
strip_trailing_whitespace	$OCEN_ROOT/std/mod.oc	/^def str::strip_trailing_whitespace(this) {$/;"	f
strlen	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strlen(s: str): u32$/;"	f
strsep	$OCEN_ROOT/compiler/utils.oc	/^[extern] def strsep(s: &str, delim: str): str$/;"	f
strsep	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strsep(str: &str, delim: str): str$/;"	f
strstr	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strstr(haystack: str, needle: str): str$/;"	f
strtod	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strtod(s: str, endptr: &str): f64$/;"	f
strtof	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strtof(s: str, endptr: &str): f32$/;"	f
strtol	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strtol(s: str, endptr: &str, base: i32 = 10): i32$/;"	f
strtoll	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strtoll(s: str, endptr: &str, base: i32 = 10): i64$/;"	f
strtoul	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def strtoul(s: str, endptr: &str, base: i32 = 10): u64$/;"	f
struct	$OCEN_ROOT/compiler/passes/code_generator.oc	/^    .out <<= `typedef struct {type_name} {type_name};\\n`$/;"	f
sub	$OCEN_ROOT/std/complex.oc	/^def Complex::sub(this, other: Complex): Complex {$/;"	f
sub	$OCEN_ROOT/std/vec.oc	/^[operator "-"] def Vec3::sub(this, other: Vec3<T>): Vec3<T> => Vec3<T>(.x - other.x, .y - other./;"	f
subrs	$OCEN_ROOT/std/vec.oc	/^[operator "-"] def Vec3::subrs(val: T, this: Vec3<T>): Vec3<T> => Vec3<T>(val - this.x, val - th/;"	f
subs	$OCEN_ROOT/std/vec.oc	/^[operator "-"] def Vec3::subs(this, val: T): Vec3<T> => Vec3<T>(.x - val, .y - val, .z - val)$/;"	f
substring	$OCEN_ROOT/std/mod.oc	/^def str::substring(this, start: u32, len: u32): str {$/;"	f
subtract	$OCEN_ROOT/std/set.oc	/^def Set::subtract(&this, other: &Set<T>) {$/;"	f
sv	$OCEN_ROOT/std/buffer.oc	/^def Buffer::sv(this): SV => SV(.data as str, .size)$/;"	f
swap	$OCEN_ROOT/std/heap.oc	/^def Heap::swap(&this, a: u32, b: u32) {$/;"	f
symbol	$OCEN_ROOT/compiler/ast/nodes.oc	/^def AST::symbol(&this): &Symbol => .resolved_symbol$/;"	f
symbol_def_obj	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def LSPServer::symbol_def_obj(&this, obj: &Value): &Value {$/;"	f
sync_toplevel	$OCEN_ROOT/compiler/parser.oc	/^def Parser::sync_toplevel(&this) {$/;"	f
system	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def system(cmd: str): i32$/;"	f
tan	$OCEN_ROOT/std/complex.oc	/^[extern "ctanf"] def Complex::tan(this): Complex$/;"	f
tan	$OCEN_ROOT/std/math.oc	/^[extern "tanf"] def f32::tan(this): f32$/;"	f
text	$OCEN_ROOT/std/mui.oc	/^def Context::text(&this, text: str) {$/;"	f
text_height_callback	$OCEN_ROOT/std/mui_og/mod.oc	/^def text_height_callback(font: mui::Font): i32 {$/;"	f
text_height_callback	$OCEN_ROOT/std/ogui/mod.oc	/^def text_height_callback(font: mui::Font): i32 {$/;"	f
text_width_callback	$OCEN_ROOT/std/mui_og/mod.oc	/^def text_width_callback(font: mui::Font, text: str, len: i32): i32 {$/;"	f
text_width_callback	$OCEN_ROOT/std/ogui/mod.oc	/^def text_width_callback(font: mui::Font, text: str, len: i32): i32 {$/;"	f
textbox	$OCEN_ROOT/std/mui.oc	/^def Context::textbox(&this, buf: str, bufsz: i32, opt: Opt = 0): Res {$/;"	f
textbox_raw	$OCEN_ROOT/std/mui.oc	/^def Context::textbox_raw(&this, buf: str, bufsz: i32, id: u32, r: Rect, opt: Opt): Res {$/;"	f
ticks_to_seconds	$OCEN_ROOT/std/midi.oc	/^def Parser::ticks_to_seconds(&this, ticks: u64): f64 {$/;"	f
time	$OCEN_ROOT/std/time.oc	/^[extern] def time(t: &Time): Time$/;"	f
tmp_copy_str	$OCEN_ROOT/std/mui.oc	/^def Context::tmp_copy_str(&this, s: str): str {$/;"	f
to	$OCEN_ROOT/compiler/passes/register_types.oc	/^def Finder::to(this, name: str, error: bool = true): Finder {$/;"	f
to_color	$OCEN_ROOT/compiler/errors.oc	/^def MessageType::to_color(this): str => match this {$/;"	f
to_f32	$OCEN_ROOT/std/mod.oc	/^[extern "atof"] def str::to_f32(this): f32$/;"	f
to_f32	$OCEN_ROOT/std/vec.oc	/^def Vec3::to_f32(this): Vec3f => Vec3f(.x as f32, .y as f32, .z as f32)$/;"	f
to_f64	$OCEN_ROOT/std/vec.oc	/^def Vec3::to_f64(this): Vec3f64 => Vec3f64(.x as f64, .y as f64, .z as f64)$/;"	f
to_i32	$OCEN_ROOT/std/mod.oc	/^[extern "atoi"] def str::to_i32(this): i32$/;"	f
to_i32	$OCEN_ROOT/std/vec.oc	/^def Vec3::to_i32(this): Vec3i => Vec3i(.x as i32, .y as i32, .z as i32)$/;"	f
to_i64	$OCEN_ROOT/std/vec.oc	/^def Vec3::to_i64(this): Vec3i64 => Vec3i64(.x as i64, .y as i64, .z as i64)$/;"	f
to_u32	$OCEN_ROOT/std/mod.oc	/^def str::to_u32(this): u32 => this.to_i32() as u32 \/\/ FIXME: this doesn't always work$/;"	f
to_u32	$OCEN_ROOT/std/vec.oc	/^def Vec3::to_u32(this): Vec3u => Vec3u(.x as u32, .y as u32, .z as u32)$/;"	f
to_u64	$OCEN_ROOT/std/vec.oc	/^def Vec3::to_u64(this): Vec3u64 => Vec3u64(.x as u64, .y as u64, .z as u64)$/;"	f
toggle_fullscreen	$OCEN_ROOT/std/og/mod.oc	/^def toggle_fullscreen() {$/;"	f
token	$OCEN_ROOT/compiler/parser.oc	/^def Parser::token(&this): &Token {$/;"	f
token	$OCEN_ROOT/std/json.oc	/^def Parser::token(&this): &Token => .tokens.at(.curr)$/;"	f
token_is	$OCEN_ROOT/compiler/parser.oc	/^def Parser::token_is(&this, type: TokenType): bool {$/;"	f
token_is_eof_or	$OCEN_ROOT/compiler/parser.oc	/^def Parser::token_is_eof_or(&this, type: TokenType): bool {$/;"	f
token_is_identifier	$OCEN_ROOT/compiler/parser.oc	/^def Parser::token_is_identifier(&this, name: str): bool => .token().is_identifier(name)$/;"	f
tolower	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def tolower(c: char): char$/;"	f
toupper	$OCEN_ROOT/std/libc/mod.oc	/^[extern] def toupper(c: char): char$/;"	f
transform	$OCEN_ROOT/std/hash/sha256.oc	/^def Context::transform(&this, data: &u8) {$/;"	f
transpose	$OCEN_ROOT/std/matrix.oc	/^def Matrix4f::transpose(this): Matrix4f {$/;"	f
trim	$OCEN_ROOT/std/sv.oc	/^def SV::trim(&this) {$/;"	f
trim_left	$OCEN_ROOT/std/sv.oc	/^def SV::trim_left(&this) {$/;"	f
trim_right	$OCEN_ROOT/std/sv.oc	/^def SV::trim_right(&this) {$/;"	f
truncate	$OCEN_ROOT/std/fs.oc	/^def File::truncate(&this, size: i64) {$/;"	f
try_bind	$OCEN_ROOT/std/socket.oc	/^def Socket::try_bind(host: str, port: i32, mode: SocketMode, out_sock: &Socket): SocketStatus {$/;"	f
try_bind_tcp	$OCEN_ROOT/std/socket.oc	/^def Socket::try_bind_tcp(host: str, port: i32, out_sock: &Socket): SocketStatus {$/;"	f
try_bind_udp	$OCEN_ROOT/std/socket.oc	/^def Socket::try_bind_udp(host: str, port: i32, out_sock: &Socket): SocketStatus {$/;"	f
try_connect	$OCEN_ROOT/std/socket.oc	/^def Socket::try_connect(host: str, port: i32, mode: SocketMode, out_sock: &Socket, timeout_secs:/;"	f
try_gen_expr_string	$OCEN_ROOT/compiler/lsp/cli/utils.oc	/^def try_gen_expr_string(expr: &AST): str => match expr.type {$/;"	f
try_get	$OCEN_ROOT/compiler/passes/register_types.oc	/^def Finder::try_get(this, name: str): Finder => .to(name, error: false)$/;"	f
try_infer_array_size	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::try_infer_array_size(&this, arr_typ: &ArrayType) {$/;"	f
try_load_mod_for_namespace	$OCEN_ROOT/compiler/parser.oc	/^def Parser::try_load_mod_for_namespace(&this, ns: &Namespace) {$/;"	f
try_lock	$OCEN_ROOT/std/thread.oc	/^def Mutex::try_lock(&this): i32 => .tx.trylock()$/;"	f
try_resolve_typedefs_in_namespace	$OCEN_ROOT/compiler/passes/typechecker.oc	/^def TypeChecker::try_resolve_typedefs_in_namespace(&this, ns: &Namespace, pre_import: bool) {$/;"	f
try_unlock	$OCEN_ROOT/std/thread.oc	/^def Mutex::try_unlock(&this): i32 => .tx.tryunlock()$/;"	f
trylock	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_mutex_trylock"]   def Mutex::trylock(&this): i32$/;"	f
tryunlock	$OCEN_ROOT/std/thread.oc	/^    [extern "pthread_mutex_tryunlock"] def Mutex::tryunlock(&this): i32$/;"	f
type	$OCEN_ROOT/compiler/passes/typechecker.oc	/^    assert type_sym.type == Structure, `Got non-struct type in check_constructor: {type_sym.type/;"	f
typecheck_and_log_errors	$OCEN_ROOT/compiler/lsp/cli/mod.oc	/^def typecheck_and_log_errors(program: &Program, path: str) {$/;"	f
types	$OCEN_ROOT/compiler/passes/typechecker.oc	/^                    .error(Error::new(node.span, "Can only use `is` with enum types"))$/;"	f
u16	$OCEN_ROOT/std/traits/compare.oc	/^def u16::compare(this, b: u16): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
u16	$OCEN_ROOT/std/traits/eq.oc	/^def u16::eq(this, other: u16): bool => this == other$/;"	f
u16	$OCEN_ROOT/std/traits/hash.oc	/^def u16::hash(this): u32 => this as u32 * 7817$/;"	f
u32	$OCEN_ROOT/std/math.oc	/^def u32::clamp(this, min: u32, max: u32): u32 => u32::max(u32::min(this, max), min)$/;"	f
u32	$OCEN_ROOT/std/mod.oc	/^def u32::min(this, other: u32): u32 => if this < other then this else other$/;"	f
u32	$OCEN_ROOT/std/traits/compare.oc	/^def u32::compare(this, b: u32): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
u32	$OCEN_ROOT/std/traits/eq.oc	/^def u32::eq(this, other: u32): bool => this == other$/;"	f
u32	$OCEN_ROOT/std/traits/hash.oc	/^def u32::hash(this): u32 => this as u32 * 7817$/;"	f
u64	$OCEN_ROOT/std/mod.oc	/^def u64::min(this, other: u64): u64 => if this < other then this else other$/;"	f
u64	$OCEN_ROOT/std/traits/compare.oc	/^def u64::compare(this, b: u64): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
u64	$OCEN_ROOT/std/traits/eq.oc	/^def u64::eq(this, other: u64): bool => this == other$/;"	f
u64	$OCEN_ROOT/std/traits/hash.oc	/^def u64::hash(this): u32 => pair_hash((this as u32).hash(), ((this >> 32) as u32).hash())$/;"	f
u8	$OCEN_ROOT/std/mod.oc	/^def u8::min(this, other: u8): u8 => if this < other then this else other$/;"	f
u8	$OCEN_ROOT/std/traits/compare.oc	/^def u8::compare(this, b: u8): i8 => (this > b) as i8 - (this < b) as i8$/;"	f
u8	$OCEN_ROOT/std/traits/eq.oc	/^def u8::eq(this, other: u8): bool => this == other$/;"	f
u8	$OCEN_ROOT/std/traits/hash.oc	/^def u8::hash(this): u32 => this as u32 * 7817$/;"	f
uLongf	$OCEN_ROOT/std/zlib.oc	/^    [extern] struct uLongf {}$/;"	f
uint16_t	$OCEN_ROOT/std/prelude.h	/^typedef uint16_t u16;$/;"	f
uint32_t	$OCEN_ROOT/std/prelude.h	/^typedef uint32_t u32;$/;"	f
uint64_t	$OCEN_ROOT/std/prelude.h	/^typedef uint64_t u64;$/;"	f
uint8_t	$OCEN_ROOT/std/prelude.h	/^typedef uint8_t u8;$/;"	f
unaliased	$OCEN_ROOT/compiler/types.oc	/^def Type::unaliased(&this): &Type {$/;"	f
unchecked_at	$OCEN_ROOT/std/vector.oc	/^def Vector::unchecked_at(&this, i: u32): T => .data[i]$/;"	f
unchecked_pop	$OCEN_ROOT/std/heap.oc	/^def Heap::unchecked_pop(&this): T {$/;"	f
unchecked_pop	$OCEN_ROOT/std/vector.oc	/^def Vector::unchecked_pop(&this): T {$/;"	f
unescape_buf	$OCEN_ROOT/compiler/lsp/server/mod.oc	/^def unescape_buf(buf: &Buffer) {$/;"	f
unhandled_type	$OCEN_ROOT/compiler/parser.oc	/^def Parser::unhandled_type(&this, func: str) {$/;"	f
union	$OCEN_ROOT/compiler/passes/code_generator.oc	/^        .out <<= `typedef union {strufull_name} {strufull_name};\\n`$/;"	f
unlock	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_UnlockTexture"]  def Texture::unlock(&this)$/;"	f
unlock	$OCEN_ROOT/std/thread.oc	/^def Mutex::unlock(&this) => check(.tx.unlock())$/;"	f
unset_global	$OCEN_ROOT/std/gc.oc	/^def unset_global(ptr: untyped_ptr): untyped_ptr {$/;"	f
untyped_ptr	$OCEN_ROOT/std/traits/eq.oc	/^def untyped_ptr::eq(this, other: untyped_ptr): bool => this == other/;"	f
untyped_ptr	$OCEN_ROOT/std/traits/hash.oc	/^def untyped_ptr::hash(this): u32 => ptr_hash(this)$/;"	f
unwrap_or	$OCEN_ROOT/std/option.oc	/^def Option::unwrap_or(this, defolt: T): T => match this {$/;"	f
unwrap_or	$OCEN_ROOT/std/result.oc	/^def Result::unwrap_or(this, defolt: T): T => match this {$/;"	f
update	$OCEN_ROOT/std/hash/sha256.oc	/^def Context::update(&this, data: &u8, len: u64) {$/;"	f
update_control	$OCEN_ROOT/std/mui.oc	/^def Context::update_control(&this, id: u32, rect: Rect, opt: Opt) {$/;"	f
update_parent	$OCEN_ROOT/compiler/ast/scopes.oc	/^def Symbol::update_parent(&this, parent: &Symbol) {$/;"	f
update_window_size	$OCEN_ROOT/std/og/state.oc	/^def update_window_size() {$/;"	f
usage	$OCEN_ROOT/compiler/main.oc	/^def usage(code: i32, full: bool) {$/;"	f
usage_and_exit	$OCEN_ROOT/std/argparse.oc	/^def Parser::usage_and_exit(&this, code: i32) {$/;"	f
usleep	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def usleep(a: u32): i32$/;"	f
validate	$OCEN_ROOT/compiler/attributes.oc	/^def Attribute::validate(&this, parser_for_errors: &Parser): bool {$/;"	f
value	$OCEN_ROOT/std/map.oc	/^def Iterator::value(&this): V {$/;"	f
value_from_hex	$OCEN_ROOT/std/mod.oc	/^def char::value_from_hex(this): u8 {$/;"	f
values	$OCEN_ROOT/compiler/attributes.oc	/^    Flags           \/\/ [flags]                                  to specify that an enum values/;"	f
var_or_alias_symbol	$OCEN_ROOT/compiler/ast/nodes.oc	/^def MatchCondArg::var_or_alias_symbol(&this): &Symbol {$/;"	f
variant	$OCEN_ROOT/compiler/parser.oc	/^                else => .error(Error::new(attr.span, "Invalid attribute for value enum variant")/;"	f
variant	$OCEN_ROOT/compiler/passes/code_generator.oc	/^         2. All enum variant values are captured and available in the body$/;"	f
variant	$OCEN_ROOT/compiler/passes/register_types.oc	/^                var.sym.span, `Duplicate enum variant: {var.sym.name}`,$/;"	f
variant	$OCEN_ROOT/compiler/passes/typechecker.oc	/^                expr.span, f"Expected value enum variant, got {resolved_sym.type} ({resolved_sym/;"	f
variants	$OCEN_ROOT/compiler/parser.oc	/^                .error(Error::new(start.span + end.span, "Extern value enum variants cannot have/;"	f
verify_structure_has_field	$OCEN_ROOT/compiler/passes/generic_pass.oc	/^def GenericPass::verify_structure_has_field(&this, type: &Type, field_name: str, span: Span): &T/;"	f
visit_po	$OCEN_ROOT/compiler/passes/visitor.oc	/^def Visitor::visit_po(&this, node: &AST) {$/;"	f
visit_var	$OCEN_ROOT/compiler/passes/visitor.oc	/^def Visitor::visit_var(&this, var: &Variable) {$/;"	f
vlog	$OCEN_ROOT/std/logging.oc	/^def vlog(level: LogLevel, fmt: str, vargs: VarArgs) {$/;"	f
volume	$OCEN_ROOT/std/sdl/mixer.oc	/^[extern "Mix_Volume"] def volume(channel: i32, volume: i32)/;"	f
vprintf	$OCEN_ROOT/std/variadic.oc	/^[extern] def vprintf(format: str, args: VarArgs): u32$/;"	f
vsnprintf	$OCEN_ROOT/std/variadic.oc	/^[extern] def vsnprintf(buffer: str, size: u32, format: str, args: VarArgs): u32$/;"	f
vsprintf	$OCEN_ROOT/std/variadic.oc	/^[extern] def vsprintf(buffer: str, format: str, args: VarArgs): u32$/;"	f
wait	$OCEN_ROOT/std/thread.oc	/^def Barrier::wait(&this) {$/;"	f
wait_and_finish	$OCEN_ROOT/std/video_renderer/mod.oc	/^def VideoRenderer::wait_and_finish(&this) {$/;"	f
wait_event_timeout	$OCEN_ROOT/std/sdl/mod.oc	/^[extern "SDL_WaitEventTimeout"] def wait_event_timeout(event: &Event, timeout: i32): bool$/;"	f
wait_for_quit	$OCEN_ROOT/std/video_renderer/sdl.oc	/^def SDLContext::wait_for_quit(&this) {$/;"	f
waitpid	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def waitpid(a: i32, b: &i32, c: i32): i32$/;"	f
write	$OCEN_ROOT/std/fs.oc	/^def File::write(&this, buf: untyped_ptr, size: u32): i32 {$/;"	f
write	$OCEN_ROOT/std/libc/unistd.oc	/^[extern] def write(a: i32, b: untyped_ptr, c: u32): i32$/;"	f
write	$OCEN_ROOT/std/socket.oc	/^def TcpStream::write(&this, buf: &Buffer): u32 {$/;"	f
write_bit	$OCEN_ROOT/std/bitio.oc	/^def BitWriter::write_bit(&this, bit: u8) {$/;"	f
write_buf	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_buf(&this, buf: &Buffer) {$/;"	f
write_buf_f	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_buf_f(&this, buf: &Buffer) {$/;"	f
write_bytes	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_bytes(&this, bytes: untyped_ptr, size: u32) {$/;"	f
write_callback	$OCEN_ROOT/std/curl.oc	/^    def write_callback($/;"	f
write_char	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_char(&this, c: char) => .write_u8(c as u8)$/;"	f
write_file	$OCEN_ROOT/std/fs.oc	/^def write_file(path: str, data: Buffer) {$/;"	f
write_file_bytes	$OCEN_ROOT/std/fs.oc	/^def write_file_bytes(path: str, data: untyped_ptr, size: u32) {$/;"	f
write_file_str	$OCEN_ROOT/std/fs.oc	/^def write_file_str(path: str, data: str) {$/;"	f
write_i16	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_i16(&this, value: i16, endian: Endian = Big) { .write_u16(value as u16, endian/;"	f
write_i32	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_i32(&this, value: i32, endian: Endian = Big) { .write_u32(value as u32, endian/;"	f
write_i64	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_i64(&this, value: i64, endian: Endian = Big) { .write_u64(value as u64, endian/;"	f
write_i8	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_i8(&this, value: i8) { .write_u8(value as u8) }$/;"	f
write_image	$OCEN_ROOT/std/sdl/mod.oc	/^def Texture::write_image(&this, img: &Image) {$/;"	f
write_str	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_str(&this, s: str) {$/;"	f
write_str_f	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_str_f(&this, s: str) {$/;"	f
write_sv	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_sv(&this, sv: SV) => .write_bytes(sv.data as &u8, sv.len)$/;"	f
write_to_file	$OCEN_ROOT/std/json.oc	/^def write_to_file(val: &Value, filename: str) {$/;"	f
write_u16	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_u16(&this, value: u16, endian: Endian = Big) {$/;"	f
write_u32	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_u32(&this, value: u32, endian: Endian = Big) {$/;"	f
write_u64	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_u64(&this, value: u64, endian: Endian = Big) {$/;"	f
write_u8	$OCEN_ROOT/std/bitio.oc	/^def BitWriter::write_u8(&this, byte: u8) {$/;"	f
write_u8	$OCEN_ROOT/std/buffer.oc	/^def Buffer::write_u8(&this, value: u8) {$/;"	f
zero	$OCEN_ROOT/std/fcntl.oc	/^[extern "FD_ZERO"] def FdSet::zero(&this)$/;"	f
zero_unused	$OCEN_ROOT/std/vector.oc	/^def Vector::zero_unused(&this) {$/;"	f
